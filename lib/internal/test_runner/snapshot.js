'use strict';
const {
  ArrayIsArray,
  ArrayPrototypeJoin,
  ArrayPrototypeMap,
  ArrayPrototypeSlice,
  ArrayPrototypeSort,
  JSONStringify,
  MapPrototypeForEach,
  ObjectKeys,
  SafeMap,
  String,
  StringPrototypeEndsWith,
  StringPrototypeReplaceAll,
  StringPrototypeSlice,
  StringPrototypeStartsWith,
} = primordials;
const {
  codes: {
    ERR_INVALID_STATE,
  },
} = require('internal/errors');
const { kEmptyObject } = require('internal/util');
const { getCallSites } = require('util');
let debug = require('internal/util/debuglog').debuglog('test_runner', (fn) => {
  debug = fn;
});
const {
  validateArray,
  validateFunction,
  validateObject,
  validateString,
} = require('internal/validators');
const { strictEqual } = require('assert');
const { mkdirSync, readFileSync, writeFileSync } = require('fs');
const { URL } = require('internal/url');
const { dirname } = require('path');
const { createContext, runInContext } = require('vm');
const acornParser = require('internal/deps/acorn/acorn/dist/acorn').Parser;
const acornWalk = require('internal/deps/acorn/acorn-walk/dist/walk');
const kMissingSnapshotTip = 'Missing snapshots can be generated by rerunning ' +
  'the command with the --test-update-snapshots flag.';
const kMissingInlineSnapshotTip = 'Missing inline snapshots can be generated by rerunning ' +
  'the command with the --test-update-snapshots flag.'; // New constant.
const defaultSerializers = [
  (value) => { return JSONStringify(value, null, 2); },
];

/**
 * Manages inline snapshot operations for test files.
 */
class InlineSnapshotManager {
  /**
   * @param {boolean} updateSnapshots - Whether to update snapshots or validate them
   */
  constructor(updateSnapshots) {
    this.updateSnapshots = updateSnapshots;
    this.inlineEvents = []; // Recorded inline snapshot operations (insert/replace).
    this._inlineFileCache = new SafeMap(); // filePath -> { source, ast }
    // TODO(pmarchini): detect source drift before applying edits.
  }

  /* eslint-disable-next-line jsdoc/require-returns-check */
  /**
   * Serializes input for inline snapshots, applying template literal escaping.
   * @param {any} input - The value to serialize
   * @param {Function[]} [serializers] - Array of serializer functions to apply
   * @returns {string} The serialized and escaped string suitable for template literals
   * @throws {ERR_INVALID_STATE} When serialization fails
   */
  serializeInline(input, serializers = serializerFns) {
    try {
      const value = this.#serializeForInlineSnapshot(input, serializers);
      return templateEscape(value);
    } catch (err) {
      throwSerializationError(input, err);
    }
  }

  /**
   * Serializes input values specifically for inline snapshot usage.
   * Handles strings, primitives, and complex objects differently.
   * @param {any} input - The value to serialize
   * @param {Function[]} serializers - Array of serializer functions
   * @returns {string} The serialized value
   * @private
   */
  #serializeForInlineSnapshot(input, serializers) {
    if (typeof input === 'string') {
      // For strings, keep them as-is rather than JSON.stringify
      // This preserves the natural string representation in the JS file
      return input;
    }

    if (typeof input === 'number' || typeof input === 'boolean' || input === null || input === undefined) {
      // For primitives, convert directly to string representation
      return String(input);
    }

    // For objects and arrays, use the standard serializer chain (JSON.stringify with formatting)
    return serializeValue(input, serializers);
  }

  /**
   * Creates an inline snapshot assertion function bound to a specific file context.
   * @param {string} contextFilePath - The file path where the assertion is called
   * @returns {Function} The inline snapshot assertion function
   */
  createInlineAssertion(contextFilePath) {
    const manager = this;
    return function inlineSnapshotAssertion(actual, expected) {
      const body = manager.serializeInline(actual);
      const normalized = manager.#normalizeInlineSnapshot(body);

      const callSite = manager.#getInlineSnapshotCallSite(contextFilePath);

      if (manager.updateSnapshots) {
        manager.#handleSnapshotUpdate(callSite, body, expected);
        return;
      }

      manager.#validateInlineSnapshot(normalized, expected, callSite.filePath);
    };
  }

  /**
   * Normalizes inline snapshot content by adding leading and trailing newlines.
   * @param {string} body - The snapshot content to normalize
   * @returns {string} The normalized snapshot content
   * @private
   */
  #normalizeInlineSnapshot(body) {
    return `\n${body}\n`;
  }

  /**
   * Retrieves the call site information for an inline snapshot.
   * Uses V8's stack trace API to find the specific location of the inlineSnapshot call.
   * @param {string} contextFilePath - The file path context to search within
   * @returns {{filePath: string, line: number, column: number}} Call site information
   * @private
   */
  #getInlineSnapshotCallSite(contextFilePath) {
    try {
      const sites = getCallSites(200);
      if (!ArrayIsArray(sites)) {
        throw new ERR_INVALID_STATE('Unable to retrieve call stack for inline snapshot');
      }

      const target = this.#findInlineSnapshotCallSite(sites, contextFilePath);
      if (!target) {
        throw new ERR_INVALID_STATE('Unable to locate inline snapshot call site in stack trace');
      }

      return {
        __proto__: null,
        filePath: contextFilePath || target.scriptName,
        line: target.lineNumber,
        column: target.columnNumber != null ? (target.columnNumber - 1) : undefined,
      };
    } catch (error) {
      if (error.code === 'ERR_INVALID_STATE') {
        throw error;
      }
      throw new ERR_INVALID_STATE(
        'Failed to analyze call stack for inline snapshot',
        { __proto__: null, cause: error });
    }
  }

  /**
   * Normalizes a file path or URL to a consistent file path format.
   * @param {string} pathOrUrl - The path or URL to normalize
   * @returns {string|null} The normalized file path, or null if parsing fails
   * @private
   */
  #normalizeFilePath(pathOrUrl) {
    if (!pathOrUrl) return null;

    // If it's already a regular file path, return as-is
    if (!StringPrototypeStartsWith(pathOrUrl, 'file://')) {
      return pathOrUrl;
    }

    // Convert file:// URL to file path
    try {
      return new URL(pathOrUrl).pathname;
    } catch {
      return null;
    }
  }

  /**
   * Finds the inline snapshot call site within the V8 stack trace.
   * @param {Array<import('util').CallSite>} sites - Array of V8 CallSite objects
   * @param {string} contextFilePath - The file path to search within
   * @returns {import('util').CallSite} The matching call site
   * @throws {ERR_INVALID_STATE} When no matching call site is found
   * @private
   */
  #findInlineSnapshotCallSite(sites, contextFilePath) {
    if (!contextFilePath) {
      throw new ERR_INVALID_STATE('Context file path is required to find inline snapshot call site.');
    }

    const normalizedContextPath = this.#normalizeFilePath(contextFilePath);
    if (!normalizedContextPath) {
      throw new ERR_INVALID_STATE(`Failed to normalize context file path: '${contextFilePath}'.`);
    }

    for (let i = 0; i < sites.length; i++) {
      const site = sites[i];
      if (!site || !site.scriptName) continue;

      const normalizedSitePath = this.#normalizeFilePath(site.scriptName);
      if (normalizedSitePath && normalizedSitePath === normalizedContextPath) {
        return site;
      }
    }

    throw new ERR_INVALID_STATE(`No matching call site found for '${contextFilePath}' in the stack trace.`);
  }

  /**
   * Records an inline snapshot event for later file updates.
   * @param {{filePath: string, line: number, column: number}} callSite - The call location
   * @param {string} body - The serialized snapshot content
   * @param {string|undefined} expected - The existing snapshot value (if any)
   * @private
   */
  #handleSnapshotUpdate(callSite, body, expected) {
    this.#recordInlineEvent({
      __proto__: null,
      // TODO(pmarchini): use the kind to report snapshot insertion/replacement
      kind: expected !== undefined ? 'replace' : 'insert',
      filePath: callSite.filePath,
      line: callSite.line,
      column: callSite.column,
      value: body,
    });
  }

  /**
   * Validates an inline snapshot against the expected value.
   * @param {string} normalized - The normalized actual snapshot content
   * @param {string|undefined} expected - The expected snapshot value from the source
   * @param {string} filePath - The file path for error reporting
   * @throws {ERR_INVALID_STATE} When snapshot is missing or mismatched
   * @private
   */
  #validateInlineSnapshot(normalized, expected, filePath) {
    if (expected === undefined) {
      const err = new ERR_INVALID_STATE(`Missing inline snapshots. ${kMissingInlineSnapshotTip}`);
      if (filePath) err.filename = filePath;
      throw err;
    }

    const expectedNormalized = this.#normalizeExpectedSnapshot(expected);

    try {
      strictEqual(normalized, expectedNormalized);
    } catch (comparisonError) {
      const err = new ERR_INVALID_STATE('Inline snapshot mismatch.');
      err.cause = comparisonError;
      if (filePath) err.filename = filePath;
      throw err;
    }
  }

  #normalizeExpectedSnapshot(expected) {
    let normalized = expected;
    StringPrototypeStartsWith(normalized, '\n') || (normalized = '\n' + normalized);
    StringPrototypeEndsWith(normalized, '\n') || (normalized = normalized + '\n');
    return normalized;
  }

  // Record an inline event (helper for later implementation).
  /**
   * Records an inline snapshot event for future file updates.
   * @param {object} ev - The event object containing snapshot update information
   * @param {string} ev.kind - The type of operation ('insert' or 'replace')
   * @param {string} ev.filePath - The file path where the snapshot is located
   * @param {number} ev.line - The line number of the snapshot call
   * @param {number} ev.column - The column number of the snapshot call
   * @param {string} ev.value - The serialized snapshot content
   * @private
   */
  #recordInlineEvent(ev) {
    this.inlineEvents.push(ev);
  }

  writeInlineSnapshotFiles() {
    if (!this.updateSnapshots) return;
    if (this.inlineEvents.length === 0) return;

    const eventsByFile = this.#groupInlineEventsByFile();

    MapPrototypeForEach(eventsByFile, (events, filePath) => {
      this.#updateInlineSnapshotsInFile(filePath, events);
    });

    this.inlineEvents.length = 0;
  }

  /**
   * Groups inline snapshot events by file path for batch processing.
   * @returns {SafeMap<string, Array<object>>} Map of file paths to their events
   * @private
   */
  #groupInlineEventsByFile() {
    const byFile = new SafeMap();
    for (const event of this.inlineEvents) {
      if (!event.filePath) continue;

      let fileEvents = byFile.get(event.filePath);
      if (fileEvents === undefined) {
        fileEvents = [];
        byFile.set(event.filePath, fileEvents);
      }
      fileEvents.push(event);
    }
    return byFile;
  }

  /**
   * Updates inline snapshots in a single file by applying generated edits.
   * @param {string} filePath - The path to the file to update
   * @param {Array<object>} events - Array of inline snapshot events for this file
   * @private
   */
  #updateInlineSnapshotsInFile(filePath, events) {
    let parsed;
    try {
      parsed = this.#getParsedInlineFile(filePath);
    } catch (error) {
      debug('inline snapshot: failed to parse %s: %s', filePath, error.message);
      return;
    }

    const edits = this.#generateFileEdits(filePath, events);
    if (edits.length === 0) return;

    const modifiedSource = this.#applyEditsToSource(parsed.source, edits);
    this.#writeModifiedFile(filePath, modifiedSource, edits.length);
  }

  /**
   * Generates source code edits for inline snapshot events.
   * @param {string} filePath - The file path for context
   * @param {Array<object>} events - Array of inline snapshot events
   * @returns {Array<object>} Array of edit objects with start, end, and text properties
   * @private
   */
  #generateFileEdits(filePath, events) {
    const edits = [];

    for (const event of events) {
      const edit = this.#createEditForEvent(filePath, event);
      if (edit) {
        edits.push(edit);
      }
    }

    return edits;
  }

  /**
   * Creates a single edit operation for an inline snapshot event.
   * @param {string} filePath - The file path for AST parsing
   * @param {object} event - The inline snapshot event
   * @returns {object | null} Edit object with start, end, text properties, or null if failed
   * @private
   */
  #createEditForEvent(filePath, event) {
    let callNode;
    try {
      callNode = this.#findInlineSnapshotCallAt(filePath, event.line, event.column);
    } catch (error) {
      debug('inline snapshot: cannot locate call at %s:%s:%s (%s)',
            filePath, event.line, event.column, error.message);
      return null;
    }

    if (!callNode) return null;

    const templateLiteral = this.#createTemplateLiteral(event.value);
    return this.#createEditFromCallNode(callNode, templateLiteral);
  }

  /**
   * Creates a template literal string representation for snapshot content.
   * @param {string} value - The snapshot content to wrap in template literal
   * @returns {string} Template literal string with backticks and newlines
   * @private
   */
  #createTemplateLiteral(value) {
    return '`\n' + value + '\n`';
  }

  /**
   * Creates an edit object from an Acorn CallExpression node and new template literal.
   * @param {object} callNode - Acorn CallExpression AST node
   * @param {string} templateLiteral - The new template literal string to insert
   * @returns {object} Edit object with start, end, and text properties
   * @private
   */
  #createEditFromCallNode(callNode, templateLiteral) {
    const args = callNode.arguments;

    if (args.length < 2) {
      // Insert second argument before closing parenthesis
      const insertionPoint = callNode.end - 1;
      return {
        __proto__: null,
        start: insertionPoint,
        end: insertionPoint,
        text: ', ' + templateLiteral,
      };
    }
    // Replace existing second argument
    const secondArg = args[1];
    return {
      __proto__: null,
      start: secondArg.start,
      end: secondArg.end,
      text: templateLiteral,
    };

  }

  /**
   * Applies an array of edits to source code, preserving character positions.
   * @param {string} source - The original source code
   * @param {Array<object>} edits - Array of edit objects with start, end, text properties
   * @returns {string} The modified source code
   * @private
   */
  #applyEditsToSource(source, edits) {
    // Sort edits from last to first to preserve character positions
    const sortedEdits = ArrayPrototypeSort(edits, (a, b) => b.start - a.start);

    let modifiedSource = source;
    for (const edit of sortedEdits) {
      modifiedSource = StringPrototypeSlice(modifiedSource, 0, edit.start) +
                       edit.text +
                       StringPrototypeSlice(modifiedSource, edit.end);
    }

    return modifiedSource;
  }

  /**
   * Writes the modified source code to a file.
   * @param {string} filePath - The file path to write to
   * @param {string} modifiedSource - The modified source code
   * @param {number} editCount - Number of edits applied (for debugging)
   * @private
   */
  #writeModifiedFile(filePath, modifiedSource, editCount) {
    try {
      writeFileSync(filePath, modifiedSource, 'utf8');
      debug('inline snapshot: wrote %s (%d edits)', filePath, editCount);
    } catch (error) {
      debug('inline snapshot: failed write %s: %s', filePath, error.message);
    }
  }

  /**
   * Gets parsed file information from cache or parses the file using Acorn.
   * @param {string} filePath - The file path to parse
   * @returns {{source: string, ast: object}} Object containing source code and Acorn AST
   * @private
   */
  #getParsedInlineFile(filePath) {
    let cached = this._inlineFileCache.get(filePath);
    if (cached) return cached;

    const source = this.#readSourceFile(filePath);
    const ast = this.#parseSourceToAST(source, filePath);

    cached = { __proto__: null, source, ast };
    this._inlineFileCache.set(filePath, cached);
    return cached;
  }

  /**
   * Reads source code from a file.
   * @param {string} filePath - The file path to read
   * @returns {string} The file contents as a string
   * @throws {ERR_INVALID_STATE} When file cannot be read
   * @private
   */
  #readSourceFile(filePath) {
    try {
      return readFileSync(filePath, 'utf8');
    } catch (error) {
      const err = new ERR_INVALID_STATE(`Cannot read test source for inline snapshots: '${filePath}'.`);
      err.cause = error;
      err.filename = filePath;
      throw err;
    }
  }

  /**
   * Parses JavaScript source code into an Acorn AST.
   * Attempts module parsing first, falls back to script parsing.
   * @param {string} source - The JavaScript source code to parse
   * @param {string} filePath - The file path for error reporting
   * @returns {object} Acorn AST object with node locations
   * @throws {ERR_INVALID_STATE} When source cannot be parsed
   * @private
   */
  #parseSourceToAST(source, filePath) {
    const parseOptions = {
      __proto__: null,
      ecmaVersion: 'latest',
      locations: true,
    };

    // Try parsing as module first, fallback to script
    try {
      return acornParser.parse(source, { __proto__: null, ...parseOptions, sourceType: 'module' });
    } catch {
      try {
        return acornParser.parse(source, { __proto__: null, ...parseOptions, sourceType: 'script' });
      } catch (error) {
        const err = new ERR_INVALID_STATE(`Cannot parse source file for inline snapshots: '${filePath}'.`);
        err.cause = error;
        err.filename = filePath;
        throw err;
      }
    }
  }

  /**
   * Lists all inline snapshot function calls in a file using Acorn AST walking.
   * @param {string} filePath - The file path to analyze
   * @returns {Array<object>} Array of Acorn CallExpression AST nodes
   * @private
   */
  #listInlineSnapshotCalls(filePath) {
    const { ast } = this.#getParsedInlineFile(filePath);
    const calls = [];

    acornWalk.simple(ast, {
      __proto__: null,
      CallExpression: (node) => {
        if (this.#isInlineSnapshotCall(node)) {
          calls.push(node);
        }
      },
    });

    return calls;
  }

  /**
   * Determines if an Acorn CallExpression node is an inline snapshot call.
   * Recognizes both direct calls and member expression calls.
   * TODO(pmarchini): Support destructured and renamed calls (e.g.,
   * const { inlineSnapshot: snap } = t.assert; snap(...))
   * @param {object} node - Acorn CallExpression AST node
   * @returns {boolean} True if the node represents an inlineSnapshot call
   * @private
   */
  #isInlineSnapshotCall(node) {
    const callee = node.callee;

    // Direct call: inlineSnapshot(...)
    if (callee.type === 'Identifier' && callee.name === 'inlineSnapshot') {
      return true;
    }

    // Member expression: t.assert.inlineSnapshot(...)
    if (callee.type === 'MemberExpression' && !callee.computed) {
      const property = callee.property;
      return property.type === 'Identifier' && property.name === 'inlineSnapshot';
    }

    return false;
  }

  /**
   * Finds an inline snapshot call at a specific line and column position.
   * @param {string} filePath - The file path containing the call
   * @param {number} line - The line number (1-based)
   * @param {number} column - The column number (0-based)
   * @returns {object | null} The matching Acorn CallExpression AST node, or null
   * @private
   */
  #findInlineSnapshotCallAt(filePath, line, column) {
    if (line == null || column == null) return null;

    const calls = this.#listInlineSnapshotCalls(filePath);
    return this.#findBestMatchingNode(calls, line, column);
  }

  /**
   * Finds the best matching AST node at a specific position.
   * Prefers the node with the smallest span when multiple nodes match.
   * @param {Array<object>} nodes - Array of Acorn AST nodes to search
   * @param {number} line - The target line number (1-based)
   * @param {number} column - The target column number (0-based)
   * @returns {object | null} The best matching AST node, or null if none match
   * @private
   */
  #findBestMatchingNode(nodes, line, column) {
    let bestMatch = null;
    let smallestSpan = Infinity;

    for (const node of nodes) {
      if (this.#nodeContainsPosition(node, line, column)) {
        const span = this.#calculateNodeSpan(node);
        if (span < smallestSpan) {
          bestMatch = node;
          smallestSpan = span;
        }
      }
    }

    return bestMatch;
  }

  /**
   * Checks if an Acorn AST node contains a specific line and column position.
   * @param {object} node - Acorn AST node with location information
   * @param {number} line - The target line number (1-based)
   * @param {number} column - The target column number (0-based)
   * @returns {boolean} True if the node contains the position
   * @private
   */
  #nodeContainsPosition(node, line, column) {
    const { start: locStart, end: locEnd } = node.loc;

    if (line < locStart.line || line > locEnd.line) return false;
    if (line === locStart.line && column < locStart.column) return false;
    if (line === locEnd.line && column > locEnd.column) return false;

    return true;
  }

  /**
   * Calculates the span (size) of an Acorn AST node for comparison purposes.
   * @param {object} node - Acorn AST node with location information
   * @returns {number} A numeric representation of the node's span
   * @private
   */
  #calculateNodeSpan(node) {
    const { start: locStart, end: locEnd } = node.loc;
    return (locEnd.line - locStart.line) * 1e6 + (locEnd.column - locStart.column);
  }
}

function defaultResolveSnapshotPath(testPath) {
  if (typeof testPath !== 'string') {
    return testPath;
  }

  return `${testPath}.snapshot`;
}

let resolveSnapshotPathFn = defaultResolveSnapshotPath;
let serializerFns = defaultSerializers;

function setResolveSnapshotPath(fn) {
  validateFunction(fn, 'fn');
  resolveSnapshotPathFn = fn;
}

function setDefaultSnapshotSerializers(serializers) {
  validateFunctionArray(serializers, 'serializers');
  serializerFns = ArrayPrototypeSlice(serializers);
}

class SnapshotFile {
  constructor(snapshotFile) {
    this.snapshotFile = snapshotFile;
    this.snapshots = { __proto__: null };
    this.nameCounts = new SafeMap();
    this.loaded = false;
  }

  getSnapshot(id) {
    if (!(id in this.snapshots)) {
      const err = new ERR_INVALID_STATE(`Snapshot '${id}' not found in ` +
        `'${this.snapshotFile}.' ${kMissingSnapshotTip}`);
      err.snapshot = id;
      err.filename = this.snapshotFile;
      throw err;
    }

    return this.snapshots[id];
  }

  setSnapshot(id, value) {
    this.snapshots[escapeSnapshotKey(id)] = value;
  }

  nextId(name) {
    const count = this.nameCounts.get(name) ?? 1;
    this.nameCounts.set(name, count + 1);
    return `${name} ${count}`;
  }

  readFile() {
    if (this.loaded) {
      debug('skipping read of snapshot file');
      return;
    }

    try {
      const source = readFileSync(this.snapshotFile, 'utf8');
      const context = { __proto__: null, exports: { __proto__: null } };

      createContext(context);
      runInContext(source, context);

      if (context.exports === null || typeof context.exports !== 'object') {
        throw new ERR_INVALID_STATE(
          `Malformed snapshot file '${this.snapshotFile}'.`,
        );
      }

      for (const key in context.exports) {
        this.snapshots[key] = templateEscape(context.exports[key]);
      }
      this.loaded = true;
    } catch (err) {
      throwReadError(err, this.snapshotFile);
    }
  }

  writeFile() {
    try {
      const keys = ArrayPrototypeSort(ObjectKeys(this.snapshots));
      const snapshotStrings = ArrayPrototypeMap(keys, (key) => {
        return `exports[\`${key}\`] = \`${this.snapshots[key]}\`;\n`;
      });
      const output = ArrayPrototypeJoin(snapshotStrings, '\n');
      mkdirSync(dirname(this.snapshotFile), { __proto__: null, recursive: true });
      writeFileSync(this.snapshotFile, output, 'utf8');
    } catch (err) {
      throwWriteError(err, this.snapshotFile);
    }
  }
}

class SnapshotManager {
  constructor(updateSnapshots) {
    // A manager instance will only read or write snapshot files based on the
    // updateSnapshots argument.
    this.updateSnapshots = updateSnapshots;
    this.cache = new SafeMap();
    this.inlineManager = new InlineSnapshotManager(updateSnapshots);
  }

  resolveSnapshotFile(entryFile) {
    let snapshotFile = this.cache.get(entryFile);

    if (snapshotFile === undefined) {
      const resolved = resolveSnapshotPathFn(entryFile);

      if (typeof resolved !== 'string') {
        const err = new ERR_INVALID_STATE('Invalid snapshot filename.');
        err.filename = resolved;
        throw err;
      }

      snapshotFile = new SnapshotFile(resolved);
      snapshotFile.loaded = this.updateSnapshots;
      this.cache.set(entryFile, snapshotFile);
    }

    return snapshotFile;
  }

  serialize(input, serializers = serializerFns) {
    try {
      const value = serializeValue(input, serializers);
      return `\n${templateEscape(value)}\n`;
    } catch (err) {
      throwSerializationError(input, err);
    }
  }

  serializeWithoutEscape(input, serializers = serializerFns) {
    try {
      return serializeValue(input, serializers);
    } catch (err) {
      throwSerializationError(input, err);
    }
  }

  serializeInline(input, serializers = serializerFns) {
    return this.inlineManager.serializeInline(input, serializers);
  }

  writeSnapshotFiles() {
    if (!this.updateSnapshots) {
      debug('skipping write of snapshot files');
      return;
    }

    this.cache.forEach((snapshotFile) => {
      snapshotFile.writeFile();
    });
  }

  writeInlineSnapshotFiles() {
    return this.inlineManager.writeInlineSnapshotFiles();
  }

  createInlineAssert() {
    const snapshotManager = this;
    return function inlineSnapshotAssertion(actual, expected) {
      const inlineAssertion = snapshotManager.inlineManager.createInlineAssertion(this?.filePath);
      return inlineAssertion.call(this, actual, expected);
    };
  }

  createAssert() {
    const manager = this;

    return function snapshotAssertion(actual, options = kEmptyObject) {
      validateObject(options, 'options');
      const {
        serializers = serializerFns,
      } = options;
      validateFunctionArray(serializers, 'options.serializers');
      const { filePath, fullName } = this;
      const snapshotFile = manager.resolveSnapshotFile(filePath);
      const value = manager.serialize(actual, serializers);
      const id = snapshotFile.nextId(fullName);

      if (manager.updateSnapshots) {
        snapshotFile.setSnapshot(id, value);
      } else {
        snapshotFile.readFile();
        strictEqual(value, snapshotFile.getSnapshot(id));
      }
    };
  }

  createFileAssert() {
    const manager = this;

    return function fileSnapshotAssertion(actual, path, options = kEmptyObject) {
      validateString(path, 'path');
      validateObject(options, 'options');
      const {
        serializers = serializerFns,
      } = options;
      validateFunctionArray(serializers, 'options.serializers');
      const value = manager.serializeWithoutEscape(actual, serializers);

      if (manager.updateSnapshots) {
        try {
          mkdirSync(dirname(path), { __proto__: null, recursive: true });
          writeFileSync(path, value, 'utf8');
        } catch (err) {
          throwWriteError(err, path);
        }
      } else {
        let expected;

        try {
          expected = readFileSync(path, 'utf8');
        } catch (err) {
          throwReadError(err, path);
        }

        strictEqual(value, expected);
      }
    };
  }
}

function throwReadError(err, filename) {
  let msg = `Cannot read snapshot file '${filename}.'`;

  if (err?.code === 'ENOENT') {
    msg += ` ${kMissingSnapshotTip}`;
  }

  const error = new ERR_INVALID_STATE(msg);
  error.cause = err;
  error.filename = filename;
  throw error;
}

function throwWriteError(err, filename) {
  const msg = `Cannot write snapshot file '${filename}.'`;
  const error = new ERR_INVALID_STATE(msg);
  error.cause = err;
  error.filename = filename;
  throw error;
}

function throwSerializationError(input, err) {
  const error = new ERR_INVALID_STATE(
    'The provided serializers did not generate a string.',
  );
  error.input = input;
  error.cause = err;
  throw error;
}

function serializeValue(value, serializers) {
  let v = value;

  for (let i = 0; i < serializers.length; ++i) {
    const fn = serializers[i];
    v = fn(v);
  }

  return v;
}

function validateFunctionArray(fns, name) {
  validateArray(fns, name);
  for (let i = 0; i < fns.length; ++i) {
    validateFunction(fns[i], `${name}[${i}]`);
  }
}

function escapeSnapshotKey(str) {
  let result = JSONStringify(str, null, 2).slice(1, -1);
  result = StringPrototypeReplaceAll(result, '`', '\\`');
  result = StringPrototypeReplaceAll(result, '${', '\\${');
  return result;
}

function templateEscape(str) {
  let result = String(str);
  result = StringPrototypeReplaceAll(result, '\\', '\\\\');
  result = StringPrototypeReplaceAll(result, '`', '\\`');
  result = StringPrototypeReplaceAll(result, '${', '\\${');
  return result;
}

module.exports = {
  SnapshotManager,
  InlineSnapshotManager,
  defaultResolveSnapshotPath, // Exported for testing only.
  defaultSerializers,         // Exported for testing only.
  setDefaultSnapshotSerializers,
  setResolveSnapshotPath,
};

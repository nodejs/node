// This file is generated by Exported_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef {{"_".join(config.protocol.namespace)}}_{{domain.domain}}_api_h
#define {{"_".join(config.protocol.namespace)}}_{{domain.domain}}_api_h

{% if config.exported.export_header %}
#include {{format_include(config.exported.export_header)}}
{% endif %}
#include {{format_include(config.exported.string_header)}}

{% for namespace in config.protocol.namespace %}
namespace {{namespace}} {
{% endfor %}

#ifndef {{"_".join(config.protocol.namespace)}}_exported_api_h
#define {{"_".join(config.protocol.namespace)}}_exported_api_h
class {{config.exported.export_macro}} Exported {
public:
    virtual void AppendSerialized(std::vector<uint8_t>* out) const = 0;

    virtual ~Exported() { }
};
#endif // !defined({{"_".join(config.protocol.namespace)}}_exported_api_h)

namespace {{domain.domain}} {
namespace API {

// ------------- Enums.
  {% for type in domain.types %}
    {% if ("enum" in type) and protocol.is_exported(domain.domain, type.id) %}

namespace {{type.id}}Enum {
      {% for literal in type.enum %}
{{config.exported.export_macro}} extern const char* {{ literal | dash_to_camelcase}};
      {% endfor %}
} // {{type.id}}Enum
    {% endif %}
  {% endfor %}
  {% for command in join_arrays(domain, ["commands", "events"]) %}
    {% for param in join_arrays(command, ["parameters", "returns"]) %}
      {% if ("enum" in param) and protocol.is_exported(domain.domain, command.name + "." + param.name) %}

namespace {{command.name | to_title_case}} {
namespace {{param.name | to_title_case}}Enum {
        {% for literal in param.enum %}
{{config.exported.export_macro}} extern const char* {{ literal | dash_to_camelcase}};
        {% endfor %}
} // {{param.name | to_title_case}}Enum
} // {{command.name | to_title_case }}
      {% endif %}
    {% endfor %}
  {% endfor %}

// ------------- Types.
  {% for type in domain.types %}
    {% if not (type.type == "object") or not ("properties" in type) or not protocol.is_exported(domain.domain, type.id) %}{% continue %}{% endif %}

class {{config.exported.export_macro}} {{type.id}} : public Exported {
public:
    static std::unique_ptr<protocol::{{domain.domain}}::API::{{type.id}}> fromBinary(const uint8_t* data, size_t length);
};
  {% endfor %}

} // namespace API
} // namespace {{domain.domain}}
{% for namespace in config.protocol.namespace %}
} // namespace {{namespace}}
{% endfor %}

#endif // !defined({{"_".join(config.protocol.namespace)}}_{{domain.domain}}_api_h)

// This file is generated by Forward_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef {{"_".join(config.protocol.namespace)}}_Forward_h
#define {{"_".join(config.protocol.namespace)}}_Forward_h

{% if config.lib.export_header %}
#include {{format_include(config.lib.export_header)}}
{% endif %}

#include <memory>
#include <vector>

#include "{{config.crdtp.dir}}/error_support.h"
#include "{{config.crdtp.dir}}/dispatch.h"
#include "{{config.crdtp.dir}}/frontend_channel.h"
#include "{{config.crdtp.dir}}/protocol_core.h"

{% if config.use_embedder_types %}
#include {{format_include(config.lib.protocol_traits)}}
{% else %}
#include {{format_include(config.lib.string_header)}}
{% endif %}

{% for namespace in config.protocol.namespace %}
namespace {{namespace}} {
{% endfor %}

using DispatchResponse = {{config.crdtp.namespace}}::DispatchResponse;
using ErrorSupport = {{config.crdtp.namespace}}::ErrorSupport;
using Serializable = {{config.crdtp.namespace}}::Serializable;
using FrontendChannel = {{config.crdtp.namespace}}::FrontendChannel;
using DomainDispatcher = {{config.crdtp.namespace}}::DomainDispatcher;
using UberDispatcher = {{config.crdtp.namespace}}::UberDispatcher;
using Response = DispatchResponse;

{% if config.use_embedder_types %}
using DictionaryValue = crdtp::traits::DictionaryValue;
using Object = crdtp::traits::DictionaryValue;
using ListValue = crdtp::traits::ListValue;
using Value = crdtp::traits::Value;
using String = crdtp::traits::String;
using Binary = crdtp::Binary;
{% else %}
class DictionaryValue;
class FundamentalValue;
class ListValue;
class Object;
class SerializedValue;
class StringValue;
class Value;
{% endif %}

using {{config.crdtp.namespace}}::detail::PtrMaybe;
using {{config.crdtp.namespace}}::detail::ValueMaybe;

template<typename T>
using Maybe = {{config.crdtp.namespace}}::Maybe<T>;

namespace detail {

template <typename T>
struct ArrayTypedef { typedef std::vector<std::unique_ptr<T>> type; };

template <>
struct ArrayTypedef<String> { typedef std::vector<String> type; };

template <>
struct ArrayTypedef<int> { typedef std::vector<int> type; };

template <>
struct ArrayTypedef<double> { typedef std::vector<double> type; };

template <>
struct ArrayTypedef<bool> { typedef std::vector<bool> type; };

template <>
struct ArrayTypedef<Binary> { typedef std::vector<Binary> type; };

}  // namespace detail

template <typename T>
using Array = typename detail::ArrayTypedef<T>::type;

{% for namespace in config.protocol.namespace %}
} // namespace {{namespace}}
{% endfor %}

#endif // !defined({{"_".join(config.protocol.namespace)}}_Forward_h)

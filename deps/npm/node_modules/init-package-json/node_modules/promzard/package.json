{
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "name": "promzard",
  "description": "prompting wizardly",
  "version": "0.2.1",
  "repository": {
    "url": "git://github.com/isaacs/promzard"
  },
  "dependencies": {
    "read": "1"
  },
  "devDependencies": {
    "tap": "~0.2.5"
  },
  "main": "promzard.js",
  "scripts": {
    "test": "tap test/*.js"
  },
  "license": "ISC",
  "readme": "# promzard\n\nA prompting wizard for building files from specialized PromZard modules.\nUsed by `npm init`.\n\nA reimplementation of @SubStack's\n[prompter](https://github.com/substack/node-prompter), which does not\nuse AST traversal.\n\nFrom another point of view, it's a reimplementation of\n[@Marak](https://github.com/marak)'s\n[wizard](https://github.com/Marak/wizard) which doesn't use schemas.\n\nThe goal is a nice drop-in enhancement for `npm init`.\n\n## Usage\n\n```javascript\nvar promzard = require('promzard')\npromzard(inputFile, optionalContextAdditions, function (er, data) {\n  // .. you know what you doing ..\n})\n```\n\nIn the `inputFile` you can have something like this:\n\n```javascript\nvar fs = require('fs')\nmodule.exports = {\n  \"greeting\": prompt(\"Who shall you greet?\", \"world\", function (who) {\n    return \"Hello, \" + who\n  }),\n  \"filename\": __filename,\n  \"directory\": function (cb) {\n    fs.readdir(__dirname, cb)\n  }\n}\n```\n\nWhen run, promzard will display the prompts and resolve the async\nfunctions in order, and then either give you an error, or the resolved\ndata, ready to be dropped into a JSON file or some other place.\n\n\n### promzard(inputFile, ctx, callback)\n\nThe inputFile is just a node module.  You can require() things, set\nmodule.exports, etc.  Whatever that module exports is the result, and it\nis walked over to call any functions as described below.\n\nThe only caveat is that you must give PromZard the full absolute path\nto the module (you can get this via Node's `require.resolve`.)  Also,\nthe `prompt` function is injected into the context object, so watch out.\n\nWhatever you put in that `ctx` will of course also be available in the\nmodule.  You can get quite fancy with this, passing in existing configs\nand so on.\n\n### Class: promzard.PromZard(file, ctx)\n\nJust like the `promzard` function, but the EventEmitter that makes it\nall happen.  Emits either a `data` event with the data, or a `error`\nevent if it blows up.\n\nIf `error` is emitted, then `data` never will be.\n\n### prompt(...)\n\nIn the promzard input module, you can call the `prompt` function.\nThis prompts the user to input some data.  The arguments are interpreted\nbased on type:\n\n1. `string`  The first string encountered is the prompt.  The second is\n   the default value.\n2. `function` A transformer function which receives the data and returns\n   something else.  More than meets the eye.\n3. `object` The `prompt` member is the prompt, the `default` member is\n   the default value, and the `transform` is the transformer.\n\nWhatever the final value is, that's what will be put on the resulting\nobject.\n\n### Functions\n\nIf there are any functions on the promzard input module's exports, then\npromzard will call each of them with a callback.  This way, your module\ncan do asynchronous actions if necessary to validate or ascertain\nwhatever needs verification.\n\nThe functions are called in the context of the ctx object, and are given\na single argument, which is a callback that should be called with either\nan error, or the result to assign to that spot.\n\nIn the async function, you can also call prompt() and return the result\nof the prompt in the callback.\n\nFor example, this works fine in a promzard module:\n\n```\nexports.asyncPrompt = function (cb) {\n  fs.stat(someFile, function (er, st) {\n    // if there's an error, no prompt, just error\n    // otherwise prompt and use the actual file size as the default\n    cb(er, prompt('file size', st.size))\n  })\n}\n```\n\nYou can also return other async functions in the async function\ncallback.  Though that's a bit silly, it could be a handy way to reuse\nfunctionality in some cases.\n\n### Sync vs Async\n\nThe `prompt()` function is not synchronous, though it appears that way.\nIt just returns a token that is swapped out when the data object is\nwalked over asynchronously later, and returns a token.\n\nFor that reason, prompt() calls whose results don't end up on the data\nobject are never shown to the user.  For example, this will only prompt\nonce:\n\n```\nexports.promptThreeTimes = prompt('prompt me once', 'shame on you')\nexports.promptThreeTimes = prompt('prompt me twice', 'um....')\nexports.promptThreeTimes = prompt('you cant prompt me again')\n```\n\n### Isn't this exactly the sort of 'looks sync' that you said was bad about other libraries?\n\nYeah, sorta.  I wouldn't use promzard for anything more complicated than\na wizard that spits out prompts to set up a config file or something.\nMaybe there are other use cases I haven't considered.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/isaacs/promzard/issues"
  },
  "homepage": "https://github.com/isaacs/promzard",
  "_id": "promzard@0.2.1",
  "_shasum": "c4c7cbe5182465c13b43540be9daf47098b4e75b",
  "_from": "promzard@~0.2.0",
  "_resolved": "https://registry.npmjs.org/promzard/-/promzard-0.2.1.tgz"
}

{
  "name": "qs",
  "description": "A querystring parser that supports nesting and arrays, with a depth limit",
  "homepage": "https://github.com/hapijs/qs",
  "version": "5.2.0",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hapijs/qs.git"
  },
  "main": "lib/index.js",
  "keywords": [
    "querystring",
    "qs"
  ],
  "engines": ">=0.10.40",
  "dependencies": {},
  "devDependencies": {
    "browserify": "^10.2.1",
    "code": "1.x.x",
    "lab": "5.x.x"
  },
  "scripts": {
    "test": "lab -a code -t 100 -L",
    "test-tap": "lab -a code -r tap -o tests.tap",
    "test-cov-html": "lab -a code -r html -o coverage.html",
    "dist": "browserify --standalone Qs lib/index.js > dist/qs.js"
  },
  "license": "BSD-3-Clause",
  "readme": "# qs\n\nA querystring parsing and stringifying library with some added security.\n\n[![Build Status](https://secure.travis-ci.org/hapijs/qs.svg)](http://travis-ci.org/hapijs/qs)\n\nLead Maintainer: [Nathan LaFreniere](https://github.com/nlf)\n\nThe **qs** module was originally created and maintained by [TJ Holowaychuk](https://github.com/visionmedia/node-querystring).\n\n## Usage\n\n```javascript\nvar Qs = require('qs');\n\nvar obj = Qs.parse('a=c');    // { a: 'c' }\nvar str = Qs.stringify(obj);  // 'a=c'\n```\n\n### Parsing Objects\n\n```javascript\nQs.parse(string, [options]);\n```\n\n**qs** allows you to create nested objects within your query strings, by surrounding the name of sub-keys with square brackets `[]`.\nFor example, the string `'foo[bar]=baz'` converts to:\n\n```javascript\n{\n  foo: {\n    bar: 'baz'\n  }\n}\n```\n\nWhen using the `plainObjects` option the parsed value is returned as a plain object, created via `Object.create(null)` and as such you should be aware that prototype methods will not exist on it and a user may set those names to whatever value they like:\n\n```javascript\nQs.parse('a.hasOwnProperty=b', { plainObjects: true });\n// { a: { hasOwnProperty: 'b' } }\n```\n\nBy default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use `plainObjects` as mentioned above, or set `allowPrototypes` to `true` which will allow user input to overwrite those properties. *WARNING* It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.\n\n```javascript\nQs.parse('a.hasOwnProperty=b', { allowPrototypes: true });\n// { a: { hasOwnProperty: 'b' } }\n```\n\nURI encoded strings work too:\n\n```javascript\nQs.parse('a%5Bb%5D=c');\n// { a: { b: 'c' } }\n```\n\nYou can also nest your objects, like `'foo[bar][baz]=foobarbaz'`:\n\n```javascript\n{\n  foo: {\n    bar: {\n      baz: 'foobarbaz'\n    }\n  }\n}\n```\n\nBy default, when nesting objects **qs** will only parse up to 5 children deep. This means if you attempt to parse a string like\n`'a[b][c][d][e][f][g][h][i]=j'` your resulting object will be:\n\n```javascript\n{\n  a: {\n    b: {\n      c: {\n        d: {\n          e: {\n            f: {\n              '[g][h][i]': 'j'\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nThis depth can be overridden by passing a `depth` option to `Qs.parse(string, [options])`:\n\n```javascript\nQs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });\n// { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } }\n```\n\nThe depth limit helps mitigate abuse when **qs** is used to parse user input, and it is recommended to keep it a reasonably small number.\n\nFor similar reasons, by default **qs** will only parse up to 1000 parameters. This can be overridden by passing a `parameterLimit` option:\n\n```javascript\nQs.parse('a=b&c=d', { parameterLimit: 1 });\n// { a: 'b' }\n```\n\nAn optional delimiter can also be passed:\n\n```javascript\nQs.parse('a=b;c=d', { delimiter: ';' });\n// { a: 'b', c: 'd' }\n```\n\nDelimiters can be a regular expression too:\n\n```javascript\nQs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });\n// { a: 'b', c: 'd', e: 'f' }\n```\n\nOption `allowDots` can be used to enable dot notation:\n\n```javascript\nQs.parse('a.b=c', { allowDots: true });\n// { a: { b: 'c' } }\n```\n\n### Parsing Arrays\n\n**qs** can also parse arrays using a similar `[]` notation:\n\n```javascript\nQs.parse('a[]=b&a[]=c');\n// { a: ['b', 'c'] }\n```\n\nYou may specify an index as well:\n\n```javascript\nQs.parse('a[1]=c&a[0]=b');\n// { a: ['b', 'c'] }\n```\n\nNote that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number\nto create an array. When creating arrays with specific indices, **qs** will compact a sparse array to only the existing values preserving\ntheir order:\n\n```javascript\nQs.parse('a[1]=b&a[15]=c');\n// { a: ['b', 'c'] }\n```\n\nNote that an empty string is also a value, and will be preserved:\n\n```javascript\nQs.parse('a[]=&a[]=b');\n// { a: ['', 'b'] }\nQs.parse('a[0]=b&a[1]=&a[2]=c');\n// { a: ['b', '', 'c'] }\n```\n\n**qs** will also limit specifying indices in an array to a maximum index of `20`. Any array members with an index of greater than `20` will\ninstead be converted to an object with the index as the key:\n\n```javascript\nQs.parse('a[100]=b');\n// { a: { '100': 'b' } }\n```\n\nThis limit can be overridden by passing an `arrayLimit` option:\n\n```javascript\nQs.parse('a[1]=b', { arrayLimit: 0 });\n// { a: { '1': 'b' } }\n```\n\nTo disable array parsing entirely, set `parseArrays` to `false`.\n\n```javascript\nQs.parse('a[]=b', { parseArrays: false });\n// { a: { '0': 'b' } }\n```\n\nIf you mix notations, **qs** will merge the two items into an object:\n\n```javascript\nQs.parse('a[0]=b&a[b]=c');\n// { a: { '0': 'b', b: 'c' } }\n```\n\nYou can also create arrays of objects:\n\n```javascript\nQs.parse('a[][b]=c');\n// { a: [{ b: 'c' }] }\n```\n\n### Stringifying\n\n```javascript\nQs.stringify(object, [options]);\n```\n\nWhen stringifying, **qs** by default URI encodes output. Objects are stringified as you would expect:\n\n```javascript\nQs.stringify({ a: 'b' });\n// 'a=b'\nQs.stringify({ a: { b: 'c' } });\n// 'a%5Bb%5D=c'\n```\n\nThis encoding can be disabled by setting the `encode` option to `false`:\n\n```javascript\nQs.stringify({ a: { b: 'c' } }, { encode: false });\n// 'a[b]=c'\n```\n\nExamples beyond this point will be shown as though the output is not URI encoded for clarity. Please note that the return values in these cases *will* be URI encoded during real usage.\n\nWhen arrays are stringified, by default they are given explicit indices:\n\n```javascript\nQs.stringify({ a: ['b', 'c', 'd'] });\n// 'a[0]=b&a[1]=c&a[2]=d'\n```\n\nYou may override this by setting the `indices` option to `false`:\n\n```javascript\nQs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });\n// 'a=b&a=c&a=d'\n```\n\nYou may use the `arrayFormat` option to specify the format of the output array\n\n```javascript\nQs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })\n// 'a[0]=b&a[1]=c'\nQs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })\n// 'a[]=b&a[]=c'\nQs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })\n// 'a=b&a=c'\n```\n\nEmpty strings and null values will omit the value, but the equals sign (=) remains in place:\n\n```javascript\nQs.stringify({ a: '' });\n// 'a='\n```\n\nProperties that are set to `undefined` will be omitted entirely:\n\n```javascript\nQs.stringify({ a: null, b: undefined });\n// 'a='\n```\n\nThe delimiter may be overridden with stringify as well:\n\n```javascript\nQs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' });\n// 'a=b;c=d'\n```\n\nFinally, you can use the `filter` option to restrict which keys will be included in the stringified output.\nIf you pass a function, it will be called for each key to obtain the replacement value. Otherwise, if you\npass an array, it will be used to select properties and array indices for stringification:\n\n```javascript\nfunction filterFunc(prefix, value) {\n  if (prefix == 'b') {\n    // Return an `undefined` value to omit a property.\n    return;\n  }\n  if (prefix == 'e[f]') {\n    return value.getTime();\n  }\n  if (prefix == 'e[g][0]') {\n    return value * 2;\n  }\n  return value;\n}\nQs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc })\n// 'a=b&c=d&e[f]=123&e[g][0]=4'\nQs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] })\n// 'a=b&e=f'\nQs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] })\n// 'a[0]=b&a[2]=d'\n```\n\n### Handling of `null` values\n\nBy default, `null` values are treated like empty strings:\n\n```javascript\nQs.stringify({ a: null, b: '' });\n// 'a=&b='\n```\n\nParsing does not distinguish between parameters with and without equal signs. Both are converted to empty strings.\n\n```javascript\nQs.parse('a&b=')\n// { a: '', b: '' }\n```\n\nTo distinguish between `null` values and empty strings use the `strictNullHandling` flag. In the result string the `null`\nvalues have no `=` sign:\n\n```javascript\nQs.stringify({ a: null, b: '' }, { strictNullHandling: true });\n// 'a&b='\n```\n\nTo parse values without `=` back to `null` use the `strictNullHandling` flag:\n\n```javascript\nQs.parse('a&b=', { strictNullHandling: true });\n// { a: null, b: '' }\n\n```\n\nTo completely skip rendering keys with `null` values, use the `skipNulls` flag:\n\n```javascript\nqs.stringify({ a: 'b', c: null}, { skipNulls: true })\n// 'a=b'\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/hapijs/qs/issues"
  },
  "_id": "qs@5.2.0",
  "_shasum": "a9f31142af468cb72b25b30136ba2456834916be",
  "_resolved": "https://registry.npmjs.org/qs/-/qs-5.2.0.tgz",
  "_from": "qs@>=5.2.0 <5.3.0"
}

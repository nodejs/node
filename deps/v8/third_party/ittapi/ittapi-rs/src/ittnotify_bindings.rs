/* automatically generated by rust-bindgen */

pub const ITT_OS_WIN: u32 = 1;
pub const ITT_OS_LINUX: u32 = 2;
pub const ITT_OS_MAC: u32 = 3;
pub const ITT_OS_FREEBSD: u32 = 4;
pub const ITT_OS: u32 = 2;
pub const ITT_PLATFORM_WIN: u32 = 1;
pub const ITT_PLATFORM_POSIX: u32 = 2;
pub const ITT_PLATFORM_MAC: u32 = 3;
pub const ITT_PLATFORM_FREEBSD: u32 = 4;
pub const ITT_PLATFORM: u32 = 2;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ITT_MAJOR: u32 = 3;
pub const ITT_MINOR: u32 = 0;
pub const __itt_suppress_all_errors: u32 = 2147483647;
pub const __itt_suppress_threading_errors: u32 = 255;
pub const __itt_suppress_memory_errors: u32 = 65280;
pub const __itt_attr_barrier: u32 = 1;
pub const __itt_attr_mutex: u32 = 2;
pub const __itt_heap_leaks: u32 = 1;
pub const __itt_heap_growth: u32 = 2;
pub const __itt_section_exec: u32 = 536870912;
pub const __itt_section_read: u32 = 1073741824;
pub const __itt_section_write: u32 = 2147483648;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    #[doc = " @defgroup control Collection Control"]
    #[doc = " @ingroup public"]
    #[doc = " General behavior: application continues to run, but no profiling information is being collected"]
    #[doc = ""]
    #[doc = " Pausing occurs not only for the current thread but for all process as well as spawned processes"]
    #[doc = " - Intel(R) Parallel Inspector and Intel(R) Inspector XE:"]
    #[doc = "   - Does not analyze or report errors that involve memory access."]
    #[doc = "   - Other errors are reported as usual. Pausing data collection in"]
    #[doc = "     Intel(R) Parallel Inspector and Intel(R) Inspector XE"]
    #[doc = "     only pauses tracing and analyzing memory access."]
    #[doc = "     It does not pause tracing or analyzing threading APIs."]
    #[doc = "   ."]
    #[doc = " - Intel(R) Parallel Amplifier and Intel(R) VTune(TM) Amplifier XE:"]
    #[doc = "   - Does continue to record when new threads are started."]
    #[doc = "   ."]
    #[doc = " - Other effects:"]
    #[doc = "   - Possible reduction of runtime overhead."]
    #[doc = "   ."]
    #[doc = " @{"]
    pub fn __itt_pause();
}
extern "C" {
    #[doc = " @brief Resume collection"]
    pub fn __itt_resume();
}
extern "C" {
    #[doc = " @brief Detach collection"]
    pub fn __itt_detach();
}
pub type __itt_pause_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_pause_ptr__3_0: __itt_pause_ptr__3_0_t;
}
pub type __itt_resume_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_resume_ptr__3_0: __itt_resume_ptr__3_0_t;
}
pub type __itt_detach_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_detach_ptr__3_0: __itt_detach_ptr__3_0_t;
}
#[doc = " @defgroup Intel Processor Trace control"]
#[doc = " API from this group provides control over collection and analysis of Intel Processor Trace (Intel PT) data"]
#[doc = " Information about Intel Processor Trace technology can be found here (Volume 3 chapter 35):"]
#[doc = " https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf"]
#[doc = " Use this API to mark particular code regions for loading detailed performance statistics."]
#[doc = " This mode makes your analysis faster and more accurate."]
#[doc = " @{"]
pub type __itt_pt_region = ::std::os::raw::c_uchar;
extern "C" {
    pub fn __itt_pt_region_create(name: *const ::std::os::raw::c_char) -> __itt_pt_region;
}
pub type __itt_pt_region_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> __itt_pt_region,
>;
extern "C" {
    pub static mut __itt_pt_region_create_ptr__3_0: __itt_pt_region_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief function contains a special code pattern identified on the post-processing stage and"]
    #[doc = " marks the beginning of a code region targeted for Intel PT analysis"]
    #[doc = " @param[in] region - region id, 0 <= region < 8"]
    pub fn __itt_mark_pt_region_begin(region: __itt_pt_region);
}
extern "C" {
    #[doc = " @brief function contains a special code pattern identified on the post-processing stage and"]
    #[doc = " marks the end of a code region targeted for Intel PT analysis"]
    #[doc = " @param[in] region - region id, 0 <= region < 8"]
    pub fn __itt_mark_pt_region_end(region: __itt_pt_region);
}
extern "C" {
    pub fn __itt_thread_set_name(name: *const ::std::os::raw::c_char);
}
pub type __itt_thread_set_name_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char)>;
extern "C" {
    pub static mut __itt_thread_set_name_ptr__3_0: __itt_thread_set_name_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Mark current thread as ignored from this point on, for the duration of its existence."]
    pub fn __itt_thread_ignore();
}
pub type __itt_thread_ignore_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_thread_ignore_ptr__3_0: __itt_thread_ignore_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Start suppressing errors identified in mask on this thread"]
    pub fn __itt_suppress_push(mask: ::std::os::raw::c_uint);
}
pub type __itt_suppress_push_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(mask: ::std::os::raw::c_uint)>;
extern "C" {
    pub static mut __itt_suppress_push_ptr__3_0: __itt_suppress_push_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Undo the effects of the matching call to __itt_suppress_push"]
    pub fn __itt_suppress_pop();
}
pub type __itt_suppress_pop_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_suppress_pop_ptr__3_0: __itt_suppress_pop_ptr__3_0_t;
}
pub const __itt_suppress_mode___itt_unsuppress_range: __itt_suppress_mode = 0;
pub const __itt_suppress_mode___itt_suppress_range: __itt_suppress_mode = 1;
#[doc = " @enum __itt_model_disable"]
#[doc = " @brief Enumerator for the disable methods"]
pub type __itt_suppress_mode = u32;
pub use self::__itt_suppress_mode as __itt_suppress_mode_t;
extern "C" {
    #[doc = " @brief Mark a range of memory for error suppression or unsuppression for error types included in mask"]
    pub fn __itt_suppress_mark_range(
        mode: __itt_suppress_mode_t,
        mask: ::std::os::raw::c_uint,
        address: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
pub type __itt_suppress_mark_range_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        mode: __itt_suppress_mode_t,
        mask: ::std::os::raw::c_uint,
        address: *mut ::std::os::raw::c_void,
        size: usize,
    ),
>;
extern "C" {
    pub static mut __itt_suppress_mark_range_ptr__3_0: __itt_suppress_mark_range_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Undo the effect of a matching call to __itt_suppress_mark_range.   If not matching"]
    #[doc = "        call is found, nothing is changed."]
    pub fn __itt_suppress_clear_range(
        mode: __itt_suppress_mode_t,
        mask: ::std::os::raw::c_uint,
        address: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
pub type __itt_suppress_clear_range_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        mode: __itt_suppress_mode_t,
        mask: ::std::os::raw::c_uint,
        address: *mut ::std::os::raw::c_void,
        size: usize,
    ),
>;
extern "C" {
    pub static mut __itt_suppress_clear_range_ptr__3_0: __itt_suppress_clear_range_ptr__3_0_t;
}
extern "C" {
    pub fn __itt_sync_create(
        addr: *mut ::std::os::raw::c_void,
        objtype: *const ::std::os::raw::c_char,
        objname: *const ::std::os::raw::c_char,
        attribute: ::std::os::raw::c_int,
    );
}
pub type __itt_sync_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        addr: *mut ::std::os::raw::c_void,
        objtype: *const ::std::os::raw::c_char,
        objname: *const ::std::os::raw::c_char,
        attribute: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    pub static mut __itt_sync_create_ptr__3_0: __itt_sync_create_ptr__3_0_t;
}
extern "C" {
    pub fn __itt_sync_rename(
        addr: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    );
}
pub type __itt_sync_rename_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, name: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub static mut __itt_sync_rename_ptr__3_0: __itt_sync_rename_ptr__3_0_t;
}
extern "C" {
    #[doc = "@brief Destroy a synchronization object."]
    #[doc = "@param addr Handle for the synchronization object."]
    pub fn __itt_sync_destroy(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_sync_destroy_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_sync_destroy_ptr__3_0: __itt_sync_destroy_ptr__3_0_t;
}
extern "C" {
    #[doc = " @name group of functions is used for performance measurement tools"]
    #[doc = " @brief Enter spin loop on user-defined sync object"]
    pub fn __itt_sync_prepare(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_sync_prepare_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_sync_prepare_ptr__3_0: __itt_sync_prepare_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Quit spin loop without acquiring spin object"]
    pub fn __itt_sync_cancel(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_sync_cancel_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_sync_cancel_ptr__3_0: __itt_sync_cancel_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Successful spin loop completion (sync object acquired)"]
    pub fn __itt_sync_acquired(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_sync_acquired_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_sync_acquired_ptr__3_0: __itt_sync_acquired_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Start sync object releasing code. Is called before the lock release call."]
    pub fn __itt_sync_releasing(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_sync_releasing_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_sync_releasing_ptr__3_0: __itt_sync_releasing_ptr__3_0_t;
}
extern "C" {
    #[doc = " @name group of functions is used for correctness checking tools"]
    #[doc = " @ingroup legacy"]
    #[doc = " @deprecated Legacy API"]
    #[doc = " @brief Fast synchronization which does no require spinning."]
    #[doc = " - This special function is to be used by TBB and OpenMP libraries only when they know"]
    #[doc = "   there is no spin but they need to suppress TC warnings about shared variable modifications."]
    #[doc = " - It only has corresponding pointers in static library and does not have corresponding function"]
    #[doc = "   in dynamic library."]
    #[doc = " @see void __itt_sync_prepare(void* addr);"]
    pub fn __itt_fsync_prepare(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_fsync_prepare_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_fsync_prepare_ptr__3_0: __itt_fsync_prepare_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup legacy"]
    #[doc = " @deprecated Legacy API"]
    #[doc = " @brief Fast synchronization which does no require spinning."]
    #[doc = " - This special function is to be used by TBB and OpenMP libraries only when they know"]
    #[doc = "   there is no spin but they need to suppress TC warnings about shared variable modifications."]
    #[doc = " - It only has corresponding pointers in static library and does not have corresponding function"]
    #[doc = "   in dynamic library."]
    #[doc = " @see void __itt_sync_cancel(void *addr);"]
    pub fn __itt_fsync_cancel(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_fsync_cancel_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_fsync_cancel_ptr__3_0: __itt_fsync_cancel_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup legacy"]
    #[doc = " @deprecated Legacy API"]
    #[doc = " @brief Fast synchronization which does no require spinning."]
    #[doc = " - This special function is to be used by TBB and OpenMP libraries only when they know"]
    #[doc = "   there is no spin but they need to suppress TC warnings about shared variable modifications."]
    #[doc = " - It only has corresponding pointers in static library and does not have corresponding function"]
    #[doc = "   in dynamic library."]
    #[doc = " @see void __itt_sync_acquired(void *addr);"]
    pub fn __itt_fsync_acquired(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_fsync_acquired_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_fsync_acquired_ptr__3_0: __itt_fsync_acquired_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup legacy"]
    #[doc = " @deprecated Legacy API"]
    #[doc = " @brief Fast synchronization which does no require spinning."]
    #[doc = " - This special function is to be used by TBB and OpenMP libraries only when they know"]
    #[doc = "   there is no spin but they need to suppress TC warnings about shared variable modifications."]
    #[doc = " - It only has corresponding pointers in static library and does not have corresponding function"]
    #[doc = "   in dynamic library."]
    #[doc = " @see void __itt_sync_releasing(void* addr);"]
    pub fn __itt_fsync_releasing(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_fsync_releasing_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_fsync_releasing_ptr__3_0: __itt_fsync_releasing_ptr__3_0_t;
}
pub type __itt_model_site = *mut ::std::os::raw::c_void;
pub type __itt_model_site_instance = *mut ::std::os::raw::c_void;
pub type __itt_model_task = *mut ::std::os::raw::c_void;
pub type __itt_model_task_instance = *mut ::std::os::raw::c_void;
pub const __itt_model_disable___itt_model_disable_observation: __itt_model_disable = 0;
pub const __itt_model_disable___itt_model_disable_collection: __itt_model_disable = 1;
#[doc = " @enum __itt_model_disable"]
#[doc = " @brief Enumerator for the disable methods"]
pub type __itt_model_disable = u32;
extern "C" {
    #[doc = " @brief ANNOTATE_SITE_BEGIN/ANNOTATE_SITE_END support."]
    #[doc = ""]
    #[doc = " site_begin/end model a potential concurrency site."]
    #[doc = " site instances may be recursively nested with themselves."]
    #[doc = " site_end exits the most recently started but unended site for the current"]
    #[doc = " thread.  The handle passed to end may be used to validate structure."]
    #[doc = " Instances of a site encountered on different threads concurrently"]
    #[doc = " are considered completely distinct. If the site name for two different"]
    #[doc = " lexical sites match, it is unspecified whether they are treated as the"]
    #[doc = " same or different for data presentation."]
    pub fn __itt_model_site_begin(
        site: *mut __itt_model_site,
        instance: *mut __itt_model_site_instance,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __itt_model_site_beginA(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __itt_model_site_beginAL(name: *const ::std::os::raw::c_char, siteNameLen: usize);
}
extern "C" {
    pub fn __itt_model_site_end(
        site: *mut __itt_model_site,
        instance: *mut __itt_model_site_instance,
    );
}
extern "C" {
    pub fn __itt_model_site_end_2();
}
pub type __itt_model_site_begin_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        site: *mut __itt_model_site,
        instance: *mut __itt_model_site_instance,
        name: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub static mut __itt_model_site_begin_ptr__3_0: __itt_model_site_begin_ptr__3_0_t;
}
pub type __itt_model_site_beginA_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char)>;
extern "C" {
    pub static mut __itt_model_site_beginA_ptr__3_0: __itt_model_site_beginA_ptr__3_0_t;
}
pub type __itt_model_site_beginAL_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char, siteNameLen: usize),
>;
extern "C" {
    pub static mut __itt_model_site_beginAL_ptr__3_0: __itt_model_site_beginAL_ptr__3_0_t;
}
pub type __itt_model_site_end_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(site: *mut __itt_model_site, instance: *mut __itt_model_site_instance),
>;
extern "C" {
    pub static mut __itt_model_site_end_ptr__3_0: __itt_model_site_end_ptr__3_0_t;
}
pub type __itt_model_site_end_2_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_model_site_end_2_ptr__3_0: __itt_model_site_end_2_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_TASK_BEGIN/ANNOTATE_TASK_END support"]
    #[doc = ""]
    #[doc = " task_begin/end model a potential task, which is contained within the most"]
    #[doc = " closely enclosing dynamic site.  task_end exits the most recently started"]
    #[doc = " but unended task.  The handle passed to end may be used to validate"]
    #[doc = " structure.  It is unspecified if bad dynamic nesting is detected.  If it"]
    #[doc = " is, it should be encoded in the resulting data collection.  The collector"]
    #[doc = " should not fail due to construct nesting issues, nor attempt to directly"]
    #[doc = " indicate the problem."]
    pub fn __itt_model_task_begin(
        task: *mut __itt_model_task,
        instance: *mut __itt_model_task_instance,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __itt_model_task_beginA(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __itt_model_task_beginAL(name: *const ::std::os::raw::c_char, taskNameLen: usize);
}
extern "C" {
    pub fn __itt_model_iteration_taskA(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __itt_model_iteration_taskAL(name: *const ::std::os::raw::c_char, taskNameLen: usize);
}
extern "C" {
    pub fn __itt_model_task_end(
        task: *mut __itt_model_task,
        instance: *mut __itt_model_task_instance,
    );
}
extern "C" {
    pub fn __itt_model_task_end_2();
}
pub type __itt_model_task_begin_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        task: *mut __itt_model_task,
        instance: *mut __itt_model_task_instance,
        name: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub static mut __itt_model_task_begin_ptr__3_0: __itt_model_task_begin_ptr__3_0_t;
}
pub type __itt_model_task_beginA_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char)>;
extern "C" {
    pub static mut __itt_model_task_beginA_ptr__3_0: __itt_model_task_beginA_ptr__3_0_t;
}
pub type __itt_model_task_beginAL_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char, taskNameLen: usize),
>;
extern "C" {
    pub static mut __itt_model_task_beginAL_ptr__3_0: __itt_model_task_beginAL_ptr__3_0_t;
}
pub type __itt_model_iteration_taskA_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char)>;
extern "C" {
    pub static mut __itt_model_iteration_taskA_ptr__3_0: __itt_model_iteration_taskA_ptr__3_0_t;
}
pub type __itt_model_iteration_taskAL_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char, taskNameLen: usize),
>;
extern "C" {
    pub static mut __itt_model_iteration_taskAL_ptr__3_0: __itt_model_iteration_taskAL_ptr__3_0_t;
}
pub type __itt_model_task_end_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(task: *mut __itt_model_task, instance: *mut __itt_model_task_instance),
>;
extern "C" {
    pub static mut __itt_model_task_end_ptr__3_0: __itt_model_task_end_ptr__3_0_t;
}
pub type __itt_model_task_end_2_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_model_task_end_2_ptr__3_0: __itt_model_task_end_2_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_LOCK_ACQUIRE/ANNOTATE_LOCK_RELEASE support"]
    #[doc = ""]
    #[doc = " lock_acquire/release model a potential lock for both lockset and"]
    #[doc = " performance modeling.  Each unique address is modeled as a separate"]
    #[doc = " lock, with invalid addresses being valid lock IDs.  Specifically:"]
    #[doc = " no storage is accessed by the API at the specified address - it is only"]
    #[doc = " used for lock identification.  Lock acquires may be self-nested and are"]
    #[doc = " unlocked by a corresponding number of releases."]
    #[doc = " (These closely correspond to __itt_sync_acquired/__itt_sync_releasing,"]
    #[doc = " but may not have identical semantics.)"]
    pub fn __itt_model_lock_acquire(lock: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __itt_model_lock_acquire_2(lock: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __itt_model_lock_release(lock: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __itt_model_lock_release_2(lock: *mut ::std::os::raw::c_void);
}
pub type __itt_model_lock_acquire_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(lock: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_model_lock_acquire_ptr__3_0: __itt_model_lock_acquire_ptr__3_0_t;
}
pub type __itt_model_lock_acquire_2_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(lock: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_model_lock_acquire_2_ptr__3_0: __itt_model_lock_acquire_2_ptr__3_0_t;
}
pub type __itt_model_lock_release_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(lock: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_model_lock_release_ptr__3_0: __itt_model_lock_release_ptr__3_0_t;
}
pub type __itt_model_lock_release_2_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(lock: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_model_lock_release_2_ptr__3_0: __itt_model_lock_release_2_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_RECORD_ALLOCATION/ANNOTATE_RECORD_DEALLOCATION support"]
    #[doc = ""]
    #[doc = " record_allocation/deallocation describe user-defined memory allocator"]
    #[doc = " behavior, which may be required for correctness modeling to understand"]
    #[doc = " when storage is not expected to be actually reused across threads."]
    pub fn __itt_model_record_allocation(addr: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    pub fn __itt_model_record_deallocation(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_model_record_allocation_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, size: usize)>;
extern "C" {
    pub static mut __itt_model_record_allocation_ptr__3_0: __itt_model_record_allocation_ptr__3_0_t;
}
pub type __itt_model_record_deallocation_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_model_record_deallocation_ptr__3_0:
        __itt_model_record_deallocation_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_INDUCTION_USES support"]
    #[doc = ""]
    #[doc = " Note particular storage is inductive through the end of the current site"]
    pub fn __itt_model_induction_uses(addr: *mut ::std::os::raw::c_void, size: usize);
}
pub type __itt_model_induction_uses_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, size: usize)>;
extern "C" {
    pub static mut __itt_model_induction_uses_ptr__3_0: __itt_model_induction_uses_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_REDUCTION_USES support"]
    #[doc = ""]
    #[doc = " Note particular storage is used for reduction through the end"]
    #[doc = " of the current site"]
    pub fn __itt_model_reduction_uses(addr: *mut ::std::os::raw::c_void, size: usize);
}
pub type __itt_model_reduction_uses_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, size: usize)>;
extern "C" {
    pub static mut __itt_model_reduction_uses_ptr__3_0: __itt_model_reduction_uses_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_OBSERVE_USES support"]
    #[doc = ""]
    #[doc = " Have correctness modeling record observations about uses of storage"]
    #[doc = " through the end of the current site"]
    pub fn __itt_model_observe_uses(addr: *mut ::std::os::raw::c_void, size: usize);
}
pub type __itt_model_observe_uses_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, size: usize)>;
extern "C" {
    pub static mut __itt_model_observe_uses_ptr__3_0: __itt_model_observe_uses_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_CLEAR_USES support"]
    #[doc = ""]
    #[doc = " Clear the special handling of a piece of storage related to induction,"]
    #[doc = " reduction or observe_uses"]
    pub fn __itt_model_clear_uses(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_model_clear_uses_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_model_clear_uses_ptr__3_0: __itt_model_clear_uses_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief ANNOTATE_DISABLE_*_PUSH/ANNOTATE_DISABLE_*_POP support"]
    #[doc = ""]
    #[doc = " disable_push/disable_pop push and pop disabling based on a parameter."]
    #[doc = " Disabling observations stops processing of memory references during"]
    #[doc = " correctness modeling, and all annotations that occur in the disabled"]
    #[doc = " region.  This allows description of code that is expected to be handled"]
    #[doc = " specially during conversion to parallelism or that is not recognized"]
    #[doc = " by tools (e.g. some kinds of synchronization operations.)"]
    #[doc = " This mechanism causes all annotations in the disabled region, other"]
    #[doc = " than disable_push and disable_pop, to be ignored.  (For example, this"]
    #[doc = " might validly be used to disable an entire parallel site and the contained"]
    #[doc = " tasks and locking in it for data collection purposes.)"]
    #[doc = " The disable for collection is a more expensive operation, but reduces"]
    #[doc = " collector overhead significantly.  This applies to BOTH correctness data"]
    #[doc = " collection and performance data collection.  For example, a site"]
    #[doc = " containing a task might only enable data collection for the first 10"]
    #[doc = " iterations.  Both performance and correctness data should reflect this,"]
    #[doc = " and the program should run as close to full speed as possible when"]
    #[doc = " collection is disabled."]
    pub fn __itt_model_disable_push(x: __itt_model_disable);
}
extern "C" {
    pub fn __itt_model_disable_pop();
}
extern "C" {
    pub fn __itt_model_aggregate_task(x: usize);
}
pub type __itt_model_disable_push_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(x: __itt_model_disable)>;
extern "C" {
    pub static mut __itt_model_disable_push_ptr__3_0: __itt_model_disable_push_ptr__3_0_t;
}
pub type __itt_model_disable_pop_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_model_disable_pop_ptr__3_0: __itt_model_disable_pop_ptr__3_0_t;
}
pub type __itt_model_aggregate_task_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(x: usize)>;
extern "C" {
    pub static mut __itt_model_aggregate_task_ptr__3_0: __itt_model_aggregate_task_ptr__3_0_t;
}
#[doc = " @defgroup heap Heap"]
#[doc = " @ingroup public"]
#[doc = " Heap group"]
#[doc = " @{"]
pub type __itt_heap_function = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn __itt_heap_function_create(
        name: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
    ) -> __itt_heap_function;
}
pub type __itt_heap_function_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
    ) -> __itt_heap_function,
>;
extern "C" {
    pub static mut __itt_heap_function_create_ptr__3_0: __itt_heap_function_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an allocation begin occurrence."]
    pub fn __itt_heap_allocate_begin(
        h: __itt_heap_function,
        size: usize,
        initialized: ::std::os::raw::c_int,
    );
}
pub type __itt_heap_allocate_begin_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(h: __itt_heap_function, size: usize, initialized: ::std::os::raw::c_int),
>;
extern "C" {
    pub static mut __itt_heap_allocate_begin_ptr__3_0: __itt_heap_allocate_begin_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an allocation end occurrence."]
    pub fn __itt_heap_allocate_end(
        h: __itt_heap_function,
        addr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        initialized: ::std::os::raw::c_int,
    );
}
pub type __itt_heap_allocate_end_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        h: __itt_heap_function,
        addr: *mut *mut ::std::os::raw::c_void,
        size: usize,
        initialized: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    pub static mut __itt_heap_allocate_end_ptr__3_0: __itt_heap_allocate_end_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an free begin occurrence."]
    pub fn __itt_heap_free_begin(h: __itt_heap_function, addr: *mut ::std::os::raw::c_void);
}
pub type __itt_heap_free_begin_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(h: __itt_heap_function, addr: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub static mut __itt_heap_free_begin_ptr__3_0: __itt_heap_free_begin_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an free end occurrence."]
    pub fn __itt_heap_free_end(h: __itt_heap_function, addr: *mut ::std::os::raw::c_void);
}
pub type __itt_heap_free_end_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(h: __itt_heap_function, addr: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub static mut __itt_heap_free_end_ptr__3_0: __itt_heap_free_end_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an reallocation begin occurrence."]
    pub fn __itt_heap_reallocate_begin(
        h: __itt_heap_function,
        addr: *mut ::std::os::raw::c_void,
        new_size: usize,
        initialized: ::std::os::raw::c_int,
    );
}
pub type __itt_heap_reallocate_begin_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        h: __itt_heap_function,
        addr: *mut ::std::os::raw::c_void,
        new_size: usize,
        initialized: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    pub static mut __itt_heap_reallocate_begin_ptr__3_0: __itt_heap_reallocate_begin_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an reallocation end occurrence."]
    pub fn __itt_heap_reallocate_end(
        h: __itt_heap_function,
        addr: *mut ::std::os::raw::c_void,
        new_addr: *mut *mut ::std::os::raw::c_void,
        new_size: usize,
        initialized: ::std::os::raw::c_int,
    );
}
pub type __itt_heap_reallocate_end_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        h: __itt_heap_function,
        addr: *mut ::std::os::raw::c_void,
        new_addr: *mut *mut ::std::os::raw::c_void,
        new_size: usize,
        initialized: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    pub static mut __itt_heap_reallocate_end_ptr__3_0: __itt_heap_reallocate_end_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief internal access begin"]
    pub fn __itt_heap_internal_access_begin();
}
pub type __itt_heap_internal_access_begin_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_heap_internal_access_begin_ptr__3_0:
        __itt_heap_internal_access_begin_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief internal access end"]
    pub fn __itt_heap_internal_access_end();
}
pub type __itt_heap_internal_access_end_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_heap_internal_access_end_ptr__3_0:
        __itt_heap_internal_access_end_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief record memory growth begin"]
    pub fn __itt_heap_record_memory_growth_begin();
}
pub type __itt_heap_record_memory_growth_begin_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_heap_record_memory_growth_begin_ptr__3_0:
        __itt_heap_record_memory_growth_begin_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief record memory growth end"]
    pub fn __itt_heap_record_memory_growth_end();
}
pub type __itt_heap_record_memory_growth_end_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_heap_record_memory_growth_end_ptr__3_0:
        __itt_heap_record_memory_growth_end_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief heap reset detection"]
    pub fn __itt_heap_reset_detection(reset_mask: ::std::os::raw::c_uint);
}
pub type __itt_heap_reset_detection_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(reset_mask: ::std::os::raw::c_uint)>;
extern "C" {
    pub static mut __itt_heap_reset_detection_ptr__3_0: __itt_heap_reset_detection_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief report"]
    pub fn __itt_heap_record(record_mask: ::std::os::raw::c_uint);
}
pub type __itt_heap_record_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(record_mask: ::std::os::raw::c_uint)>;
extern "C" {
    pub static mut __itt_heap_record_ptr__3_0: __itt_heap_record_ptr__3_0_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_domain {
    #[doc = "< Zero if disabled, non-zero if enabled. The meaning of different non-zero values is reserved to the runtime"]
    pub flags: ::std::os::raw::c_int,
    #[doc = "< Copy of original name in ASCII."]
    pub nameA: *const ::std::os::raw::c_char,
    pub nameW: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved to the runtime"]
    pub extra1: ::std::os::raw::c_int,
    #[doc = "< Reserved to the runtime"]
    pub extra2: *mut ::std::os::raw::c_void,
    pub next: *mut ___itt_domain,
}
#[test]
fn bindgen_test_layout____itt_domain() {
    assert_eq!(
        ::std::mem::size_of::<___itt_domain>(),
        48usize,
        concat!("Size of: ", stringify!(___itt_domain))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_domain>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_domain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_domain>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_domain),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_domain>())).nameA as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_domain),
            "::",
            stringify!(nameA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_domain>())).nameW as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_domain),
            "::",
            stringify!(nameW)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_domain>())).extra1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_domain),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_domain>())).extra2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_domain),
            "::",
            stringify!(extra2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_domain>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_domain),
            "::",
            stringify!(next)
        )
    );
}
pub type __itt_domain = ___itt_domain;
extern "C" {
    pub fn __itt_domain_create(name: *const ::std::os::raw::c_char) -> *mut __itt_domain;
}
pub type __itt_domain_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut __itt_domain,
>;
extern "C" {
    pub static mut __itt_domain_create_ptr__3_0: __itt_domain_create_ptr__3_0_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_id {
    pub d1: ::std::os::raw::c_ulonglong,
    pub d2: ::std::os::raw::c_ulonglong,
    pub d3: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout____itt_id() {
    assert_eq!(
        ::std::mem::size_of::<___itt_id>(),
        24usize,
        concat!("Size of: ", stringify!(___itt_id))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_id>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_id>())).d1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_id),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_id>())).d2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_id),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_id>())).d3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_id),
            "::",
            stringify!(d3)
        )
    );
}
pub type __itt_id = ___itt_id;
extern "C" {
    pub static __itt_null: __itt_id;
}
extern "C" {
    #[doc = " @ingroup ids"]
    #[doc = " @brief Create an instance of identifier."]
    #[doc = " This establishes the beginning of the lifetime of an instance of"]
    #[doc = " the given ID in the trace. Once this lifetime starts, the ID"]
    #[doc = " can be used to tag named entity instances in calls such as"]
    #[doc = " __itt_task_begin, and to specify relationships among"]
    #[doc = " identified named entity instances, using the \\ref relations APIs."]
    #[doc = " Instance IDs are not domain specific!"]
    #[doc = " @param[in] domain The domain controlling the execution of this call."]
    #[doc = " @param[in] id The ID to create."]
    pub fn __itt_id_create(domain: *const __itt_domain, id: __itt_id);
}
pub type __itt_id_create_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(domain: *const __itt_domain, id: __itt_id)>;
extern "C" {
    pub static mut __itt_id_create_ptr__3_0: __itt_id_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup ids"]
    #[doc = " @brief Destroy an instance of identifier."]
    #[doc = " This ends the lifetime of the current instance of the given ID value in the trace."]
    #[doc = " Any relationships that are established after this lifetime ends are invalid."]
    #[doc = " This call must be performed before the given ID value can be reused for a different"]
    #[doc = " named entity instance."]
    #[doc = " @param[in] domain The domain controlling the execution of this call."]
    #[doc = " @param[in] id The ID to destroy."]
    pub fn __itt_id_destroy(domain: *const __itt_domain, id: __itt_id);
}
pub type __itt_id_destroy_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(domain: *const __itt_domain, id: __itt_id)>;
extern "C" {
    pub static mut __itt_id_destroy_ptr__3_0: __itt_id_destroy_ptr__3_0_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_string_handle {
    #[doc = "< Copy of original string in ASCII."]
    pub strA: *const ::std::os::raw::c_char,
    pub strW: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved. Must be zero"]
    pub extra1: ::std::os::raw::c_int,
    #[doc = "< Reserved. Must be zero"]
    pub extra2: *mut ::std::os::raw::c_void,
    pub next: *mut ___itt_string_handle,
}
#[test]
fn bindgen_test_layout____itt_string_handle() {
    assert_eq!(
        ::std::mem::size_of::<___itt_string_handle>(),
        40usize,
        concat!("Size of: ", stringify!(___itt_string_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_string_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_string_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_string_handle>())).strA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_string_handle),
            "::",
            stringify!(strA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_string_handle>())).strW as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_string_handle),
            "::",
            stringify!(strW)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_string_handle>())).extra1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_string_handle),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_string_handle>())).extra2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_string_handle),
            "::",
            stringify!(extra2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_string_handle>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_string_handle),
            "::",
            stringify!(next)
        )
    );
}
pub type __itt_string_handle = ___itt_string_handle;
extern "C" {
    pub fn __itt_string_handle_create(
        name: *const ::std::os::raw::c_char,
    ) -> *mut __itt_string_handle;
}
pub type __itt_string_handle_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut __itt_string_handle,
>;
extern "C" {
    pub static mut __itt_string_handle_create_ptr__3_0: __itt_string_handle_create_ptr__3_0_t;
}
#[doc = " @cond exclude_from_documentation"]
pub type __itt_timestamp = ::std::os::raw::c_ulonglong;
extern "C" {
    #[doc = " @ingroup timestamps"]
    #[doc = " @brief Return timestamp corresponding to the current moment."]
    #[doc = " This returns the timestamp in the format that is the most relevant for the current"]
    #[doc = " host or platform (RDTSC, QPC, and others). You can use the \"<\" operator to"]
    #[doc = " compare __itt_timestamp values."]
    pub fn __itt_get_timestamp() -> __itt_timestamp;
}
pub type __itt_get_timestamp_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn() -> __itt_timestamp>;
extern "C" {
    pub static mut __itt_get_timestamp_ptr__3_0: __itt_get_timestamp_ptr__3_0_t;
}
extern "C" {
    #[doc = " @defgroup regions Regions"]
    #[doc = " @ingroup public"]
    #[doc = " Regions group"]
    #[doc = " @{"]
    #[doc = " @ingroup regions"]
    #[doc = " @brief Begin of region instance."]
    #[doc = " Successive calls to __itt_region_begin with the same ID are ignored"]
    #[doc = " until a call to __itt_region_end with the same ID"]
    #[doc = " @param[in] domain The domain for this region instance"]
    #[doc = " @param[in] id The instance ID for this region instance. Must not be __itt_null"]
    #[doc = " @param[in] parentid The instance ID for the parent of this region instance, or __itt_null"]
    #[doc = " @param[in] name The name of this region"]
    pub fn __itt_region_begin(
        domain: *const __itt_domain,
        id: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    );
}
extern "C" {
    #[doc = " @ingroup regions"]
    #[doc = " @brief End of region instance."]
    #[doc = " The first call to __itt_region_end with a given ID ends the"]
    #[doc = " region. Successive calls with the same ID are ignored, as are"]
    #[doc = " calls that do not have a matching __itt_region_begin call."]
    #[doc = " @param[in] domain The domain for this region instance"]
    #[doc = " @param[in] id The instance ID for this region instance"]
    pub fn __itt_region_end(domain: *const __itt_domain, id: __itt_id);
}
pub type __itt_region_begin_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    ),
>;
extern "C" {
    pub static mut __itt_region_begin_ptr__3_0: __itt_region_begin_ptr__3_0_t;
}
pub type __itt_region_end_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(domain: *const __itt_domain, id: __itt_id)>;
extern "C" {
    pub static mut __itt_region_end_ptr__3_0: __itt_region_end_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup frames"]
    #[doc = " @brief Begin a frame instance."]
    #[doc = " Successive calls to __itt_frame_begin with the"]
    #[doc = " same ID are ignored until a call to __itt_frame_end with the same ID."]
    #[doc = " @param[in] domain The domain for this frame instance"]
    #[doc = " @param[in] id The instance ID for this frame instance or NULL"]
    pub fn __itt_frame_begin_v3(domain: *const __itt_domain, id: *mut __itt_id);
}
extern "C" {
    #[doc = " @ingroup frames"]
    #[doc = " @brief End a frame instance."]
    #[doc = " The first call to __itt_frame_end with a given ID"]
    #[doc = " ends the frame. Successive calls with the same ID are ignored, as are"]
    #[doc = " calls that do not have a matching __itt_frame_begin call."]
    #[doc = " @param[in] domain The domain for this frame instance"]
    #[doc = " @param[in] id The instance ID for this frame instance or NULL for current"]
    pub fn __itt_frame_end_v3(domain: *const __itt_domain, id: *mut __itt_id);
}
extern "C" {
    #[doc = " @ingroup frames"]
    #[doc = " @brief Submits a frame instance."]
    #[doc = " Successive calls to __itt_frame_begin or __itt_frame_submit with the"]
    #[doc = " same ID are ignored until a call to __itt_frame_end or __itt_frame_submit"]
    #[doc = " with the same ID."]
    #[doc = " Passing special __itt_timestamp_none value as \"end\" argument means"]
    #[doc = " take the current timestamp as the end timestamp."]
    #[doc = " @param[in] domain The domain for this frame instance"]
    #[doc = " @param[in] id The instance ID for this frame instance or NULL"]
    #[doc = " @param[in] begin Timestamp of the beginning of the frame"]
    #[doc = " @param[in] end Timestamp of the end of the frame"]
    pub fn __itt_frame_submit_v3(
        domain: *const __itt_domain,
        id: *mut __itt_id,
        begin: __itt_timestamp,
        end: __itt_timestamp,
    );
}
pub type __itt_frame_begin_v3_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(domain: *const __itt_domain, id: *mut __itt_id)>;
extern "C" {
    pub static mut __itt_frame_begin_v3_ptr__3_0: __itt_frame_begin_v3_ptr__3_0_t;
}
pub type __itt_frame_end_v3_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(domain: *const __itt_domain, id: *mut __itt_id)>;
extern "C" {
    pub static mut __itt_frame_end_v3_ptr__3_0: __itt_frame_end_v3_ptr__3_0_t;
}
pub type __itt_frame_submit_v3_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: *mut __itt_id,
        begin: __itt_timestamp,
        end: __itt_timestamp,
    ),
>;
extern "C" {
    pub static mut __itt_frame_submit_v3_ptr__3_0: __itt_frame_submit_v3_ptr__3_0_t;
}
extern "C" {
    #[doc = " @defgroup taskgroup Task Group"]
    #[doc = " @ingroup public"]
    #[doc = " Task Group"]
    #[doc = " @{"]
    #[doc = " @ingroup task_groups"]
    #[doc = " @brief Denotes a task_group instance."]
    #[doc = " Successive calls to __itt_task_group with the same ID are ignored."]
    #[doc = " @param[in] domain The domain for this task_group instance"]
    #[doc = " @param[in] id The instance ID for this task_group instance. Must not be __itt_null."]
    #[doc = " @param[in] parentid The instance ID for the parent of this task_group instance, or __itt_null."]
    #[doc = " @param[in] name The name of this task_group"]
    pub fn __itt_task_group(
        domain: *const __itt_domain,
        id: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    );
}
pub type __itt_task_group_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    ),
>;
extern "C" {
    pub static mut __itt_task_group_ptr__3_0: __itt_task_group_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup tasks"]
    #[doc = " @brief Begin a task instance."]
    #[doc = " @param[in] domain The domain for this task"]
    #[doc = " @param[in] taskid The instance ID for this task instance, or __itt_null"]
    #[doc = " @param[in] parentid The parent instance to which this task instance belongs, or __itt_null"]
    #[doc = " @param[in] name The name of this task"]
    pub fn __itt_task_begin(
        domain: *const __itt_domain,
        taskid: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    );
}
extern "C" {
    #[doc = " @ingroup tasks"]
    #[doc = " @brief Begin a task instance."]
    #[doc = " @param[in] domain The domain for this task"]
    #[doc = " @param[in] taskid The identifier for this task instance (may be 0)"]
    #[doc = " @param[in] parentid The parent of this task (may be 0)"]
    #[doc = " @param[in] fn The pointer to the function you are tracing"]
    pub fn __itt_task_begin_fn(
        domain: *const __itt_domain,
        taskid: __itt_id,
        parentid: __itt_id,
        fn_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @ingroup tasks"]
    #[doc = " @brief End the current task instance."]
    #[doc = " @param[in] domain The domain for this task"]
    pub fn __itt_task_end(domain: *const __itt_domain);
}
extern "C" {
    #[doc = " @ingroup tasks"]
    #[doc = " @brief Begin an overlapped task instance."]
    #[doc = " @param[in] domain The domain for this task."]
    #[doc = " @param[in] taskid The identifier for this task instance, *cannot* be __itt_null."]
    #[doc = " @param[in] parentid The parent of this task, or __itt_null."]
    #[doc = " @param[in] name The name of this task."]
    pub fn __itt_task_begin_overlapped(
        domain: *const __itt_domain,
        taskid: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    );
}
extern "C" {
    #[doc = " @ingroup tasks"]
    #[doc = " @brief End an overlapped task instance."]
    #[doc = " @param[in] domain The domain for this task"]
    #[doc = " @param[in] taskid Explicit ID of finished task"]
    pub fn __itt_task_end_overlapped(domain: *const __itt_domain, taskid: __itt_id);
}
pub type __itt_task_begin_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    ),
>;
extern "C" {
    pub static mut __itt_task_begin_ptr__3_0: __itt_task_begin_ptr__3_0_t;
}
pub type __itt_task_begin_fn_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: __itt_id,
        parentid: __itt_id,
        fn_: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub static mut __itt_task_begin_fn_ptr__3_0: __itt_task_begin_fn_ptr__3_0_t;
}
pub type __itt_task_end_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(domain: *const __itt_domain)>;
extern "C" {
    pub static mut __itt_task_end_ptr__3_0: __itt_task_end_ptr__3_0_t;
}
pub type __itt_task_begin_overlapped_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        taskid: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    ),
>;
extern "C" {
    pub static mut __itt_task_begin_overlapped_ptr__3_0: __itt_task_begin_overlapped_ptr__3_0_t;
}
pub type __itt_task_end_overlapped_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(domain: *const __itt_domain, taskid: __itt_id)>;
extern "C" {
    pub static mut __itt_task_end_overlapped_ptr__3_0: __itt_task_end_overlapped_ptr__3_0_t;
}
pub const __itt_scope___itt_scope_unknown: __itt_scope = 0;
pub const __itt_scope___itt_scope_global: __itt_scope = 1;
pub const __itt_scope___itt_scope_track_group: __itt_scope = 2;
pub const __itt_scope___itt_scope_track: __itt_scope = 3;
pub const __itt_scope___itt_scope_task: __itt_scope = 4;
pub const __itt_scope___itt_scope_marker: __itt_scope = 5;
#[doc = " @brief Describes the scope of an event object in the trace."]
pub type __itt_scope = u32;
extern "C" {
    #[doc = " @ingroup markers"]
    #[doc = " @brief Create a marker instance"]
    #[doc = " @param[in] domain The domain for this marker"]
    #[doc = " @param[in] id The instance ID for this marker or __itt_null"]
    #[doc = " @param[in] name The name for this marker"]
    #[doc = " @param[in] scope The scope for this marker"]
    pub fn __itt_marker(
        domain: *const __itt_domain,
        id: __itt_id,
        name: *mut __itt_string_handle,
        scope: __itt_scope,
    );
}
pub type __itt_marker_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: __itt_id,
        name: *mut __itt_string_handle,
        scope: __itt_scope,
    ),
>;
extern "C" {
    pub static mut __itt_marker_ptr__3_0: __itt_marker_ptr__3_0_t;
}
pub const __itt_metadata_type___itt_metadata_unknown: __itt_metadata_type = 0;
#[doc = "< Unsigned 64-bit integer"]
pub const __itt_metadata_type___itt_metadata_u64: __itt_metadata_type = 1;
#[doc = "< Signed 64-bit integer"]
pub const __itt_metadata_type___itt_metadata_s64: __itt_metadata_type = 2;
#[doc = "< Unsigned 32-bit integer"]
pub const __itt_metadata_type___itt_metadata_u32: __itt_metadata_type = 3;
#[doc = "< Signed 32-bit integer"]
pub const __itt_metadata_type___itt_metadata_s32: __itt_metadata_type = 4;
#[doc = "< Unsigned 16-bit integer"]
pub const __itt_metadata_type___itt_metadata_u16: __itt_metadata_type = 5;
#[doc = "< Signed 16-bit integer"]
pub const __itt_metadata_type___itt_metadata_s16: __itt_metadata_type = 6;
#[doc = "< Signed 32-bit floating-point"]
pub const __itt_metadata_type___itt_metadata_float: __itt_metadata_type = 7;
#[doc = "< SIgned 64-bit floating-point"]
pub const __itt_metadata_type___itt_metadata_double: __itt_metadata_type = 8;
#[doc = " @ingroup parameters"]
#[doc = " @brief describes the type of metadata"]
pub type __itt_metadata_type = u32;
extern "C" {
    #[doc = " @ingroup parameters"]
    #[doc = " @brief Add metadata to an instance of a named entity."]
    #[doc = " @param[in] domain The domain controlling the call"]
    #[doc = " @param[in] id The identifier of the instance to which the metadata is to be added, or __itt_null to add to the current task"]
    #[doc = " @param[in] key The name of the metadata"]
    #[doc = " @param[in] type The type of the metadata"]
    #[doc = " @param[in] count The number of elements of the given type. If count == 0, no metadata will be added."]
    #[doc = " @param[in] data The metadata itself"]
    pub fn __itt_metadata_add(
        domain: *const __itt_domain,
        id: __itt_id,
        key: *mut __itt_string_handle,
        type_: __itt_metadata_type,
        count: usize,
        data: *mut ::std::os::raw::c_void,
    );
}
pub type __itt_metadata_add_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: __itt_id,
        key: *mut __itt_string_handle,
        type_: __itt_metadata_type,
        count: usize,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub static mut __itt_metadata_add_ptr__3_0: __itt_metadata_add_ptr__3_0_t;
}
extern "C" {
    pub fn __itt_metadata_str_add(
        domain: *const __itt_domain,
        id: __itt_id,
        key: *mut __itt_string_handle,
        data: *const ::std::os::raw::c_char,
        length: usize,
    );
}
pub type __itt_metadata_str_add_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        id: __itt_id,
        key: *mut __itt_string_handle,
        data: *const ::std::os::raw::c_char,
        length: usize,
    ),
>;
extern "C" {
    pub static mut __itt_metadata_str_add_ptr__3_0: __itt_metadata_str_add_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup parameters"]
    #[doc = " @brief Add metadata to an instance of a named entity."]
    #[doc = " @param[in] domain The domain controlling the call"]
    #[doc = " @param[in] scope The scope of the instance to which the metadata is to be added"]
    #[doc = ""]
    #[doc = " @param[in] id The identifier of the instance to which the metadata is to be added, or __itt_null to add to the current task"]
    #[doc = ""]
    #[doc = " @param[in] key The name of the metadata"]
    #[doc = " @param[in] type The type of the metadata"]
    #[doc = " @param[in] count The number of elements of the given type. If count == 0, no metadata will be added."]
    #[doc = " @param[in] data The metadata itself"]
    pub fn __itt_metadata_add_with_scope(
        domain: *const __itt_domain,
        scope: __itt_scope,
        key: *mut __itt_string_handle,
        type_: __itt_metadata_type,
        count: usize,
        data: *mut ::std::os::raw::c_void,
    );
}
pub type __itt_metadata_add_with_scope_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        scope: __itt_scope,
        key: *mut __itt_string_handle,
        type_: __itt_metadata_type,
        count: usize,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub static mut __itt_metadata_add_with_scope_ptr__3_0: __itt_metadata_add_with_scope_ptr__3_0_t;
}
extern "C" {
    pub fn __itt_metadata_str_add_with_scope(
        domain: *const __itt_domain,
        scope: __itt_scope,
        key: *mut __itt_string_handle,
        data: *const ::std::os::raw::c_char,
        length: usize,
    );
}
pub type __itt_metadata_str_add_with_scope_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        scope: __itt_scope,
        key: *mut __itt_string_handle,
        data: *const ::std::os::raw::c_char,
        length: usize,
    ),
>;
extern "C" {
    pub static mut __itt_metadata_str_add_with_scope_ptr__3_0:
        __itt_metadata_str_add_with_scope_ptr__3_0_t;
}
pub const __itt_relation___itt_relation_is_unknown: __itt_relation = 0;
#[doc = "< \"A is dependent on B\" means that A cannot start until B completes"]
pub const __itt_relation___itt_relation_is_dependent_on: __itt_relation = 1;
#[doc = "< \"A is sibling of B\" means that A and B were created as a group"]
pub const __itt_relation___itt_relation_is_sibling_of: __itt_relation = 2;
#[doc = "< \"A is parent of B\" means that A created B"]
pub const __itt_relation___itt_relation_is_parent_of: __itt_relation = 3;
#[doc = "< \"A is continuation of B\" means that A assumes the dependencies of B"]
pub const __itt_relation___itt_relation_is_continuation_of: __itt_relation = 4;
#[doc = "< \"A is child of B\" means that A was created by B (inverse of is_parent_of)"]
pub const __itt_relation___itt_relation_is_child_of: __itt_relation = 5;
#[doc = "< \"A is continued by B\" means that B assumes the dependencies of A (inverse of is_continuation_of)"]
pub const __itt_relation___itt_relation_is_continued_by: __itt_relation = 6;
#[doc = "< \"A is predecessor to B\" means that B cannot start until A completes (inverse of is_dependent_on)"]
pub const __itt_relation___itt_relation_is_predecessor_to: __itt_relation = 7;
#[doc = " @ingroup relations"]
#[doc = " @brief The kind of relation between two instances is specified by the enumerated type __itt_relation."]
#[doc = " Relations between instances can be added with an API call. The relation"]
#[doc = " API uses instance IDs. Relations can be added before or after the actual"]
#[doc = " instances are created and persist independently of the instances. This"]
#[doc = " is the motivation for having different lifetimes for instance IDs and"]
#[doc = " the actual instances."]
pub type __itt_relation = u32;
extern "C" {
    #[doc = " @ingroup relations"]
    #[doc = " @brief Add a relation to the current task instance."]
    #[doc = " The current task instance is the head of the relation."]
    #[doc = " @param[in] domain The domain controlling this call"]
    #[doc = " @param[in] relation The kind of relation"]
    #[doc = " @param[in] tail The ID for the tail of the relation"]
    pub fn __itt_relation_add_to_current(
        domain: *const __itt_domain,
        relation: __itt_relation,
        tail: __itt_id,
    );
}
extern "C" {
    #[doc = " @ingroup relations"]
    #[doc = " @brief Add a relation between two instance identifiers."]
    #[doc = " @param[in] domain The domain controlling this call"]
    #[doc = " @param[in] head The ID for the head of the relation"]
    #[doc = " @param[in] relation The kind of relation"]
    #[doc = " @param[in] tail The ID for the tail of the relation"]
    pub fn __itt_relation_add(
        domain: *const __itt_domain,
        head: __itt_id,
        relation: __itt_relation,
        tail: __itt_id,
    );
}
pub type __itt_relation_add_to_current_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(domain: *const __itt_domain, relation: __itt_relation, tail: __itt_id),
>;
extern "C" {
    pub static mut __itt_relation_add_to_current_ptr__3_0: __itt_relation_add_to_current_ptr__3_0_t;
}
pub type __itt_relation_add_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        head: __itt_id,
        relation: __itt_relation,
        tail: __itt_id,
    ),
>;
extern "C" {
    pub static mut __itt_relation_add_ptr__3_0: __itt_relation_add_ptr__3_0_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_clock_info {
    #[doc = "< Clock domain frequency"]
    pub clock_freq: ::std::os::raw::c_ulonglong,
    #[doc = "< Clock domain base timestamp"]
    pub clock_base: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout____itt_clock_info() {
    assert_eq!(
        ::std::mem::size_of::<___itt_clock_info>(),
        16usize,
        concat!("Size of: ", stringify!(___itt_clock_info))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_clock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_clock_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_info>())).clock_freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_info),
            "::",
            stringify!(clock_freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_info>())).clock_base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_info),
            "::",
            stringify!(clock_base)
        )
    );
}
pub type __itt_clock_info = ___itt_clock_info;
#[doc = " @cond exclude_from_documentation"]
pub type __itt_get_clock_info_fn = ::std::option::Option<
    unsafe extern "C" fn(clock_info: *mut __itt_clock_info, data: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_clock_domain {
    #[doc = "< Most recent clock domain info"]
    pub info: __itt_clock_info,
    #[doc = "< Callback function pointer"]
    pub fn_: __itt_get_clock_info_fn,
    #[doc = "< Input argument for the callback function"]
    pub fn_data: *mut ::std::os::raw::c_void,
    #[doc = "< Reserved. Must be zero"]
    pub extra1: ::std::os::raw::c_int,
    #[doc = "< Reserved. Must be zero"]
    pub extra2: *mut ::std::os::raw::c_void,
    pub next: *mut ___itt_clock_domain,
}
#[test]
fn bindgen_test_layout____itt_clock_domain() {
    assert_eq!(
        ::std::mem::size_of::<___itt_clock_domain>(),
        56usize,
        concat!("Size of: ", stringify!(___itt_clock_domain))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_clock_domain>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_clock_domain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_domain>())).info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_domain),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_domain>())).fn_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_domain),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_domain>())).fn_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_domain),
            "::",
            stringify!(fn_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_domain>())).extra1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_domain),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_domain>())).extra2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_domain),
            "::",
            stringify!(extra2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_clock_domain>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_clock_domain),
            "::",
            stringify!(next)
        )
    );
}
pub type __itt_clock_domain = ___itt_clock_domain;
extern "C" {
    #[doc = " @ingroup clockdomains"]
    #[doc = " @brief Create a clock domain."]
    #[doc = " Certain applications require the capability to trace their application using"]
    #[doc = " a clock domain different than the CPU, for instance the instrumentation of events"]
    #[doc = " that occur on a GPU."]
    #[doc = " Because the set of domains is expected to be static over the application's execution time,"]
    #[doc = " there is no mechanism to destroy a domain."]
    #[doc = " Any domain can be accessed by any thread in the process, regardless of which thread created"]
    #[doc = " the domain. This call is thread-safe."]
    #[doc = " @param[in] fn A pointer to a callback function which retrieves alternative CPU timestamps"]
    #[doc = " @param[in] fn_data Argument for a callback function; may be NULL"]
    pub fn __itt_clock_domain_create(
        fn_: __itt_get_clock_info_fn,
        fn_data: *mut ::std::os::raw::c_void,
    ) -> *mut __itt_clock_domain;
}
pub type __itt_clock_domain_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        fn_: __itt_get_clock_info_fn,
        fn_data: *mut ::std::os::raw::c_void,
    ) -> *mut __itt_clock_domain,
>;
extern "C" {
    pub static mut __itt_clock_domain_create_ptr__3_0: __itt_clock_domain_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup clockdomains"]
    #[doc = " @brief Recalculate clock domains frequencies and clock base timestamps."]
    pub fn __itt_clock_domain_reset();
}
pub type __itt_clock_domain_reset_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_clock_domain_reset_ptr__3_0: __itt_clock_domain_reset_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup clockdomain"]
    #[doc = " @brief Create an instance of identifier. This establishes the beginning of the lifetime of"]
    #[doc = " an instance of the given ID in the trace. Once this lifetime starts, the ID can be used to"]
    #[doc = " tag named entity instances in calls such as __itt_task_begin, and to specify relationships among"]
    #[doc = " identified named entity instances, using the \\ref relations APIs."]
    #[doc = " @param[in] domain The domain controlling the execution of this call."]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    #[doc = " @param[in] id The ID to create."]
    pub fn __itt_id_create_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
    );
}
extern "C" {
    #[doc = " @ingroup clockdomain"]
    #[doc = " @brief Destroy an instance of identifier. This ends the lifetime of the current instance of the"]
    #[doc = " given ID value in the trace. Any relationships that are established after this lifetime ends are"]
    #[doc = " invalid. This call must be performed before the given ID value can be reused for a different"]
    #[doc = " named entity instance."]
    #[doc = " @param[in] domain The domain controlling the execution of this call."]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    #[doc = " @param[in] id The ID to destroy."]
    pub fn __itt_id_destroy_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
    );
}
pub type __itt_id_create_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
    ),
>;
extern "C" {
    pub static mut __itt_id_create_ex_ptr__3_0: __itt_id_create_ex_ptr__3_0_t;
}
pub type __itt_id_destroy_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
    ),
>;
extern "C" {
    pub static mut __itt_id_destroy_ex_ptr__3_0: __itt_id_destroy_ex_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup clockdomain"]
    #[doc = " @brief Begin a task instance."]
    #[doc = " @param[in] domain The domain for this task"]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    #[doc = " @param[in] taskid The instance ID for this task instance, or __itt_null"]
    #[doc = " @param[in] parentid The parent instance to which this task instance belongs, or __itt_null"]
    #[doc = " @param[in] name The name of this task"]
    pub fn __itt_task_begin_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        taskid: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    );
}
extern "C" {
    #[doc = " @ingroup clockdomain"]
    #[doc = " @brief Begin a task instance."]
    #[doc = " @param[in] domain The domain for this task"]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    #[doc = " @param[in] taskid The identifier for this task instance, or __itt_null"]
    #[doc = " @param[in] parentid The parent of this task, or __itt_null"]
    #[doc = " @param[in] fn The pointer to the function you are tracing"]
    pub fn __itt_task_begin_fn_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        taskid: __itt_id,
        parentid: __itt_id,
        fn_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @ingroup clockdomain"]
    #[doc = " @brief End the current task instance."]
    #[doc = " @param[in] domain The domain for this task"]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    pub fn __itt_task_end_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
    );
}
pub type __itt_task_begin_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
        parentid: __itt_id,
        name: *mut __itt_string_handle,
    ),
>;
extern "C" {
    pub static mut __itt_task_begin_ex_ptr__3_0: __itt_task_begin_ex_ptr__3_0_t;
}
pub type __itt_task_begin_fn_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
        parentid: __itt_id,
        fn_: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub static mut __itt_task_begin_fn_ex_ptr__3_0: __itt_task_begin_fn_ex_ptr__3_0_t;
}
pub type __itt_task_end_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
    ),
>;
extern "C" {
    pub static mut __itt_task_end_ex_ptr__3_0: __itt_task_end_ex_ptr__3_0_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_counter {
    _unused: [u8; 0],
}
#[doc = " @brief opaque structure for counter identification"]
pub type __itt_counter = *mut ___itt_counter;
extern "C" {
    pub fn __itt_counter_create(
        name: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
    ) -> __itt_counter;
}
pub type __itt_counter_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
    ) -> __itt_counter,
>;
extern "C" {
    pub static mut __itt_counter_create_ptr__3_0: __itt_counter_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Increment the unsigned 64 bits integer counter value"]
    #[doc = ""]
    #[doc = " Calling this function to non-unsigned 64 bits integer counters has no effect"]
    pub fn __itt_counter_inc(id: __itt_counter);
}
pub type __itt_counter_inc_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(id: __itt_counter)>;
extern "C" {
    pub static mut __itt_counter_inc_ptr__3_0: __itt_counter_inc_ptr__3_0_t;
}
extern "C" {
    #[doc = " @endcond */"]
    #[doc = " @brief Increment the unsigned 64 bits integer counter value with x"]
    #[doc = ""]
    #[doc = " Calling this function to non-unsigned 64 bits integer counters has no effect"]
    pub fn __itt_counter_inc_delta(id: __itt_counter, value: ::std::os::raw::c_ulonglong);
}
pub type __itt_counter_inc_delta_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(id: __itt_counter, value: ::std::os::raw::c_ulonglong),
>;
extern "C" {
    pub static mut __itt_counter_inc_delta_ptr__3_0: __itt_counter_inc_delta_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Decrement the unsigned 64 bits integer counter value"]
    #[doc = ""]
    #[doc = " Calling this function to non-unsigned 64 bits integer counters has no effect"]
    pub fn __itt_counter_dec(id: __itt_counter);
}
pub type __itt_counter_dec_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(id: __itt_counter)>;
extern "C" {
    pub static mut __itt_counter_dec_ptr__3_0: __itt_counter_dec_ptr__3_0_t;
}
extern "C" {
    #[doc = " @endcond */"]
    #[doc = " @brief Decrement the unsigned 64 bits integer counter value with x"]
    #[doc = ""]
    #[doc = " Calling this function to non-unsigned 64 bits integer counters has no effect"]
    pub fn __itt_counter_dec_delta(id: __itt_counter, value: ::std::os::raw::c_ulonglong);
}
pub type __itt_counter_dec_delta_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(id: __itt_counter, value: ::std::os::raw::c_ulonglong),
>;
extern "C" {
    pub static mut __itt_counter_dec_delta_ptr__3_0: __itt_counter_dec_delta_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup counters"]
    #[doc = " @brief Increment a counter by one."]
    #[doc = " The first call with a given name creates a counter by that name and sets its"]
    #[doc = " value to zero. Successive calls increment the counter value."]
    #[doc = " @param[in] domain The domain controlling the call. Counter names are not domain specific."]
    #[doc = "            The domain argument is used only to enable or disable the API calls."]
    #[doc = " @param[in] name The name of the counter"]
    pub fn __itt_counter_inc_v3(domain: *const __itt_domain, name: *mut __itt_string_handle);
}
extern "C" {
    #[doc = " @ingroup counters"]
    #[doc = " @brief Increment a counter by the value specified in delta."]
    #[doc = " @param[in] domain The domain controlling the call. Counter names are not domain specific."]
    #[doc = "            The domain argument is used only to enable or disable the API calls."]
    #[doc = " @param[in] name The name of the counter"]
    #[doc = " @param[in] delta The amount by which to increment the counter"]
    pub fn __itt_counter_inc_delta_v3(
        domain: *const __itt_domain,
        name: *mut __itt_string_handle,
        delta: ::std::os::raw::c_ulonglong,
    );
}
pub type __itt_counter_inc_v3_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(domain: *const __itt_domain, name: *mut __itt_string_handle),
>;
extern "C" {
    pub static mut __itt_counter_inc_v3_ptr__3_0: __itt_counter_inc_v3_ptr__3_0_t;
}
pub type __itt_counter_inc_delta_v3_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        name: *mut __itt_string_handle,
        delta: ::std::os::raw::c_ulonglong,
    ),
>;
extern "C" {
    pub static mut __itt_counter_inc_delta_v3_ptr__3_0: __itt_counter_inc_delta_v3_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup counters"]
    #[doc = " @brief Decrement a counter by one."]
    #[doc = " The first call with a given name creates a counter by that name and sets its"]
    #[doc = " value to zero. Successive calls decrement the counter value."]
    #[doc = " @param[in] domain The domain controlling the call. Counter names are not domain specific."]
    #[doc = "            The domain argument is used only to enable or disable the API calls."]
    #[doc = " @param[in] name The name of the counter"]
    pub fn __itt_counter_dec_v3(domain: *const __itt_domain, name: *mut __itt_string_handle);
}
extern "C" {
    #[doc = " @ingroup counters"]
    #[doc = " @brief Decrement a counter by the value specified in delta."]
    #[doc = " @param[in] domain The domain controlling the call. Counter names are not domain specific."]
    #[doc = "            The domain argument is used only to enable or disable the API calls."]
    #[doc = " @param[in] name The name of the counter"]
    #[doc = " @param[in] delta The amount by which to decrement the counter"]
    pub fn __itt_counter_dec_delta_v3(
        domain: *const __itt_domain,
        name: *mut __itt_string_handle,
        delta: ::std::os::raw::c_ulonglong,
    );
}
pub type __itt_counter_dec_v3_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(domain: *const __itt_domain, name: *mut __itt_string_handle),
>;
extern "C" {
    pub static mut __itt_counter_dec_v3_ptr__3_0: __itt_counter_dec_v3_ptr__3_0_t;
}
pub type __itt_counter_dec_delta_v3_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        name: *mut __itt_string_handle,
        delta: ::std::os::raw::c_ulonglong,
    ),
>;
extern "C" {
    pub static mut __itt_counter_dec_delta_v3_ptr__3_0: __itt_counter_dec_delta_v3_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Set the counter value"]
    pub fn __itt_counter_set_value(id: __itt_counter, value_ptr: *mut ::std::os::raw::c_void);
}
pub type __itt_counter_set_value_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(id: __itt_counter, value_ptr: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub static mut __itt_counter_set_value_ptr__3_0: __itt_counter_set_value_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Set the counter value"]
    pub fn __itt_counter_set_value_ex(
        id: __itt_counter,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        value_ptr: *mut ::std::os::raw::c_void,
    );
}
pub type __itt_counter_set_value_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: __itt_counter,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        value_ptr: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub static mut __itt_counter_set_value_ex_ptr__3_0: __itt_counter_set_value_ex_ptr__3_0_t;
}
extern "C" {
    pub fn __itt_counter_create_typed(
        name: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
        type_: __itt_metadata_type,
    ) -> __itt_counter;
}
pub type __itt_counter_create_typed_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
        type_: __itt_metadata_type,
    ) -> __itt_counter,
>;
extern "C" {
    pub static mut __itt_counter_create_typed_ptr__3_0: __itt_counter_create_typed_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Destroy the counter identified by the pointer previously returned by __itt_counter_create() or"]
    #[doc = " __itt_counter_create_typed()"]
    pub fn __itt_counter_destroy(id: __itt_counter);
}
pub type __itt_counter_destroy_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(id: __itt_counter)>;
extern "C" {
    pub static mut __itt_counter_destroy_ptr__3_0: __itt_counter_destroy_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup markers"]
    #[doc = " @brief Create a marker instance."]
    #[doc = " @param[in] domain The domain for this marker"]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    #[doc = " @param[in] id The instance ID for this marker, or __itt_null"]
    #[doc = " @param[in] name The name for this marker"]
    #[doc = " @param[in] scope The scope for this marker"]
    pub fn __itt_marker_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
        name: *mut __itt_string_handle,
        scope: __itt_scope,
    );
}
pub type __itt_marker_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        id: __itt_id,
        name: *mut __itt_string_handle,
        scope: __itt_scope,
    ),
>;
extern "C" {
    pub static mut __itt_marker_ex_ptr__3_0: __itt_marker_ex_ptr__3_0_t;
}
extern "C" {
    #[doc = " @ingroup clockdomain"]
    #[doc = " @brief Add a relation to the current task instance."]
    #[doc = " The current task instance is the head of the relation."]
    #[doc = " @param[in] domain The domain controlling this call"]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    #[doc = " @param[in] relation The kind of relation"]
    #[doc = " @param[in] tail The ID for the tail of the relation"]
    pub fn __itt_relation_add_to_current_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        relation: __itt_relation,
        tail: __itt_id,
    );
}
extern "C" {
    #[doc = " @ingroup clockdomain"]
    #[doc = " @brief Add a relation between two instance identifiers."]
    #[doc = " @param[in] domain The domain controlling this call"]
    #[doc = " @param[in] clock_domain The clock domain controlling the execution of this call."]
    #[doc = " @param[in] timestamp The user defined timestamp."]
    #[doc = " @param[in] head The ID for the head of the relation"]
    #[doc = " @param[in] relation The kind of relation"]
    #[doc = " @param[in] tail The ID for the tail of the relation"]
    pub fn __itt_relation_add_ex(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        head: __itt_id,
        relation: __itt_relation,
        tail: __itt_id,
    );
}
pub type __itt_relation_add_to_current_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        relation: __itt_relation,
        tail: __itt_id,
    ),
>;
extern "C" {
    pub static mut __itt_relation_add_to_current_ex_ptr__3_0:
        __itt_relation_add_to_current_ex_ptr__3_0_t;
}
pub type __itt_relation_add_ex_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        domain: *const __itt_domain,
        clock_domain: *mut __itt_clock_domain,
        timestamp: ::std::os::raw::c_ulonglong,
        head: __itt_id,
        relation: __itt_relation,
        tail: __itt_id,
    ),
>;
extern "C" {
    pub static mut __itt_relation_add_ex_ptr__3_0: __itt_relation_add_ex_ptr__3_0_t;
}
pub const ___itt_track_group_type___itt_track_group_type_normal: ___itt_track_group_type = 0;
#[doc = " @cond exclude_from_documentation"]
pub type ___itt_track_group_type = u32;
pub use self::___itt_track_group_type as __itt_track_group_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_track_group {
    #[doc = "< Name of the track group"]
    pub name: *mut __itt_string_handle,
    #[doc = "< List of child tracks"]
    pub track: *mut ___itt_track,
    #[doc = "< Type of the track group"]
    pub tgtype: __itt_track_group_type,
    #[doc = "< Reserved. Must be zero"]
    pub extra1: ::std::os::raw::c_int,
    #[doc = "< Reserved. Must be zero"]
    pub extra2: *mut ::std::os::raw::c_void,
    pub next: *mut ___itt_track_group,
}
#[test]
fn bindgen_test_layout____itt_track_group() {
    assert_eq!(
        ::std::mem::size_of::<___itt_track_group>(),
        40usize,
        concat!("Size of: ", stringify!(___itt_track_group))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_track_group>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_track_group))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track_group>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track_group),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track_group>())).track as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track_group),
            "::",
            stringify!(track)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track_group>())).tgtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track_group),
            "::",
            stringify!(tgtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track_group>())).extra1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track_group),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track_group>())).extra2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track_group),
            "::",
            stringify!(extra2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track_group>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track_group),
            "::",
            stringify!(next)
        )
    );
}
pub type __itt_track_group = ___itt_track_group;
pub const ___itt_track_type___itt_track_type_normal: ___itt_track_type = 0;
#[doc = " @brief Placeholder for custom track types. Currently, \"normal\" custom track"]
#[doc = " is the only available track type."]
pub type ___itt_track_type = u32;
pub use self::___itt_track_type as __itt_track_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_track {
    #[doc = "< Name of the track group"]
    pub name: *mut __itt_string_handle,
    #[doc = "< Parent group to a track"]
    pub group: *mut __itt_track_group,
    #[doc = "< Type of the track"]
    pub ttype: __itt_track_type,
    #[doc = "< Reserved. Must be zero"]
    pub extra1: ::std::os::raw::c_int,
    #[doc = "< Reserved. Must be zero"]
    pub extra2: *mut ::std::os::raw::c_void,
    pub next: *mut ___itt_track,
}
#[test]
fn bindgen_test_layout____itt_track() {
    assert_eq!(
        ::std::mem::size_of::<___itt_track>(),
        40usize,
        concat!("Size of: ", stringify!(___itt_track))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_track>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_track))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track>())).group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track>())).ttype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track),
            "::",
            stringify!(ttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track>())).extra1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track>())).extra2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track),
            "::",
            stringify!(extra2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_track>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_track),
            "::",
            stringify!(next)
        )
    );
}
pub type __itt_track = ___itt_track;
extern "C" {
    #[doc = " @brief Create logical track group."]
    pub fn __itt_track_group_create(
        name: *mut __itt_string_handle,
        track_group_type: __itt_track_group_type,
    ) -> *mut __itt_track_group;
}
pub type __itt_track_group_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *mut __itt_string_handle,
        track_group_type: __itt_track_group_type,
    ) -> *mut __itt_track_group,
>;
extern "C" {
    pub static mut __itt_track_group_create_ptr__3_0: __itt_track_group_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Create logical track."]
    pub fn __itt_track_create(
        track_group: *mut __itt_track_group,
        name: *mut __itt_string_handle,
        track_type: __itt_track_type,
    ) -> *mut __itt_track;
}
pub type __itt_track_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        track_group: *mut __itt_track_group,
        name: *mut __itt_string_handle,
        track_type: __itt_track_type,
    ) -> *mut __itt_track,
>;
extern "C" {
    pub static mut __itt_track_create_ptr__3_0: __itt_track_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Set the logical track."]
    pub fn __itt_set_track(track: *mut __itt_track);
}
pub type __itt_set_track_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(track: *mut __itt_track)>;
extern "C" {
    pub static mut __itt_set_track_ptr__3_0: __itt_set_track_ptr__3_0_t;
}
#[doc = " @cond exclude_from_gpa_documentation */"]
#[doc = " @defgroup events Events"]
#[doc = " @ingroup public"]
#[doc = " Events group"]
#[doc = " @{"]
pub type __itt_event = ::std::os::raw::c_int;
extern "C" {
    pub fn __itt_event_create(
        name: *const ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
    ) -> __itt_event;
}
pub type __itt_event_create_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
    ) -> __itt_event,
>;
extern "C" {
    pub static mut __itt_event_create_ptr__3_0: __itt_event_create_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an event occurrence."]
    #[doc = " @return __itt_err upon failure (invalid event id/user event feature not enabled)"]
    pub fn __itt_event_start(event: __itt_event) -> ::std::os::raw::c_int;
}
pub type __itt_event_start_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(event: __itt_event) -> ::std::os::raw::c_int>;
extern "C" {
    pub static mut __itt_event_start_ptr__3_0: __itt_event_start_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Record an event end occurrence."]
    #[doc = " @note It is optional if events do not have durations."]
    #[doc = " @return __itt_err upon failure (invalid event id/user event feature not enabled)"]
    pub fn __itt_event_end(event: __itt_event) -> ::std::os::raw::c_int;
}
pub type __itt_event_end_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(event: __itt_event) -> ::std::os::raw::c_int>;
extern "C" {
    pub static mut __itt_event_end_ptr__3_0: __itt_event_end_ptr__3_0_t;
}
pub const __itt_av_data_type___itt_e_first: __itt_av_data_type = 0;
pub const __itt_av_data_type___itt_e_char: __itt_av_data_type = 0;
pub const __itt_av_data_type___itt_e_uchar: __itt_av_data_type = 1;
pub const __itt_av_data_type___itt_e_int16: __itt_av_data_type = 2;
pub const __itt_av_data_type___itt_e_uint16: __itt_av_data_type = 3;
pub const __itt_av_data_type___itt_e_int32: __itt_av_data_type = 4;
pub const __itt_av_data_type___itt_e_uint32: __itt_av_data_type = 5;
pub const __itt_av_data_type___itt_e_int64: __itt_av_data_type = 6;
pub const __itt_av_data_type___itt_e_uint64: __itt_av_data_type = 7;
pub const __itt_av_data_type___itt_e_float: __itt_av_data_type = 8;
pub const __itt_av_data_type___itt_e_double: __itt_av_data_type = 9;
pub const __itt_av_data_type___itt_e_last: __itt_av_data_type = 9;
#[doc = " @enum __itt_av_data_type"]
#[doc = " @brief Defines types of arrays data (for C/C++ intrinsic types)"]
pub type __itt_av_data_type = u32;
extern "C" {
    pub fn __itt_av_save(
        data: *mut ::std::os::raw::c_void,
        rank: ::std::os::raw::c_int,
        dimensions: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        filePath: *const ::std::os::raw::c_char,
        columnOrder: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __itt_av_save_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        rank: ::std::os::raw::c_int,
        dimensions: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        filePath: *const ::std::os::raw::c_char,
        columnOrder: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static mut __itt_av_save_ptr__3_0: __itt_av_save_ptr__3_0_t;
}
extern "C" {
    #[doc = " @endcond"]
    pub fn __itt_enable_attach();
}
pub type __itt_enable_attach_ptr__3_0_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut __itt_enable_attach_ptr__3_0: __itt_enable_attach_ptr__3_0_t;
}
extern "C" {
    pub fn __itt_module_load(
        start_addr: *mut ::std::os::raw::c_void,
        end_addr: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
}
pub type __itt_module_load_ptr__3_0_t = ::std::option::Option<
    unsafe extern "C" fn(
        start_addr: *mut ::std::os::raw::c_void,
        end_addr: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub static mut __itt_module_load_ptr__3_0: __itt_module_load_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Report module unload"]
    #[doc = " This API is used to report necessary information in case of bypassing default system loader."]
    #[doc = " Notification should be done just before the module is unloaded from process memory."]
    #[doc = " @param[in] addr - base address of loaded module"]
    pub fn __itt_module_unload(addr: *mut ::std::os::raw::c_void);
}
pub type __itt_module_unload_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub static mut __itt_module_unload_ptr__3_0: __itt_module_unload_ptr__3_0_t;
}
pub const __itt_module_type___itt_module_type_unknown: __itt_module_type = 0;
pub const __itt_module_type___itt_module_type_elf: __itt_module_type = 1;
pub const __itt_module_type___itt_module_type_coff: __itt_module_type = 2;
#[doc = " @cond exclude_from_documentation"]
pub type __itt_module_type = u32;
pub const __itt_section_type_itt_section_type_unknown: __itt_section_type = 0;
pub const __itt_section_type_itt_section_type_bss: __itt_section_type = 1;
pub const __itt_section_type_itt_section_type_data: __itt_section_type = 2;
pub const __itt_section_type_itt_section_type_text: __itt_section_type = 3;
#[doc = " @cond exclude_from_documentation"]
pub type __itt_section_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_section_info {
    #[doc = "< Section name in UTF8"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Section content and semantics description"]
    pub type_: __itt_section_type,
    #[doc = "< Section bit flags that describe attributes using bit mask"]
    #[doc = " Zero if disabled, non-zero if enabled"]
    pub flags: usize,
    #[doc = "< Section load(relocated) start address"]
    pub start_addr: *mut ::std::os::raw::c_void,
    #[doc = "< Section file offset"]
    pub size: usize,
    #[doc = "< Section size"]
    pub file_offset: usize,
}
#[test]
fn bindgen_test_layout____itt_section_info() {
    assert_eq!(
        ::std::mem::size_of::<___itt_section_info>(),
        48usize,
        concat!("Size of: ", stringify!(___itt_section_info))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_section_info>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_section_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_section_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_section_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_section_info>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_section_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_section_info>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_section_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_section_info>())).start_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_section_info),
            "::",
            stringify!(start_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_section_info>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_section_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_section_info>())).file_offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_section_info),
            "::",
            stringify!(file_offset)
        )
    );
}
pub type __itt_section_info = ___itt_section_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ___itt_module_object {
    #[doc = "< API version"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "< Unique identifier. This is unchanged for sections that belong to the same module"]
    pub module_id: __itt_id,
    #[doc = "< Binary module format"]
    pub module_type: __itt_module_type,
    #[doc = "< Unique module name or path to module in UTF8"]
    #[doc = " Contains module name when module_bufer and module_size exist"]
    #[doc = " Contains module path when module_bufer and module_size absent"]
    #[doc = " module_name remains the same for the certain module_id"]
    pub module_name: *const ::std::os::raw::c_char,
    #[doc = "< Module buffer content"]
    pub module_buffer: *mut ::std::os::raw::c_void,
    #[doc = "< Module buffer size */"]
    #[doc = " If module_buffer and module_size do not exist,"]
    #[doc = " the binary module exists on the system already."]
    #[doc = " The module_name parameter contains the path to the module."]
    pub module_size: usize,
    #[doc = "< Reference to section information"]
    pub section_array: *mut __itt_section_info,
    pub section_number: usize,
}
#[test]
fn bindgen_test_layout____itt_module_object() {
    assert_eq!(
        ::std::mem::size_of::<___itt_module_object>(),
        80usize,
        concat!("Size of: ", stringify!(___itt_module_object))
    );
    assert_eq!(
        ::std::mem::align_of::<___itt_module_object>(),
        8usize,
        concat!("Alignment of ", stringify!(___itt_module_object))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_module_object>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<___itt_module_object>())).module_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(module_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<___itt_module_object>())).module_type as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(module_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<___itt_module_object>())).module_name as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(module_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<___itt_module_object>())).module_buffer as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(module_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<___itt_module_object>())).module_size as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(module_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<___itt_module_object>())).section_array as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(section_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<___itt_module_object>())).section_number as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(___itt_module_object),
            "::",
            stringify!(section_number)
        )
    );
}
pub type __itt_module_object = ___itt_module_object;
extern "C" {
    #[doc = " @brief Load module content and its loaded(relocated) sections."]
    #[doc = " This API is useful to save a module, or specify its location on the system and report information about loaded sections."]
    #[doc = " The target module is saved on the system if module buffer content and size are available."]
    #[doc = " If module buffer content and size are unavailable, the module name contains the path to the existing binary module."]
    #[doc = " @param[in] module_obj - provides module and section information, along with unique module identifiers (name,module ID)"]
    #[doc = " which bind the binary module to particular sections."]
    pub fn __itt_module_load_with_sections(module_obj: *mut __itt_module_object);
}
pub type __itt_module_load_with_sections_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(module_obj: *mut __itt_module_object)>;
extern "C" {
    pub static mut __itt_module_load_with_sections_ptr__3_0:
        __itt_module_load_with_sections_ptr__3_0_t;
}
extern "C" {
    #[doc = " @brief Unload a module and its loaded(relocated) sections."]
    #[doc = " This API notifies that the module and its sections were unloaded."]
    #[doc = " @param[in] module_obj - provides module and sections information, along with unique module identifiers (name,module ID)"]
    #[doc = " which bind the binary module to particular sections."]
    pub fn __itt_module_unload_with_sections(module_obj: *mut __itt_module_object);
}
pub type __itt_module_unload_with_sections_ptr__3_0_t =
    ::std::option::Option<unsafe extern "C" fn(module_obj: *mut __itt_module_object)>;
extern "C" {
    pub static mut __itt_module_unload_with_sections_ptr__3_0:
        __itt_module_unload_with_sections_ptr__3_0_t;
}

// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-regexp-gen.h'
#include 'src/builtins/builtins-utils-gen.h'
#include 'src/builtins/builtins.h'
#include 'src/codegen/code-factory.h'
#include 'src/heap/factory-inl.h'
#include 'src/objects/arguments.h'
#include 'src/objects/bigint.h'
#include 'src/objects/elements-kind.h'
#include 'src/objects/free-space.h'
#include 'src/objects/js-generator.h'
#include 'src/objects/js-promise.h'
#include 'src/objects/js-regexp-string-iterator.h'
#include 'src/objects/module.h'
#include 'src/objects/objects.h'
#include 'src/objects/stack-frame-info.h'
#include 'src/objects/template-objects.h'

type void;
type never;

type Tagged generates 'TNode<Object>' constexpr 'ObjectPtr';
type Smi extends Tagged generates 'TNode<Smi>' constexpr 'Smi';

// A Smi that is greater than or equal to 0. See TaggedIsPositiveSmi.
type PositiveSmi extends Smi;

// The Smi value zero, which is often used as null for HeapObject types.
type Zero extends PositiveSmi;

@abstract
extern class HeapObject extends Tagged {
  map: Map;
}

type Object = Smi | HeapObject;
type int32 generates 'TNode<Int32T>' constexpr 'int32_t';
type uint32 generates 'TNode<Uint32T>' constexpr 'uint32_t';
type int31 extends int32
    generates 'TNode<Int32T>' constexpr 'int31_t';
type uint31 extends uint32
    generates 'TNode<Uint32T>' constexpr 'uint31_t';
type int16 extends int31
    generates 'TNode<Int16T>' constexpr 'int16_t';
type uint16 extends uint31
    generates 'TNode<Uint16T>' constexpr 'uint16_t';
type int8 extends int16 generates 'TNode<Int8T>' constexpr 'int8_t';
type uint8 extends uint16
    generates 'TNode<Uint8T>' constexpr 'uint8_t';
type int64 generates 'TNode<Int64T>' constexpr 'int64_t';
type intptr generates 'TNode<IntPtrT>' constexpr 'intptr_t';
type uintptr generates 'TNode<UintPtrT>' constexpr 'uintptr_t';
type float32 generates 'TNode<Float32T>' constexpr 'float';
type float64 generates 'TNode<Float64T>' constexpr 'double';
type bool generates 'TNode<BoolT>' constexpr 'bool';
type bint generates 'TNode<BInt>' constexpr 'BInt';
type string constexpr 'const char*';

type NameDictionary extends FixedArray;

type RawPtr generates 'TNode<RawPtrT>' constexpr 'void*';
type Code extends HeapObject generates 'TNode<Code>';
type BuiltinPtr extends Smi generates 'TNode<BuiltinPtr>';
extern class Context extends HeapObject {
  length: Smi;
  scope_info: ScopeInfo;
  previous: Object;
  extension: Object;
  native_context: Object;
}
type NativeContext extends Context;

@generateCppClass
extern class Oddball extends HeapObject {
  to_number_raw: float64;
  to_string: String;
  to_number: Number;
  type_of: String;
  kind: Smi;
}

extern class HeapNumber extends HeapObject { value: float64; }
type Number = Smi | HeapNumber;
type BigInt extends HeapObject generates 'TNode<BigInt>';
type Numeric = Number | BigInt;

@abstract
@noVerifier
extern class Name extends HeapObject {
  hash_field: int32;
}

extern class Symbol extends Name {
  flags: int32;
  name: Object;
}

@abstract
extern class String extends Name {
  length: uint32;
}

extern class ConsString extends String {
  first: String;
  second: String;
}

@abstract
@noVerifier
extern class ExternalString extends String {
  resource: RawPtr;
  resource_data: RawPtr;
}

extern class ExternalOneByteString extends ExternalString {}
extern class ExternalTwoByteString extends ExternalString {}

extern class InternalizedString extends String {}

// TODO(v8:8983): Add declaration for variable-sized region.
@abstract
@noVerifier
extern class SeqString extends String {
}
extern class SeqOneByteString extends SeqString {}
extern class SeqTwoByteString extends SeqString {}

extern class SlicedString extends String {
  parent: String;
  offset: Smi;
}

extern class ThinString extends String { actual: String; }

// The HeapNumber value NaN
type NaN extends HeapNumber;

@abstract
@noVerifier
@generatePrint
@generateCppClass
extern class Struct extends HeapObject {
}

@abstract
@dirtyInstantiatedAbstractClass
@generatePrint
@generateCppClass
extern class Tuple2 extends Struct {
  value1: Object;
  value2: Object;
}

@abstract
@dirtyInstantiatedAbstractClass
@generatePrint
@generateCppClass
extern class Tuple3 extends Tuple2 {
  value3: Object;
}

// A direct string can be accessed directly through CSA without going into the
// C++ runtime. See also: ToDirectStringAssembler.
type DirectString extends String;

type RootIndex generates 'TNode<Int32T>' constexpr 'RootIndex';

@abstract
@noVerifier
@generateCppClass
extern class FixedArrayBase extends HeapObject {
  length: Smi;
}

extern class FixedArray extends FixedArrayBase { objects[length]: Object; }

extern class FixedDoubleArray extends FixedArrayBase {
  floats[length]: float64;
}

extern class WeakFixedArray extends HeapObject { length: Smi; }

extern class ByteArray extends FixedArrayBase {}

type LayoutDescriptor extends ByteArray
    generates 'TNode<LayoutDescriptor>';
type TransitionArray extends WeakFixedArray
    generates 'TNode<TransitionArray>';

// InstanceType actually extends uint16, but a bunch of methods in
// CodeStubAssembler expect a TNode<Int32T>, so keeping it signed for now.
type InstanceType extends int16 constexpr 'InstanceType';

extern class Map extends HeapObject {
  instance_size_in_words: uint8;
  in_object_properties_start_or_constructor_function_index: uint8;
  used_or_unused_instance_size_in_words: uint8;
  visitor_id: uint8;
  instance_type: InstanceType;
  bit_field: uint8;
  bit_field2: uint8;
  bit_field3: uint32;

  @if(TAGGED_SIZE_8_BYTES) optional_padding: uint32;
  @ifnot(TAGGED_SIZE_8_BYTES) optional_padding: void;

  prototype: HeapObject;
  constructor_or_back_pointer: Object;
  instance_descriptors: DescriptorArray;
  @if(V8_DOUBLE_FIELDS_UNBOXING) layout_descriptor: LayoutDescriptor;
  @ifnot(V8_DOUBLE_FIELDS_UNBOXING) layout_descriptor: void;
  dependent_code: DependentCode;
  prototype_validity_cell: Smi | Cell;
  weak transitions_or_prototype_info: Map | TransitionArray |
      PrototypeInfo | Smi;
}

type BytecodeArray extends FixedArrayBase;

@generatePrint
extern class EnumCache extends Struct {
  keys: FixedArray;
  indices: FixedArray;
}

@generatePrint
extern class SourcePositionTableWithFrameCache extends Struct {
  source_position_table: ByteArray;
  stack_frame_cache: Object;
}

// We make this class abstract because it is missing the variable-sized part,
// which is still impossible to express in Torque.
@abstract
extern class DescriptorArray extends HeapObject {
  number_of_all_descriptors: uint16;
  number_of_descriptors: uint16;
  raw_number_of_marked_descriptors: uint16;
  filler16_bits: uint16;
  enum_cache: EnumCache;
  // DescriptorEntry needs to be a struct with three fields.
  // desriptors : DescriptorEntry[number_of_all_descriptors]
}

// These intrinsics should never be called from Torque code. They're used
// internally by the 'new' operator and only declared here because it's simpler
// than building the definition from C++.
intrinsic %GetAllocationBaseSize<Class: type>(map: Map): intptr;
intrinsic %Allocate<Class: type>(size: intptr): Class;
intrinsic %AllocateInternalClass<Class: type>(slotCount: constexpr intptr):
    Class;

intrinsic %AddIndexedFieldSizeToObjectSize<T: type>(
    baseSize: intptr, indexSize: T, fieldSize: int32): intptr {
  const convertedIndexSize = Convert<int32>(indexSize);
  const variableSize: int32 =
      TryInt32Mul(convertedIndexSize, fieldSize) otherwise unreachable;
  const convertedVariableSize = Convert<intptr>(variableSize);
  return TryIntPtrAdd(baseSize, convertedVariableSize) otherwise unreachable;
}

intrinsic
%InitializeFieldsFromIterator<Container: type, Index: type, Iterator: type>(
    c: Container, length: Index, i: Iterator) {
  try {
    let mutableIterator = i;
    let current: Index = 0;
    while (current < length) {
      // TODO(danno): The indexed accessor on the container requires that the
      // '[]=' operator be defined explicitly for the Container
      // (e.g. FixedArray). We should change this to use slice references
      // once they are implemented.
      c[current++] = mutableIterator.Next() otherwise NoMore;
    }
  }
  label NoMore deferred {
    unreachable;
  }
}

@abstract
@noVerifier
extern class JSReceiver extends HeapObject {
  properties_or_hash: FixedArrayBase | Smi;
}

type Constructor extends JSReceiver;

@abstract
@dirtyInstantiatedAbstractClass
extern class JSObject extends JSReceiver {
  @noVerifier elements: FixedArrayBase;
}

macro NewJSObject(
    map: Map, properties: FixedArrayBase | Smi,
    elements: FixedArrayBase): JSObject {
  return new JSObject{map, properties_or_hash: properties, elements};
}
macro NewJSObject(implicit context: Context)(): JSObject {
  const objectFunction: JSFunction = GetObjectFunction();
  const map: Map = Cast<Map>(objectFunction.prototype_or_initial_map)
      otherwise unreachable;
  return new JSObject{
    map,
    properties_or_hash: kEmptyFixedArray,
    elements: kEmptyFixedArray
  };
}

macro GetDerivedMap(implicit context: Context)(
    target: JSFunction, newTarget: JSReceiver): Map {
  try {
    const constructor = Cast<JSFunction>(newTarget) otherwise SlowPath;
    const map =
        Cast<Map>(constructor.prototype_or_initial_map) otherwise SlowPath;
    if (LoadConstructorOrBackPointer(map) != target) {
      goto SlowPath;
    }

    return map;
  }
  label SlowPath {
    return runtime::GetDerivedMap(context, target, newTarget);
  }
}

extern class JSFunction extends JSObject {
  shared_function_info: SharedFunctionInfo;
  context: Context;
  feedback_cell: FeedbackCell;
  weak code: Code;
  @noVerifier weak prototype_or_initial_map: JSReceiver | Map;
}

extern class JSProxy extends JSReceiver {
  target: Object;
  handler: Object;
}

@noVerifier
extern class JSProxyRevocableResult extends JSObject {
  proxy: Object;
  revoke: Object;
}

macro NewJSProxyRevocableResult(implicit context: Context)(
    proxy: JSProxy, revoke: JSFunction): JSProxyRevocableResult {
  return new JSProxyRevocableResult{
    map: GetProxyRevocableResultMap(),
    properties_or_hash: kEmptyFixedArray,
    elements: kEmptyFixedArray,
    proxy,
    revoke
  };
}

extern class JSGlobalProxy extends JSObject { native_context: Object; }

extern class JSValue extends JSObject { value: Object; }

extern class JSArgumentsObject extends JSObject {}
@noVerifier
@hasSameInstanceTypeAsParent
extern class JSArgumentsObjectWithLength extends JSArgumentsObject {
  length: Object;
}
@hasSameInstanceTypeAsParent
extern class JSSloppyArgumentsObject extends JSArgumentsObjectWithLength {
  callee: Object;
}

extern class JSArrayIterator extends JSObject {
  iterated_object: JSReceiver;
  next_index: Number;
  kind: Smi;
}

extern class JSArray extends JSObject {
  IsEmpty(): bool {
    return this.length == 0;
  }
  length: Number;
}

macro NewJSArray(implicit context: Context)(
    map: Map, elements: FixedArrayBase): JSArray {
  return new JSArray{
    map,
    properties_or_hash: kEmptyFixedArray,
    elements,
    length: elements.length
  };
}

macro NewJSArray(implicit context: Context)(): JSArray {
  return new JSArray{
    map: GetFastPackedSmiElementsJSArrayMap(),
    properties_or_hash: kEmptyFixedArray,
    elements: kEmptyFixedArray,
    length: 0
  };
}

struct HoleIterator {
  Next(): Object labels NoMore() {
    return Hole;
  }
}

macro NewJSArray(implicit context: Context)(map: Map, length: Smi): JSArray {
  const map = GetFastPackedSmiElementsJSArrayMap();
  const i = HoleIterator{};
  const elements = new FixedArray{map, length, objects: ...i};
  return new
  JSArray{map, properties_or_hash: kEmptyFixedArray, elements, length};
}

// A HeapObject with a JSArray map, and either fast packed elements, or fast
// holey elements when the global NoElementsProtector is not invalidated.
transient type FastJSArray extends JSArray;

// A HeapObject with a JSArray map, and either fast packed elements, or fast
// holey elements or frozen, sealed elements when the global NoElementsProtector
// is not invalidated.
transient type FastJSArrayForRead extends JSArray;

// A FastJSArray when the global ArraySpeciesProtector is not invalidated.
transient type FastJSArrayForCopy extends FastJSArray;

// A FastJSArray when the global ArrayIteratorProtector is not invalidated.
transient type FastJSArrayWithNoCustomIteration extends FastJSArray;

// A FastJSArrayForRead when the global ArrayIteratorProtector is not
// invalidated.
transient type FastJSArrayForReadWithNoCustomIteration extends
    FastJSArrayForRead;

type NoSharedNameSentinel extends Smi;

type JSModuleNamespace extends JSObject;
type WeakArrayList extends HeapObject;

@abstract
@noVerifier
extern class JSWeakCollection extends JSObject {
  table: Object;
}
extern class JSWeakSet extends JSWeakCollection {}
extern class JSWeakMap extends JSWeakCollection {}

@noVerifier
extern class JSCollectionIterator extends JSObject {
  table: Object;
  index: Object;
}

extern class JSMessageObject extends JSObject {
  // Tagged fields.
  message_type: Smi;
  arguments: Object;
  script: Script;
  stack_frames: Object;
  shared_info: SharedFunctionInfo | Undefined;

  // Raw data fields.
  // TODO(ishell): store as int32 instead of Smi.
  bytecode_offset: Smi;
  start_position: Smi;
  end_position: Smi;
  error_level: Smi;
}

extern class PrototypeInfo extends Struct {
  js_module_namespace: JSModuleNamespace | Undefined;
  prototype_users: WeakArrayList | Zero;
  registry_slot: Smi;
  validity_cell: Object;
  @noVerifier object_create_map: Smi | WeakArrayList;
  bit_field: Smi;
}

extern class Script extends Struct {
  source: Object;
  name: Object;
  line_offset: Smi;
  column_offset: Smi;
  context: Object;
  script_type: Smi;
  line_ends: Object;
  id: Smi;
  eval_from_shared_or_wrapped_arguments: Object;
  eval_from_position: Smi;
  shared_function_infos: Object;
  flags: Smi;
  source_url: Object;
  source_mapping_url: Object;
  host_defined_options: Object;
}

extern class EmbedderDataArray extends HeapObject { length: Smi; }

type ScopeInfo extends Object generates 'TNode<ScopeInfo>';

extern class PreparseData extends HeapObject {
  // TODO(v8:8983): Add declaration for variable-sized region.
  data_length: int32;
  inner_length: int32;
}

extern class InterpreterData extends Struct {
  bytecode_array: BytecodeArray;
  interpreter_trampoline: Code;
}

extern class SharedFunctionInfo extends HeapObject {
  weak function_data: Object;
  name_or_scope_info: String | NoSharedNameSentinel | ScopeInfo;
  outer_scope_info_or_feedback_metadata: HeapObject;
  script_or_debug_info: Script | DebugInfo | Undefined;
  length: int16;
  formal_parameter_count: uint16;
  // Currently set to uint16, can be set to uint8 to save space.
  expected_nof_properties: uint16;
  function_token_offset: int16;
  flags: int32;
  @if(V8_SFI_HAS_UNIQUE_ID) unique_id: int32;
}

extern class JSBoundFunction extends JSObject {
  bound_target_function: JSReceiver;
  bound_this: Object;
  bound_arguments: FixedArray;
}

type Callable = JSFunction | JSBoundFunction | JSProxy;

extern operator '.length_intptr' macro LoadAndUntagFixedArrayBaseLength(
    FixedArrayBase): intptr;

type SloppyArgumentsElements extends FixedArray;
type NumberDictionary extends HeapObject
    generates 'TNode<NumberDictionary>';

extern class FreeSpace extends HeapObject {
  size: Smi;
  @noVerifier next: FreeSpace;
}

// %RawDownCast should *never* be used anywhere in Torque code except for
// in Torque-based UnsafeCast operators preceeded by an appropriate
// type assert()
intrinsic %RawDownCast<To: type, From: type>(x: From): To;
intrinsic %RawConstexprCast<To: type, From: type>(f: From): To;

type NativeContextSlot generates 'TNode<IntPtrT>' constexpr 'int32_t';
const ARRAY_BUFFER_FUN_INDEX: constexpr NativeContextSlot
    generates 'Context::ARRAY_BUFFER_FUN_INDEX';
const ARRAY_BUFFER_NOINIT_FUN_INDEX: constexpr NativeContextSlot
    generates 'Context::ARRAY_BUFFER_NOINIT_FUN_INDEX';
const ARRAY_BUFFER_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::ARRAY_BUFFER_MAP_INDEX';
const ARRAY_JOIN_STACK_INDEX: constexpr NativeContextSlot
    generates 'Context::ARRAY_JOIN_STACK_INDEX';
const OBJECT_FUNCTION_INDEX: constexpr NativeContextSlot
    generates 'Context::OBJECT_FUNCTION_INDEX';
const ITERATOR_RESULT_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::ITERATOR_RESULT_MAP_INDEX';
const JS_ARRAY_PACKED_ELEMENTS_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::JS_ARRAY_PACKED_ELEMENTS_MAP_INDEX';
const JS_ARRAY_PACKED_SMI_ELEMENTS_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::JS_ARRAY_PACKED_SMI_ELEMENTS_MAP_INDEX';
const PROXY_REVOCABLE_RESULT_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::PROXY_REVOCABLE_RESULT_MAP_INDEX';
const REFLECT_APPLY_INDEX: constexpr NativeContextSlot
    generates 'Context::REFLECT_APPLY_INDEX';
const REGEXP_LAST_MATCH_INFO_INDEX: constexpr NativeContextSlot
    generates 'Context::REGEXP_LAST_MATCH_INFO_INDEX';
const INITIAL_STRING_ITERATOR_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::INITIAL_STRING_ITERATOR_MAP_INDEX';
extern operator '[]' macro LoadContextElement(
    NativeContext, NativeContextSlot): Object;
extern operator '[]=' macro StoreContextElement(
    NativeContext, NativeContextSlot, Object): void;

type ContextSlot generates 'TNode<IntPtrT>' constexpr 'int32_t';
const PROXY_SLOT: constexpr ContextSlot
    generates 'Context::MIN_CONTEXT_SLOTS';
extern operator '[]' macro LoadContextElement(Context, ContextSlot): Object;
extern operator '[]=' macro StoreContextElement(
    Context, ContextSlot, Object): void;

extern operator '[]' macro LoadContextElement(Context, intptr): Object;
extern operator '[]' macro LoadContextElement(Context, Smi): Object;

extern class JSArrayBuffer extends JSObject {
  byte_length: uintptr;
  backing_store: RawPtr;
}

@abstract
extern class JSArrayBufferView extends JSObject {
  buffer: JSArrayBuffer;
  byte_offset: uintptr;
  byte_length: uintptr;
}

extern class JSTypedArray extends JSArrayBufferView {
  AttachOffHeapBuffer(buffer: JSArrayBuffer, byteOffset: uintptr): void {
    const basePointer: Smi = 0;

    // The max byteOffset is 8 * MaxSmi on the particular platform. 32 bit
    // platforms are self-limiting, because we can't allocate an array bigger
    // than our 32-bit arithmetic range anyway. 64 bit platforms could
    // theoretically have an offset up to 2^35 - 1.
    const backingStore = buffer.backing_store;
    const externalPointer = backingStore + Convert<intptr>(byteOffset);

    // Assert no overflow has occurred. Only assert if the mock array buffer
    // allocator is NOT used. When the mock array buffer is used, impossibly
    // large allocations are allowed that would erroneously cause an overflow
    // and this assertion to fail.
    assert(
        IsMockArrayBufferAllocatorFlag() ||
        Convert<uintptr>(externalPointer) >= Convert<uintptr>(backingStore));

    this.elements = kEmptyByteArray;
    this.buffer = buffer;
    this.external_pointer = externalPointer;
    this.base_pointer = basePointer;
  }

  length: uintptr;
  external_pointer: RawPtr;
  base_pointer: ByteArray | Smi;
}

@noVerifier
extern class JSAccessorPropertyDescriptor extends JSObject {
  get: Object;
  set: Object;
  enumerable: Object;
  configurable: Object;
}

@abstract
@noVerifier
extern class JSCollection extends JSObject {
  table: Object;
}
extern class JSSet extends JSCollection {}
extern class JSMap extends JSCollection {}

extern class JSDate extends JSObject {
  value: NumberOrUndefined;
  year: Undefined | Smi | NaN;
  month: Undefined | Smi | NaN;
  day: Undefined | Smi | NaN;
  weekday: Undefined | Smi | NaN;
  hour: Undefined | Smi | NaN;
  min: Undefined | Smi | NaN;
  sec: Undefined | Smi | NaN;
  cache_stamp: Undefined | Smi | NaN;
}

extern class JSGlobalObject extends JSObject {
  native_context: NativeContext;
  global_proxy: JSGlobalProxy;
}

extern class JSAsyncFromSyncIterator extends JSObject {
  sync_iterator: JSReceiver;
  next: Object;
}

extern class JSStringIterator extends JSObject {
  string: String;
  next_index: Smi;
}

@noVerifier
extern class JSDataPropertyDescriptor extends JSObject {
  value: Object;
  writable: Object;
  enumerable: Object;
  configurable: Object;
}

@abstract
extern class TemplateInfo extends Struct {
  tag: Object;
  serial_number: Object;
  number_of_properties: Smi;
  property_list: Object;
  property_accessors: Object;
}

@generatePrint
extern class TemplateObjectDescription extends Struct {
  raw_strings: FixedArray;
  cooked_strings: FixedArray;
}

extern class FunctionTemplateRareData extends Struct {
  prototype_template: Object;
  prototype_provider_template: Object;
  parent_template: Object;
  named_property_handler: Object;
  indexed_property_handler: Object;
  instance_template: Object;
  instance_call_handler: Object;
  access_check_info: Object;
}

extern class FunctionTemplateInfo extends TemplateInfo {
  call_code: Object;
  class_name: Object;
  signature: Object;
  function_template_rare_data: Object;
  shared_function_info: Object;
  flag: Smi;
  @noVerifier length: Smi;
  cached_property_name: Object;
}

extern class ObjectTemplateInfo extends TemplateInfo {
  constructor: Object;
  data: Object;
}

extern class PropertyArray extends HeapObject { length_and_hash: Smi; }

type DependentCode extends WeakFixedArray;

extern class PropertyCell extends HeapObject {
  name: Name;
  property_details_raw: Smi;
  value: Object;
  dependent_code: DependentCode;
}

extern class JSDataView extends JSArrayBufferView { data_pointer: RawPtr; }

type ElementsKind generates 'TNode<Int32T>' constexpr 'ElementsKind';
type LanguageMode extends Smi constexpr 'LanguageMode';
type ExtractFixedArrayFlags
    generates 'TNode<Smi>'
    constexpr 'CodeStubAssembler::ExtractFixedArrayFlags';
type ParameterMode
    generates 'TNode<Int32T>' constexpr 'ParameterMode';
type WriteBarrierMode
    generates 'TNode<Int32T>' constexpr 'WriteBarrierMode';

type MessageTemplate constexpr 'MessageTemplate';
type PrimitiveType constexpr 'PrimitiveType';
type ToIntegerTruncationMode
constexpr 'CodeStubAssembler::ToIntegerTruncationMode';
type AllocationFlags constexpr 'AllocationFlags';
type SlackTrackingMode constexpr 'SlackTrackingMode';

type UnicodeEncoding constexpr 'UnicodeEncoding';
const UTF16:
    constexpr UnicodeEncoding generates 'UnicodeEncoding::UTF16';
const UTF32:
    constexpr UnicodeEncoding generates 'UnicodeEncoding::UTF32';

extern class Foreign extends HeapObject { foreign_address: RawPtr; }

extern class InterceptorInfo extends Struct {
  @noVerifier getter: Foreign | Zero;
  @noVerifier setter: Foreign | Zero;
  @noVerifier query: Foreign | Zero;
  @noVerifier descriptor: Foreign | Zero;
  @noVerifier deleter: Foreign | Zero;
  @noVerifier enumerator: Foreign | Zero;
  @noVerifier definer: Foreign | Zero;
  data: Object;
  flags: Smi;
}

extern class AccessCheckInfo extends Struct {
  callback: Foreign | Zero;
  named_interceptor: InterceptorInfo | Zero;
  indexed_interceptor: InterceptorInfo | Zero;
  data: Object;
}

extern class ArrayBoilerplateDescription extends Struct {
  flags: Smi;
  constant_elements: FixedArrayBase;
}

extern class AliasedArgumentsEntry extends Struct { aliased_context_slot: Smi; }

extern class Cell extends HeapObject { value: Object; }

extern class DataHandler extends Struct {
  smi_handler: Smi | Code;
  validity_cell: Smi | Cell;
  @noVerifier weak data_1: Object;
  @noVerifier weak data_2: Object;
  @noVerifier weak data_3: Object;
}

@abstract
@dirtyInstantiatedAbstractClass
extern class JSGeneratorObject extends JSObject {
  function: JSFunction;
  context: Context;
  receiver: Object;
  input_or_debug_pos: Object;
  resume_mode: Smi;
  continuation: Smi;
  parameters_and_registers: FixedArray;
}

extern class JSAsyncFunctionObject extends JSGeneratorObject {
  promise: JSPromise;
}

extern class JSAsyncGeneratorObject extends JSGeneratorObject {
  queue: HeapObject;
  is_awaiting: Smi;
}

extern class JSPromise extends JSObject {
  reactions_or_result: Object;
  flags: Smi;
}

@abstract
extern class Microtask extends Struct {
}

extern class CallbackTask extends Microtask {
  callback: Foreign;
  data: Foreign;
}

extern class CallableTask extends Microtask {
  callable: JSReceiver;
  context: Context;
}

extern class StackFrameInfo extends Struct {
  line_number: Smi;
  column_number: Smi;
  promise_all_index: Smi;
  script_id: Smi;
  script_name: Object;
  script_name_or_source_url: Object;
  function_name: Object;
  wasm_module_name: Object;
  flag: Smi;
}

extern class StackTraceFrame extends Struct {
  frame_array: Object;
  frame_index: Smi;
  frame_info: Object;
  id: Smi;
}

extern class ClassPositions extends Struct {
  start: Smi;
  end: Smi;
}

type WasmInstanceObject extends JSObject;

extern class WasmExportedFunctionData extends Struct {
  wrapper_code: Code;
  instance: WasmInstanceObject;
  jump_table_offset: Smi;
  function_index: Smi;
}

extern class WasmJSFunctionData extends Struct { wrapper_code: Code; }

extern class WasmCapiFunctionData extends Struct {
  call_target: RawPtr;
  embedder_data: RawPtr;
  wrapper_code: Code;
  serialized_signature: ByteArray;  // PodArray<wasm::ValueType>
}

extern class WasmDebugInfo extends Struct {
  instance: WasmInstanceObject;
  interpreter_handle: Foreign | Undefined;
  locals_names: FixedArray | Undefined;
  c_wasm_entries: FixedArray | Undefined;
  c_wasm_entry_map: Foreign | Undefined;  // Managed<wasm::SignatureMap>
}

extern class WasmExceptionTag extends Struct { index: Smi; }

const kSmiTagSize: constexpr int31 generates 'kSmiTagSize';
const V8_INFINITY: constexpr float64 generates 'V8_INFINITY';

const NO_ELEMENTS: constexpr ElementsKind generates 'NO_ELEMENTS';

const PACKED_SMI_ELEMENTS:
    constexpr ElementsKind generates 'PACKED_SMI_ELEMENTS';
const HOLEY_SMI_ELEMENTS:
    constexpr ElementsKind generates 'HOLEY_SMI_ELEMENTS';
const PACKED_ELEMENTS:
    constexpr ElementsKind generates 'PACKED_ELEMENTS';
const HOLEY_ELEMENTS: constexpr ElementsKind generates 'HOLEY_ELEMENTS';
const PACKED_DOUBLE_ELEMENTS:
    constexpr ElementsKind generates 'PACKED_DOUBLE_ELEMENTS';
const HOLEY_DOUBLE_ELEMENTS:
    constexpr ElementsKind generates 'HOLEY_DOUBLE_ELEMENTS';
const LAST_FROZEN_ELEMENTS_KIND:
    constexpr ElementsKind generates 'LAST_FROZEN_ELEMENTS_KIND';
const DICTIONARY_ELEMENTS:
    constexpr ElementsKind generates 'DICTIONARY_ELEMENTS';

const UINT8_ELEMENTS: constexpr ElementsKind generates 'UINT8_ELEMENTS';
const INT8_ELEMENTS: constexpr ElementsKind generates 'INT8_ELEMENTS';
const UINT16_ELEMENTS:
    constexpr ElementsKind generates 'UINT16_ELEMENTS';
const INT16_ELEMENTS: constexpr ElementsKind generates 'INT16_ELEMENTS';
const UINT32_ELEMENTS:
    constexpr ElementsKind generates 'UINT32_ELEMENTS';
const INT32_ELEMENTS: constexpr ElementsKind generates 'INT32_ELEMENTS';
const FLOAT32_ELEMENTS:
    constexpr ElementsKind generates 'FLOAT32_ELEMENTS';
const FLOAT64_ELEMENTS:
    constexpr ElementsKind generates 'FLOAT64_ELEMENTS';
const UINT8_CLAMPED_ELEMENTS:
    constexpr ElementsKind generates 'UINT8_CLAMPED_ELEMENTS';
const BIGUINT64_ELEMENTS:
    constexpr ElementsKind generates 'BIGUINT64_ELEMENTS';
const BIGINT64_ELEMENTS:
    constexpr ElementsKind generates 'BIGINT64_ELEMENTS';

const kNone:
    constexpr AllocationFlags generates 'CodeStubAssembler::kNone';
const kDoubleAlignment: constexpr AllocationFlags
    generates 'CodeStubAssembler::kDoubleAlignment';
const kPretenured:
    constexpr AllocationFlags generates 'CodeStubAssembler::kPretenured';
const kAllowLargeObjectAllocation: constexpr AllocationFlags
    generates 'CodeStubAssembler::kAllowLargeObjectAllocation';

const kWithSlackTracking: constexpr SlackTrackingMode
    generates 'SlackTrackingMode::kWithSlackTracking';
const kNoSlackTracking: constexpr SlackTrackingMode
    generates 'SlackTrackingMode::kNoSlackTracking';

const kFixedDoubleArrays: constexpr ExtractFixedArrayFlags
    generates 'CodeStubAssembler::ExtractFixedArrayFlag::kFixedDoubleArrays';
const kAllFixedArrays: constexpr ExtractFixedArrayFlags
    generates 'CodeStubAssembler::ExtractFixedArrayFlag::kAllFixedArrays';
const kFixedArrays: constexpr ExtractFixedArrayFlags
    generates 'CodeStubAssembler::ExtractFixedArrayFlag::kFixedArrays';

const kFixedArrayMapRootIndex:
    constexpr RootIndex generates 'RootIndex::kFixedArrayMap';
const kFixedCOWArrayMapRootIndex:
    constexpr RootIndex generates 'RootIndex::kFixedCOWArrayMap';
const kEmptyByteArrayRootIndex:
    constexpr RootIndex generates 'RootIndex::kEmptyByteArray';
const kEmptyFixedArrayRootIndex:
    constexpr RootIndex generates 'RootIndex::kEmptyFixedArray';
const kTheHoleValueRootIndex:
    constexpr RootIndex generates 'RootIndex::kTheHoleValue';

const kInvalidArrayBufferLength: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidArrayBufferLength';
const kInvalidArrayLength: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidArrayLength';
const kCalledNonCallable: constexpr MessageTemplate
    generates 'MessageTemplate::kCalledNonCallable';
const kCalledOnNullOrUndefined: constexpr MessageTemplate
    generates 'MessageTemplate::kCalledOnNullOrUndefined';
const kInvalidOffset: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidOffset';
const kInvalidTypedArrayLength: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidTypedArrayLength';
const kIteratorSymbolNonCallable: constexpr MessageTemplate
    generates 'MessageTemplate::kIteratorSymbolNonCallable';
const kIteratorValueNotAnObject: constexpr MessageTemplate
    generates 'MessageTemplate::kIteratorValueNotAnObject';
const kNotIterable: constexpr MessageTemplate
    generates 'MessageTemplate::kNotIterable';
const kReduceNoInitial: constexpr MessageTemplate
    generates 'MessageTemplate::kReduceNoInitial';
const kFirstArgumentNotRegExp: constexpr MessageTemplate
    generates 'MessageTemplate::kFirstArgumentNotRegExp';
const kBigIntMixedTypes: constexpr MessageTemplate
    generates 'MessageTemplate::kBigIntMixedTypes';
const kTypedArrayTooShort: constexpr MessageTemplate
    generates 'MessageTemplate::kTypedArrayTooShort';
const kInvalidCountValue: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidCountValue';
const kConstructorNotFunction: constexpr MessageTemplate
    generates 'MessageTemplate::kConstructorNotFunction';
const kSymbolToString: constexpr MessageTemplate
    generates 'MessageTemplate::kSymbolToString';
const kPropertyNotFunction: constexpr MessageTemplate
    generates 'MessageTemplate::kPropertyNotFunction';

const kMaxArrayIndex:
    constexpr uint32 generates 'JSArray::kMaxArrayIndex';
const kArrayBufferMaxByteLength:
    constexpr uintptr generates 'JSArrayBuffer::kMaxByteLength';
const V8_TYPED_ARRAY_MAX_SIZE_IN_HEAP:
    constexpr int31 generates 'V8_TYPED_ARRAY_MAX_SIZE_IN_HEAP';
const kMaxSafeInteger: constexpr float64 generates 'kMaxSafeInteger';
const kSmiMaxValue: constexpr uintptr generates 'kSmiMaxValue';
const kSmiMax: uintptr = kSmiMaxValue;
const kStringMaxLength: constexpr int31 generates 'String::kMaxLength';
const kFixedArrayMaxLength:
    constexpr int31 generates 'FixedArray::kMaxLength';
const kObjectAlignmentMask: constexpr intptr
    generates 'kObjectAlignmentMask';
const kMinAddedElementsCapacity:
    constexpr int31 generates 'JSObject::kMinAddedElementsCapacity';
const kMaxCopyElements:
    constexpr int31 generates 'JSArray::kMaxCopyElements';
const kMaxRegularHeapObjectSize: constexpr int31
    generates 'kMaxRegularHeapObjectSize';

const kMaxNewSpaceFixedArrayElements: constexpr int31
    generates 'FixedArray::kMaxRegularLength';
const kSloppyArgumentsArgumentsIndex: constexpr int31
    generates 'SloppyArgumentsElements::kArgumentsIndex';
const kSloppyArgumentsContextIndex: constexpr int31
    generates 'SloppyArgumentsElements::kContextIndex';
const kSloppyArgumentsParameterMapStart: constexpr int31
    generates 'SloppyArgumentsElements::kParameterMapStart';

const kTruncateMinusZero: constexpr ToIntegerTruncationMode
    generates 'CodeStubAssembler::ToIntegerTruncationMode::kTruncateMinusZero'
    ;

const kNotTypedArray: constexpr MessageTemplate
    generates 'MessageTemplate::kNotTypedArray';
const kDetachedOperation: constexpr MessageTemplate
    generates 'MessageTemplate::kDetachedOperation';
const kBadSortComparisonFunction: constexpr MessageTemplate
    generates 'MessageTemplate::kBadSortComparisonFunction';
const kIncompatibleMethodReceiver: constexpr MessageTemplate
    generates 'MessageTemplate::kIncompatibleMethodReceiver';
const kInvalidDataViewAccessorOffset: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidDataViewAccessorOffset';
const kStrictReadOnlyProperty: constexpr MessageTemplate
    generates 'MessageTemplate::kStrictReadOnlyProperty';

const kString: constexpr PrimitiveType
    generates 'PrimitiveType::kString';

type Hole extends Oddball;
type Null extends Oddball;
type Undefined extends Oddball;
type True extends Oddball;
type False extends Oddball;
type EmptyString extends String;
type Boolean = True | False;

type NumberOrUndefined = Number | Undefined;

extern macro TheHoleConstant(): Hole;
extern macro NullConstant(): Null;
extern macro UndefinedConstant(): Undefined;
extern macro TrueConstant(): True;
extern macro FalseConstant(): False;
extern macro Int32TrueConstant(): bool;
extern macro Int32FalseConstant(): bool;
extern macro EmptyStringConstant(): EmptyString;
extern macro LengthStringConstant(): String;
extern macro NanConstant(): NaN;

const Hole: Hole = TheHoleConstant();
const Null: Null = NullConstant();
const Undefined: Undefined = UndefinedConstant();
const True: True = TrueConstant();
const False: False = FalseConstant();
const kEmptyString: EmptyString = EmptyStringConstant();
const kLengthString: String = LengthStringConstant();
const kNaN: NaN = NanConstant();

const true: constexpr bool generates 'true';
const false: constexpr bool generates 'false';

const kStrict: constexpr LanguageMode generates 'LanguageMode::kStrict';
const kSloppy: constexpr LanguageMode generates 'LanguageMode::kSloppy';

const SMI_PARAMETERS: constexpr ParameterMode
    generates 'CodeStubAssembler::SMI_PARAMETERS';
const INTPTR_PARAMETERS: constexpr ParameterMode
    generates 'CodeStubAssembler::INTPTR_PARAMETERS';

const SKIP_WRITE_BARRIER:
    constexpr WriteBarrierMode generates 'SKIP_WRITE_BARRIER';
const UNSAFE_SKIP_WRITE_BARRIER:
    constexpr WriteBarrierMode generates 'UNSAFE_SKIP_WRITE_BARRIER';

extern class AsyncGeneratorRequest extends Struct {
  next: AsyncGeneratorRequest | Undefined;
  resume_mode: Smi;
  value: Object;
  promise: JSPromise;
}

extern class ModuleInfoEntry extends Struct {
  export_name: String | Undefined;
  local_name: String | Undefined;
  import_name: String | Undefined;
  module_request: Smi;
  cell_index: Smi;
  beg_pos: Smi;
  end_pos: Smi;
}

extern class PromiseCapability extends Struct {
  promise: JSReceiver | Undefined;
  resolve: Object;
  reject: Object;
}

extern class PromiseReaction extends Struct {
  next: PromiseReaction | Zero;
  reject_handler: Callable | Undefined;
  fulfill_handler: Callable | Undefined;
  promise_or_capability: JSPromise | PromiseCapability | Undefined;
}

@abstract
extern class PromiseReactionJobTask extends Microtask {
  argument: Object;
  context: Context;
  @noVerifier handler: Callable | Undefined;
  promise_or_capability: JSPromise | PromiseCapability | Undefined;
}

extern class PromiseFulfillReactionJobTask extends PromiseReactionJobTask {}

extern class PromiseRejectReactionJobTask extends PromiseReactionJobTask {}

extern class PromiseResolveThenableJobTask extends Microtask {
  context: Context;
  promise_to_resolve: JSPromise;
  then: JSReceiver;
  thenable: JSReceiver;
}

extern class JSRegExp extends JSObject {
  data: FixedArray | Undefined;
  source: String | Undefined;
  flags: Smi | Undefined;
}

@noVerifier
extern class JSIteratorResult extends JSObject {
  value: Object;
  done: Boolean;
}

macro NewJSIteratorResult(implicit context: Context)(
    value: Object, done: Boolean): JSIteratorResult {
  return new JSIteratorResult{
    map: GetIteratorResultMap(),
    properties_or_hash: kEmptyFixedArray,
    elements: kEmptyFixedArray,
    value,
    done
  };
}

// Note: Although a condition for a FastJSRegExp is having a positive smi
// lastIndex (see RegExpBuiltinsAssembler::BranchIfFastRegExp), it is possible
// for this to change without transitioning the transient type. As a precaution,
// validate the lastIndex is positive smi when used in fast paths.
transient type FastJSRegExp extends JSRegExp;

extern operator '.global' macro
RegExpBuiltinsAssembler::FastFlagGetterGlobal(FastJSRegExp): bool;
extern operator '.unicode' macro
RegExpBuiltinsAssembler::FastFlagGetterUnicode(FastJSRegExp): bool;
extern operator '.lastIndex' macro
RegExpBuiltinsAssembler::FastLoadLastIndex(FastJSRegExp): Smi;
extern operator '.lastIndex=' macro
RegExpBuiltinsAssembler::FastStoreLastIndex(FastJSRegExp, Smi): void;

@hasSameInstanceTypeAsParent
extern class JSRegExpResult extends JSArray {
  index: Object;
  input: Object;
  groups: Object;
}

extern class JSRegExpStringIterator extends JSObject {
  iterating_reg_exp: Object;
  iterated_string: String;
  flags: Smi;
}

const kRegExpMatchInfoFirstCaptureIndex:
    constexpr int31 generates 'RegExpMatchInfo::kFirstCaptureIndex';
const kRegExpMatchInfoNumberOfCapturesIndex:
    constexpr int31 generates 'RegExpMatchInfo::kNumberOfCapturesIndex';

macro GetStartOfCaptureIndex(captureIndex: constexpr int31): constexpr int31 {
  return kRegExpMatchInfoFirstCaptureIndex + (captureIndex * 2);
}

@hasSameInstanceTypeAsParent
extern class RegExpMatchInfo extends FixedArray {
  GetStartOfCapture(implicit context: Context)(captureIndex: constexpr int31):
      Smi {
    const index: constexpr int31 = GetStartOfCaptureIndex(captureIndex);
    return UnsafeCast<Smi>(this.objects[index]);
  }
  GetEndOfCapture(implicit context: Context)(captureIndex: constexpr int31):
      Smi {
    const index: constexpr int31 = GetStartOfCaptureIndex(captureIndex) + 1;
    return UnsafeCast<Smi>(this.objects[index]);
  }
  NumberOfCaptures(implicit context: Context)(): Smi {
    return UnsafeCast<Smi>(this.objects[kRegExpMatchInfoNumberOfCapturesIndex]);
  }
}

extern class AccessorInfo extends Struct {
  name: Object;
  flags: Smi;
  expected_receiver_type: Object;
  @noVerifier setter: Foreign | Zero;
  @noVerifier getter: Foreign | Zero;
  @noVerifier js_getter: Foreign | Zero;
  data: Object;
}

extern class AccessorPair extends Struct {
  getter: Object;
  setter: Object;
}

extern class BreakPoint extends Tuple2 {}
extern class BreakPointInfo extends Tuple2 {}
type CoverageInfo extends FixedArray;

extern class DebugInfo extends Struct {
  shared_function_info: SharedFunctionInfo;
  debugger_hints: Smi;
  script: Undefined | Script;
  original_bytecode_array: Undefined | BytecodeArray;
  debug_bytecode_array: Undefined | BytecodeArray;
  break_points: FixedArray;
  flags: Smi;
  coverage_info: CoverageInfo | Undefined;
}

extern class FeedbackVector extends HeapObject {
  shared_function_info: SharedFunctionInfo;
  // TODO(v8:9108): currently no support for MaybeObject in Torque
  @noVerifier optimized_code_weak_or_smi: Object;
  closure_feedback_cell_array: FixedArray;
  length: int32;
  invocation_count: int32;
  profiler_ticks: int32;
  // TODO(v8:9287) The padding is not necessary on platforms with 4 bytes
  // tagged pointers, we should make it conditional; however, platform-specific
  // interacts badly with GCMole, so we need to address that first.
  padding: uint32;
}

extern class FeedbackCell extends Struct {
  value: Undefined | FeedbackVector | FixedArray;
  interrupt_budget: int32;
}

type AllocationSite extends Struct;
extern class AllocationMemento extends Struct {
  @noVerifier allocation_site: AllocationSite;
}

extern class WasmModuleObject extends JSObject {
  native_module: Foreign;
  export_wrappers: FixedArray;
  script: Script;
  weak_instance_list: WeakArrayList;
  asm_js_offset_table: ByteArray | Undefined;
  break_point_infos: FixedArray | Undefined;
}

extern class WasmTableObject extends JSObject {
  entries: FixedArray;
  maximum_length: Smi | HeapNumber | Undefined;
  dispatch_tables: FixedArray;
  raw_type: Smi;
}

extern class WasmMemoryObject extends JSObject {
  array_buffer: JSArrayBuffer;
  maximum_pages: Smi;
  instances: WeakArrayList | Undefined;
}

extern class WasmGlobalObject extends JSObject {
  untagged_buffer: JSArrayBuffer;
  tagged_buffer: FixedArray;
  offset: Smi;
  flags: Smi;
}

extern class WasmExceptionObject extends JSObject {
  serialized_signature: ByteArray;  // PodArray<wasm::ValueType>
  exception_tag: HeapObject;
}

@noVerifier
extern class WasmExceptionPackage extends JSReceiver {
}

type WasmExportedFunction extends JSFunction;

extern class AsmWasmData extends Struct {
  managed_native_module: Foreign;  // Managed<wasm::NativeModule>
  export_wrappers: FixedArray;
  asm_js_offset_table: ByteArray;
  uses_bitset: HeapNumber;
}

extern macro Is64(): constexpr bool;

extern macro SelectBooleanConstant(bool): Boolean;

extern macro Print(constexpr string);
extern macro Print(constexpr string, Object);
extern macro Comment(constexpr string);
extern macro StaticAssert(bool);
extern macro Print(Object);
extern macro DebugBreak();
extern transitioning macro ToInteger_Inline(Context, Object): Number;
extern transitioning macro ToInteger_Inline(
    Context, Object, constexpr ToIntegerTruncationMode): Number;
extern transitioning macro ToLength_Inline(Context, Object): Number;
extern transitioning macro ToNumber_Inline(Context, Object): Number;
extern transitioning macro ToSmiIndex(implicit context: Context)(Object):
    PositiveSmi labels IfRangeError;
extern transitioning macro ToSmiLength(implicit context: Context)(Object):
    PositiveSmi labels IfRangeError;
extern transitioning macro ToString_Inline(Context, Object): String;
extern transitioning macro ToThisString(implicit context: Context)(
    Object, String): String;
extern transitioning macro ToThisValue(implicit context: Context)(
    Object, constexpr PrimitiveType, constexpr string): Object;
extern transitioning macro GetProperty(implicit context: Context)(
    Object, Object): Object;
extern transitioning builtin SetProperty(implicit context: Context)(
    Object, Object, Object);
extern transitioning builtin SetPropertyInLiteral(implicit context: Context)(
    Object, Object, Object);
extern transitioning builtin DeleteProperty(implicit context: Context)(
    Object, Object, LanguageMode);
extern transitioning builtin HasProperty(implicit context: Context)(
    Object, Object): Boolean;
extern transitioning macro HasProperty_Inline(implicit context: Context)(
    JSReceiver, Object): Boolean;

extern macro ThrowRangeError(implicit context: Context)(
    constexpr MessageTemplate): never;
extern macro ThrowRangeError(implicit context: Context)(
    constexpr MessageTemplate, Object): never;
extern macro ThrowTypeError(implicit context: Context)(
    constexpr MessageTemplate): never;
extern macro ThrowTypeError(implicit context: Context)(
    constexpr MessageTemplate, constexpr string): never;
extern macro ThrowTypeError(implicit context: Context)(
    constexpr MessageTemplate, Object): never;
extern macro ThrowTypeError(implicit context: Context)(
    constexpr MessageTemplate, Object, Object): never;
extern macro ThrowTypeError(implicit context: Context)(
    constexpr MessageTemplate, Object, Object, Object): never;
extern transitioning runtime ThrowTypeErrorIfStrict(implicit context: Context)(
    Smi, Object, Object): void;

extern macro ArraySpeciesCreate(Context, Object, Number): JSReceiver;
extern macro ArrayCreate(implicit context: Context)(Number): JSArray;
extern macro BuildAppendJSArray(
    constexpr ElementsKind, FastJSArray, Object): void labels Bailout;

extern macro EnsureArrayPushable(Map): ElementsKind
    labels Bailout;
extern macro EnsureArrayLengthWritable(Map) labels Bailout;
// TODO: Reduce duplication once varargs are supported in macros.
extern macro Construct(implicit context: Context)(
    Constructor, Object): JSReceiver;
extern macro Construct(implicit context: Context)(
    Constructor, Object, Object): JSReceiver;
extern macro Construct(implicit context: Context)(
    Constructor, Object, Object, Object): JSReceiver;
extern macro ConstructWithTarget(implicit context: Context)(
    Constructor, JSReceiver): JSReceiver;
extern macro ConstructWithTarget(implicit context: Context)(
    Constructor, JSReceiver, Object): JSReceiver;
extern macro SpeciesConstructor(implicit context: Context)(
    Object, JSReceiver): JSReceiver;

extern builtin ToObject(Context, Object): JSReceiver;
extern macro ToObject_Inline(Context, Object): JSReceiver;
extern macro IsNullOrUndefined(Object): bool;
extern macro IsTheHole(Object): bool;
extern macro IsString(HeapObject): bool;
transitioning builtin ToString(context: Context, o: Object): String {
  return ToStringImpl(context, o);
}
extern transitioning runtime ToStringRT(Context, Object): String;
extern transitioning builtin NonPrimitiveToPrimitive_String(
    Context, Object): Object;

extern transitioning runtime NormalizeElements(Context, JSObject);
extern transitioning runtime TransitionElementsKindWithKind(
    Context, JSObject, Smi);

extern macro LoadBufferObject(RawPtr, constexpr int32): Object;
extern macro LoadBufferPointer(RawPtr, constexpr int32): RawPtr;
extern macro LoadBufferSmi(RawPtr, constexpr int32): Smi;

extern macro LoadRoot(constexpr RootIndex): Object;
extern macro StoreRoot(constexpr RootIndex, Object): Object;

extern runtime StringEqual(Context, String, String): Oddball;
extern builtin StringLessThan(Context, String, String): Boolean;
extern macro StringCharCodeAt(String, intptr): int32;
extern runtime StringCompareSequence(Context, String, String, Number): Boolean;
extern macro StringFromSingleCharCode(int32): String;

extern macro StrictEqual(Object, Object): Boolean;
extern macro SmiLexicographicCompare(Smi, Smi): Smi;
extern runtime ReThrow(Context, Object): never;
extern runtime ThrowInvalidStringLength(Context): never;

extern operator '==' macro WordEqual(RawPtr, RawPtr): bool;
extern operator '!=' macro WordNotEqual(RawPtr, RawPtr): bool;
extern operator '+' macro RawPtrAdd(RawPtr, intptr): RawPtr;
extern operator '+' macro RawPtrAdd(intptr, RawPtr): RawPtr;

extern operator '<' macro Int32LessThan(int32, int32): bool;
extern operator '<' macro Uint32LessThan(uint32, uint32): bool;
extern operator '>' macro Int32GreaterThan(int32, int32): bool;
extern operator '>' macro Uint32GreaterThan(uint32, uint32): bool;
extern operator '<=' macro Int32LessThanOrEqual(int32, int32): bool;
extern operator '<=' macro Uint32LessThanOrEqual(uint32, uint32): bool;
extern operator '>=' macro Int32GreaterThanOrEqual(int32, int32): bool;
extern operator '>=' macro Uint32GreaterThanOrEqual(uint32, uint32): bool;

extern operator '==' macro SmiEqual(Smi, Smi): bool;
extern operator '!=' macro SmiNotEqual(Smi, Smi): bool;
extern operator '<' macro SmiLessThan(Smi, Smi): bool;
extern operator '<=' macro SmiLessThanOrEqual(Smi, Smi): bool;
extern operator '>' macro SmiGreaterThan(Smi, Smi): bool;
extern operator '>=' macro SmiGreaterThanOrEqual(Smi, Smi): bool;

extern operator '==' macro ElementsKindEqual(
    constexpr ElementsKind, constexpr ElementsKind): constexpr bool;
extern operator '==' macro ElementsKindEqual(ElementsKind, ElementsKind): bool;
operator '!=' macro ElementsKindNotEqual(
    k1: ElementsKind, k2: ElementsKind): bool {
  return !ElementsKindEqual(k1, k2);
}
extern macro IsElementsKindLessThanOrEqual(
    ElementsKind, constexpr ElementsKind): bool;
extern macro IsElementsKindGreaterThan(
    ElementsKind, constexpr ElementsKind): bool;
extern macro IsFastElementsKind(constexpr ElementsKind): constexpr bool;
extern macro IsDoubleElementsKind(constexpr ElementsKind): constexpr bool;

extern macro IsFastAliasedArgumentsMap(implicit context: Context)(Map): bool;
extern macro IsSlowAliasedArgumentsMap(implicit context: Context)(Map): bool;
extern macro IsSloppyArgumentsMap(implicit context: Context)(Map): bool;
extern macro IsStrictArgumentsMap(implicit context: Context)(Map): bool;

extern macro SmiAbove(Smi, Smi): bool;

extern operator '==' macro WordEqual(intptr, intptr): bool;
extern operator '==' macro WordEqual(uintptr, uintptr): bool;
extern operator '!=' macro WordNotEqual(intptr, intptr): bool;
extern operator '!=' macro WordNotEqual(uintptr, uintptr): bool;
extern operator '<' macro IntPtrLessThan(intptr, intptr): bool;
extern operator '<' macro UintPtrLessThan(uintptr, uintptr): bool;
extern operator '>' macro IntPtrGreaterThan(intptr, intptr): bool;
extern operator '>' macro UintPtrGreaterThan(uintptr, uintptr): bool;
extern operator '<=' macro IntPtrLessThanOrEqual(intptr, intptr): bool;
extern operator '<=' macro UintPtrLessThanOrEqual(uintptr, uintptr): bool;
extern operator '>=' macro IntPtrGreaterThanOrEqual(intptr, intptr): bool;
extern operator '>=' macro UintPtrGreaterThanOrEqual(uintptr, uintptr): bool;
extern operator '~' macro WordNot(intptr): intptr;
extern operator '~' macro WordNot(uintptr): uintptr;
extern operator '~' macro ConstexprWordNot(constexpr intptr): constexpr intptr;
extern operator '~' macro ConstexprWordNot(constexpr uintptr):
    constexpr uintptr;

extern operator '==' macro Float64Equal(float64, float64): bool;
extern operator '!=' macro Float64NotEqual(float64, float64): bool;
extern operator '>' macro Float64GreaterThan(float64, float64): bool;
extern operator '<' macro Float64LessThan(float64, float64): bool;

extern macro BranchIfNumberEqual(Number, Number): never
    labels Taken, NotTaken;
operator '==' macro IsNumberEqual(a: Number, b: Number): bool {
  return (BranchIfNumberEqual(a, b)) ? true : false;
}
operator '!=' macro IsNumberNotEqual(a: Number, b: Number): bool {
  return (BranchIfNumberEqual(a, b)) ? false : true;
}
extern operator '<' macro BranchIfNumberLessThan(Number, Number): never
    labels Taken, NotTaken;
extern operator '<=' macro BranchIfNumberLessThanOrEqual(Number, Number): never
    labels Taken, NotTaken;

extern operator '>' macro BranchIfNumberGreaterThan(Number, Number): never
    labels Taken, NotTaken;
extern operator '>=' macro BranchIfNumberGreaterThanOrEqual(
    Number, Number): never
    labels Taken, NotTaken;

// The type of all tagged values that can safely be compared with WordEqual.
type TaggedWithIdentity =
    JSReceiver | FixedArrayBase | Oddball | Map | EmptyString;

extern operator '==' macro WordEqual(TaggedWithIdentity, Object): bool;
extern operator '==' macro WordEqual(Object, TaggedWithIdentity): bool;
extern operator '==' macro WordEqual(
    TaggedWithIdentity, TaggedWithIdentity): bool;
extern operator '!=' macro WordNotEqual(TaggedWithIdentity, Object): bool;
extern operator '!=' macro WordNotEqual(Object, TaggedWithIdentity): bool;
extern operator '!=' macro WordNotEqual(
    TaggedWithIdentity, TaggedWithIdentity): bool;
// Do not overload == and != if it is unclear if object identity is the right
// equality.
extern macro WordEqual(Object, Object): bool;
extern macro WordNotEqual(Object, Object): bool;

extern operator '+' macro SmiAdd(Smi, Smi): Smi;
extern operator '-' macro SmiSub(Smi, Smi): Smi;
extern operator '&' macro SmiAnd(Smi, Smi): Smi;
extern operator '|' macro SmiOr(Smi, Smi): Smi;
extern operator '<<' macro SmiShl(Smi, constexpr int31): Smi;
extern operator '>>' macro SmiSar(Smi, constexpr int31): Smi;

extern operator '+' macro IntPtrAdd(intptr, intptr): intptr;
extern operator '+' macro ConstexprIntPtrAdd(
    constexpr intptr, constexpr intptr): constexpr intptr;
extern operator '+' macro ConstexprUintPtrAdd(
    constexpr uintptr, constexpr uintptr): constexpr intptr;
extern operator '-' macro IntPtrSub(intptr, intptr): intptr;
extern operator '*' macro IntPtrMul(intptr, intptr): intptr;
extern operator '/' macro IntPtrDiv(intptr, intptr): intptr;
extern operator '<<' macro WordShl(intptr, intptr): intptr;
extern operator '>>' macro WordSar(intptr, intptr): intptr;
extern operator '&' macro WordAnd(intptr, intptr): intptr;
extern operator '|' macro WordOr(intptr, intptr): intptr;

extern operator '+' macro UintPtrAdd(uintptr, uintptr): uintptr;
extern operator '-' macro UintPtrSub(uintptr, uintptr): uintptr;
extern operator '<<' macro WordShl(uintptr, uintptr): uintptr;
extern operator '>>>' macro WordShr(uintptr, uintptr): uintptr;
extern operator '&' macro WordAnd(uintptr, uintptr): uintptr;
extern operator '|' macro WordOr(uintptr, uintptr): uintptr;

extern operator '+' macro Int32Add(int32, int32): int32;
extern operator '+' macro ConstexprUint32Add(
    constexpr uint32, constexpr int32): constexpr uint32;
extern operator '+' macro ConstexprInt31Add(
    constexpr int31, constexpr int31): constexpr int31;
extern operator '*' macro ConstexprInt31Mul(
    constexpr int31, constexpr int31): constexpr int31;
extern operator '-' macro Int32Sub(int32, int32): int32;
extern operator '*' macro Int32Mul(int32, int32): int32;
extern operator '%' macro Int32Mod(int32, int32): int32;
extern operator '&' macro Word32And(int32, int32): int32;
extern operator '&' macro Word32And(uint32, uint32): uint32;
extern operator '==' macro
ConstexprInt31Equal(constexpr int31, constexpr int31): constexpr bool;
extern operator '>=' macro
ConstexprInt31GreaterThanEqual(
    constexpr int31, constexpr int31): constexpr bool;

extern operator '==' macro Word32Equal(int32, int32): bool;
extern operator '==' macro Word32Equal(uint32, uint32): bool;
extern operator '!=' macro Word32NotEqual(int32, int32): bool;
extern operator '!=' macro Word32NotEqual(uint32, uint32): bool;
extern operator '>>>' macro Word32Shr(uint32, uint32): uint32;
extern operator '<<' macro Word32Shl(int32, int32): int32;
extern operator '<<' macro Word32Shl(uint32, uint32): uint32;
extern operator '|' macro Word32Or(int32, int32): int32;
extern operator '|' macro Word32Or(uint32, uint32): uint32;
extern operator '&' macro Word32And(bool, bool): bool;
extern operator '|' macro Word32Or(bool, bool): bool;
extern operator '==' macro Word32Equal(bool, bool): bool;
extern operator '!=' macro Word32NotEqual(bool, bool): bool;

extern operator '+' macro Float64Add(float64, float64): float64;

extern operator '+' macro NumberAdd(Number, Number): Number;
extern operator '-' macro NumberSub(Number, Number): Number;
extern macro NumberMin(Number, Number): Number;
extern macro NumberMax(Number, Number): Number;
macro Min(x: Number, y: Number): Number {
  return NumberMin(x, y);
}
macro Max(x: Number, y: Number): Number {
  return NumberMax(x, y);
}

extern macro TryIntPtrAdd(intptr, intptr): intptr labels Overflow;
extern macro TryIntPtrSub(intptr, intptr): intptr labels Overflow;
extern macro TryInt32Mul(int32, int32): int32 labels Overflow;

extern operator '<<' macro ConstexprUintPtrShl(
    constexpr uintptr, constexpr int31): constexpr uintptr;
extern operator '>>>' macro ConstexprUintPtrShr(
    constexpr uintptr, constexpr int31): constexpr uintptr;

extern macro SmiMax(Smi, Smi): Smi;
extern macro SmiMin(Smi, Smi): Smi;
extern macro SmiMul(Smi, Smi): Number;
extern macro SmiMod(Smi, Smi): Number;

extern macro IntPtrMax(intptr, intptr): intptr;
extern macro IntPtrMin(intptr, intptr): intptr;

extern operator '!' macro ConstexprBoolNot(constexpr bool): constexpr bool;
extern operator '!' macro Word32BinaryNot(bool): bool;
extern operator '!' macro IsFalse(Boolean): bool;

extern operator '.instanceType' macro LoadInstanceType(HeapObject):
    InstanceType;

extern operator '.length_intptr' macro LoadStringLengthAsWord(String): intptr;
extern operator '.length_uint32' macro LoadStringLengthAsWord32(String): uint32;
extern operator '.length_smi' macro LoadStringLengthAsSmi(String): Smi;

extern builtin StringAdd_CheckNone(implicit context: Context)(
    String, String): String;
operator '+' macro StringAdd(implicit context: Context)(
    a: String, b: String): String {
  return StringAdd_CheckNone(a, b);
}

extern macro TaggedIsSmi(Object): bool;
extern macro TaggedIsNotSmi(Object): bool;
extern macro TaggedIsPositiveSmi(Object): bool;
extern macro IsValidPositiveSmi(intptr): bool;

extern macro HeapObjectToJSDataView(HeapObject): JSDataView
    labels CastError;
extern macro HeapObjectToJSProxy(HeapObject): JSProxy
    labels CastError;
extern macro HeapObjectToJSStringIterator(HeapObject): JSStringIterator
    labels CastError;
extern macro HeapObjectToJSArrayBuffer(HeapObject): JSArrayBuffer
    labels CastError;
extern macro TaggedToHeapObject(Object): HeapObject
    labels CastError;
extern macro TaggedToSmi(Object): Smi
    labels CastError;
extern macro TaggedToPositiveSmi(Object): PositiveSmi
    labels CastError;
extern macro TaggedToDirectString(Object): DirectString
    labels CastError;
extern macro HeapObjectToJSArray(HeapObject): JSArray
    labels CastError;
extern macro HeapObjectToCallable(HeapObject): Callable
    labels CastError;
extern macro HeapObjectToFixedArray(HeapObject): FixedArray
    labels CastError;
extern macro HeapObjectToFixedDoubleArray(HeapObject): FixedDoubleArray
    labels CastError;
extern macro HeapObjectToString(HeapObject): String
    labels CastError;
extern macro HeapObjectToConstructor(HeapObject): Constructor
    labels CastError;
extern macro HeapObjectToHeapNumber(HeapObject): HeapNumber
    labels CastError;
extern macro HeapObjectToSloppyArgumentsElements(HeapObject):
    SloppyArgumentsElements
    labels CastError;
extern macro HeapObjectToRegExpMatchInfo(HeapObject):
    RegExpMatchInfo labels CastError;
extern macro TaggedToNumber(Object): Number
    labels CastError;

macro Cast<A: type>(implicit context: Context)(o: Object): A
    labels CastError {
  return Cast<A>(TaggedToHeapObject(o) otherwise CastError)
      otherwise CastError;
}

Cast<Smi>(o: Object): Smi
    labels CastError {
  return TaggedToSmi(o) otherwise CastError;
}

Cast<PositiveSmi>(o: Object): PositiveSmi
    labels CastError {
  return TaggedToPositiveSmi(o) otherwise CastError;
}

Cast<Number>(o: Object): Number
    labels CastError {
  return TaggedToNumber(o) otherwise CastError;
}

macro Cast<A: type>(o: HeapObject): A
    labels CastError;

Cast<HeapObject>(o: HeapObject): HeapObject
    labels CastError {
  return o;
}

Cast<Null>(o: HeapObject): Null
    labels CastError {
  if (o != Null) goto CastError;
  return %RawDownCast<Null>(o);
}

Cast<FixedArray>(o: HeapObject): FixedArray
    labels CastError {
  return HeapObjectToFixedArray(o) otherwise CastError;
}

Cast<FixedDoubleArray>(o: HeapObject): FixedDoubleArray
    labels CastError {
  return HeapObjectToFixedDoubleArray(o) otherwise CastError;
}

Cast<SloppyArgumentsElements>(o: HeapObject): SloppyArgumentsElements
    labels CastError {
  return HeapObjectToSloppyArgumentsElements(o) otherwise CastError;
}

Cast<JSDataView>(o: HeapObject): JSDataView
    labels CastError {
  return HeapObjectToJSDataView(o) otherwise CastError;
}

Cast<JSProxy>(o: HeapObject): JSProxy
    labels CastError {
  return HeapObjectToJSProxy(o) otherwise CastError;
}

Cast<JSStringIterator>(o: HeapObject): JSStringIterator
    labels CastError {
  return HeapObjectToJSStringIterator(o) otherwise CastError;
}

Cast<JSTypedArray>(o: HeapObject): JSTypedArray
    labels CastError {
  if (IsJSTypedArray(o)) return %RawDownCast<JSTypedArray>(o);
  goto CastError;
}

Cast<JSTypedArray>(implicit context: Context)(o: Object): JSTypedArray
    labels CastError {
  const heapObject = Cast<HeapObject>(o) otherwise CastError;
  return Cast<JSTypedArray>(heapObject) otherwise CastError;
}

Cast<Callable>(o: HeapObject): Callable
    labels CastError {
  return HeapObjectToCallable(o) otherwise CastError;
}

Cast<Undefined | Callable>(o: HeapObject): Undefined | Callable
    labels CastError {
  if (o == Undefined) return Undefined;
  return HeapObjectToCallable(o) otherwise CastError;
}

Cast<JSArray>(o: HeapObject): JSArray
    labels CastError {
  return HeapObjectToJSArray(o) otherwise CastError;
}

Cast<JSArrayBuffer>(o: HeapObject): JSArrayBuffer
    labels CastError {
  return HeapObjectToJSArrayBuffer(o) otherwise CastError;
}

Cast<Context>(o: HeapObject): Context
    labels CastError {
  if (IsContext(o)) return %RawDownCast<Context>(o);
  goto CastError;
}

Cast<JSObject>(o: HeapObject): JSObject
    labels CastError {
  if (IsJSObject(o)) return %RawDownCast<JSObject>(o);
  goto CastError;
}

Cast<NumberDictionary>(o: HeapObject): NumberDictionary
    labels CastError {
  if (IsNumberDictionary(o)) return %RawDownCast<NumberDictionary>(o);
  goto CastError;
}

Cast<String>(o: HeapObject): String
    labels CastError {
  return HeapObjectToString(o) otherwise CastError;
}

Cast<Oddball>(o: HeapObject): Oddball
    labels CastError {
  if (IsOddball(o)) return %RawDownCast<Oddball>(o);
  goto CastError;
}

Cast<Symbol>(o: HeapObject): Symbol
    labels CastError {
  if (IsSymbol(o)) return %RawDownCast<Symbol>(o);
  goto CastError;
}

Cast<DirectString>(o: HeapObject): DirectString
    labels CastError {
  return TaggedToDirectString(o) otherwise CastError;
}

Cast<Constructor>(o: HeapObject): Constructor
    labels CastError {
  return HeapObjectToConstructor(o) otherwise CastError;
}

Cast<HeapNumber>(o: HeapObject): HeapNumber
    labels CastError {
  if (IsHeapNumber(o)) return %RawDownCast<HeapNumber>(o);
  goto CastError;
}

Cast<JSRegExp>(o: HeapObject): JSRegExp
    labels CastError {
  if (IsJSRegExp(o)) return %RawDownCast<JSRegExp>(o);
  goto CastError;
}

Cast<Map>(implicit context: Context)(o: HeapObject): Map
    labels CastError {
  if (IsMap(o)) return %RawDownCast<Map>(o);
  goto CastError;
}

Cast<JSValue>(o: HeapObject): JSValue
    labels CastError {
  if (IsJSValue(o)) return %RawDownCast<JSValue>(o);
  goto CastError;
}

Cast<JSArgumentsObjectWithLength>(implicit context: Context)(o: HeapObject):
    JSArgumentsObjectWithLength
    labels CastError {
  const map: Map = o.map;
  try {
    if (IsFastAliasedArgumentsMap(map)) goto True;
    if (IsSloppyArgumentsMap(map)) goto True;
    if (IsStrictArgumentsMap(map)) goto True;
    if (IsSlowAliasedArgumentsMap(map)) goto True;
    goto CastError;
  }
  label True {
    return %RawDownCast<JSArgumentsObjectWithLength>(o);
  }
}

Cast<FastJSRegExp>(implicit context: Context)(o: HeapObject): FastJSRegExp
    labels CastError {
  if (regexp::BranchIfFastRegExp(o)) return %RawDownCast<FastJSRegExp>(o);
  goto CastError;
}

Cast<FastJSArray>(implicit context: Context)(o: HeapObject): FastJSArray
    labels CastError {
  const map: Map = o.map;
  if (!IsJSArrayMap(map)) goto CastError;

  // Bailout if receiver has slow elements.
  const elementsKind: ElementsKind = LoadMapElementsKind(map);
  if (!IsFastElementsKind(elementsKind)) goto CastError;

  // Verify that our prototype is the initial array prototype.
  if (!IsPrototypeInitialArrayPrototype(map)) goto CastError;

  if (IsNoElementsProtectorCellInvalid()) goto CastError;
  return %RawDownCast<FastJSArray>(o);
}

Cast<FastJSArrayForRead>(implicit context: Context)(o: HeapObject):
    FastJSArrayForRead
    labels CastError {
  const map: Map = o.map;
  if (!IsJSArrayMap(map)) goto CastError;

  // Bailout if receiver has slow elements.
  const elementsKind: ElementsKind = LoadMapElementsKind(map);
  if (!IsElementsKindLessThanOrEqual(elementsKind, LAST_FROZEN_ELEMENTS_KIND))
    goto CastError;

  // Verify that our prototype is the initial array prototype.
  if (!IsPrototypeInitialArrayPrototype(map)) goto CastError;

  if (IsNoElementsProtectorCellInvalid()) goto CastError;
  return %RawDownCast<FastJSArrayForRead>(o);
}

Cast<FastJSArrayForCopy>(implicit context: Context)(o: HeapObject):
    FastJSArrayForCopy
    labels CastError {
  if (IsArraySpeciesProtectorCellInvalid()) goto CastError;
  const a: FastJSArray = Cast<FastJSArray>(o) otherwise CastError;
  return %RawDownCast<FastJSArrayForCopy>(o);
}

Cast<FastJSArrayWithNoCustomIteration>(implicit context: Context)(
    o: HeapObject): FastJSArrayWithNoCustomIteration
    labels CastError {
  if (IsArrayIteratorProtectorCellInvalid()) goto CastError;
  const a: FastJSArray = Cast<FastJSArray>(o) otherwise CastError;
  return %RawDownCast<FastJSArrayWithNoCustomIteration>(o);
}

Cast<FastJSArrayForReadWithNoCustomIteration>(implicit context: Context)(
    o: HeapObject): FastJSArrayForReadWithNoCustomIteration
    labels CastError {
  if (IsArrayIteratorProtectorCellInvalid()) goto CastError;
  const a: FastJSArrayForRead = Cast<FastJSArrayForRead>(o) otherwise CastError;
  return %RawDownCast<FastJSArrayForReadWithNoCustomIteration>(o);
}

Cast<JSReceiver>(implicit context: Context)(o: HeapObject): JSReceiver
    labels CastError {
  if (IsJSReceiver(o)) return %RawDownCast<JSReceiver>(o);
  goto CastError;
}

Cast<JSFunction>(implicit context: Context)(o: HeapObject): JSFunction
    labels CastError {
  if (IsJSFunction(o)) return %RawDownCast<JSFunction>(o);
  goto CastError;
}

extern macro IsDebugInfo(HeapObject): bool;
Cast<DebugInfo>(implicit context: Context)(o: HeapObject): DebugInfo
    labels CastError {
  if (IsDebugInfo(o)) return %RawDownCast<DebugInfo>(o);
  goto CastError;
}

extern macro IsCoverageInfo(HeapObject): bool;
Cast<CoverageInfo>(implicit context: Context)(o: HeapObject): CoverageInfo
    labels CastError {
  // TODO(jgruber): Assign an instance type.
  if (IsFixedArray(o)) return %RawDownCast<CoverageInfo>(o);
  goto CastError;
}

extern macro AllocateHeapNumberWithValue(float64): HeapNumber;
extern macro ChangeInt32ToTagged(int32): Number;
extern macro ChangeUint32ToTagged(uint32): Number;
extern macro ChangeUintPtrToFloat64(uintptr): float64;
extern macro ChangeUintPtrToTagged(uintptr): Number;
extern macro Unsigned(int32): uint32;
extern macro Unsigned(int16): uint16;
extern macro Unsigned(int8): uint8;
extern macro Unsigned(intptr): uintptr;
extern macro Unsigned(RawPtr): uintptr;
extern macro Signed(uint32): int32;
extern macro Signed(uint16): int16;
extern macro Signed(uint8): int8;
extern macro Signed(uintptr): intptr;
extern macro Signed(RawPtr): intptr;
extern macro TruncateIntPtrToInt32(intptr): int32;
extern macro SmiTag(intptr): Smi;
extern macro SmiFromInt32(int32): Smi;
extern macro SmiUntag(Smi): intptr;
extern macro SmiToInt32(Smi): int32;
extern macro RoundIntPtrToFloat64(intptr): float64;
extern macro ChangeFloat32ToFloat64(float32): float64;
extern macro ChangeNumberToFloat64(Number): float64;
extern macro ChangeFloat64ToUintPtr(float64): uintptr;
extern macro ChangeInt32ToIntPtr(int32): intptr;   // Sign-extends.
extern macro ChangeUint32ToWord(uint32): uintptr;  // Doesn't sign-extend.
extern macro LoadNativeContext(Context): NativeContext;
extern macro TruncateFloat64ToFloat32(float64): float32;
extern macro TruncateHeapNumberValueToWord32(Number): int32;
extern macro LoadJSArrayElementsMap(constexpr ElementsKind, Context): Map;
extern macro LoadJSArrayElementsMap(ElementsKind, Context): Map;
extern macro ChangeNonnegativeNumberToUintPtr(Number): uintptr;
extern macro TryNumberToUintPtr(Number): uintptr labels IfNegative;
extern macro NumberConstant(constexpr float64): Number;
extern macro NumberConstant(constexpr int32): Number;
extern macro NumberConstant(constexpr uint32): Number;
extern macro IntPtrConstant(constexpr int31): intptr;
extern macro IntPtrConstant(constexpr int32): intptr;
extern macro Int32Constant(constexpr int31): int31;
extern macro Int32Constant(constexpr int32): int32;
extern macro Float64Constant(constexpr int31): float64;
extern macro Float64Constant(constexpr float64): float64;
extern macro SmiConstant(constexpr int31): Smi;
extern macro SmiConstant(constexpr Smi): Smi;
extern macro SmiConstant(constexpr MessageTemplate): Smi;
extern macro BoolConstant(constexpr bool): bool;
extern macro StringConstant(constexpr string): String;
extern macro LanguageModeConstant(constexpr LanguageMode): LanguageMode;
extern macro Int32Constant(constexpr ElementsKind): ElementsKind;
extern macro IntPtrConstant(constexpr NativeContextSlot): NativeContextSlot;
extern macro IntPtrConstant(constexpr ContextSlot): ContextSlot;
extern macro IntPtrConstant(constexpr intptr): intptr;
extern macro SingleCharacterStringConstant(constexpr string): String;

extern macro BitcastWordToTaggedSigned(intptr): Smi;
extern macro BitcastWordToTaggedSigned(uintptr): Smi;
extern macro BitcastWordToTagged(intptr): Object;
extern macro BitcastWordToTagged(uintptr): Object;
extern macro BitcastTaggedToWord(Tagged): intptr;

intrinsic %FromConstexpr<To: type, From: type>(b: From): To;
macro FromConstexpr<To: type, From: type>(o: From): To;
FromConstexpr<int31, constexpr int31>(i: constexpr int31): int31 {
  return %FromConstexpr<int31>(i);
}
FromConstexpr<int32, constexpr int31>(i: constexpr int31): int32 {
  return %FromConstexpr<int32>(i);
}
FromConstexpr<int32, constexpr int32>(i: constexpr int32): int32 {
  return %FromConstexpr<int32>(i);
}
FromConstexpr<intptr, constexpr int31>(i: constexpr int31): intptr {
  return %FromConstexpr<intptr>(i);
}
FromConstexpr<intptr, constexpr int32>(i: constexpr int32): intptr {
  return %FromConstexpr<intptr>(i);
}
FromConstexpr<intptr, constexpr intptr>(i: constexpr intptr): intptr {
  return %FromConstexpr<intptr>(i);
}
FromConstexpr<uintptr, constexpr uintptr>(i: constexpr uintptr): uintptr {
  return %FromConstexpr<uintptr>(i);
}
FromConstexpr<Smi, constexpr int31>(i: constexpr int31): Smi {
  return %FromConstexpr<Smi>(i);
}
FromConstexpr<PositiveSmi, constexpr int31>(i: constexpr int31): PositiveSmi {
  assert(i >= 0);
  return %FromConstexpr<PositiveSmi>(i);
}
FromConstexpr<String, constexpr string>(s: constexpr string): String {
  return %FromConstexpr<String>(s);
}
FromConstexpr<Number, constexpr uint32>(i: constexpr uint32): Number {
  return %FromConstexpr<Number>(i);
}
FromConstexpr<Number, constexpr int32>(i: constexpr int32): Number {
  return %FromConstexpr<Number>(i);
}
FromConstexpr<Number, constexpr float64>(f: constexpr float64): Number {
  return %FromConstexpr<Number>(f);
}
FromConstexpr<Number, constexpr int31>(i: constexpr int31): Number {
  return %FromConstexpr<Number>(i);
}
FromConstexpr<Number, constexpr Smi>(s: constexpr Smi): Number {
  return SmiConstant(s);
}
FromConstexpr<Smi, constexpr Smi>(s: constexpr Smi): Smi {
  return SmiConstant(s);
}
FromConstexpr<uint32, constexpr int31>(i: constexpr int31): uint32 {
  return Unsigned(Int32Constant(i));
}
FromConstexpr<uintptr, constexpr int31>(i: constexpr int31): uintptr {
  return ChangeUint32ToWord(i);
}
FromConstexpr<float64, constexpr int31>(i: constexpr int31): float64 {
  return Float64Constant(i);
}
FromConstexpr<float64, constexpr float64>(i: constexpr float64): float64 {
  return Float64Constant(i);
}
FromConstexpr<bool, constexpr bool>(b: constexpr bool): bool {
  return BoolConstant(b);
}
FromConstexpr<LanguageMode, constexpr LanguageMode>(m: constexpr LanguageMode):
    LanguageMode {
  return %RawDownCast<LanguageMode>(%FromConstexpr<Smi>(m));
}
FromConstexpr<ElementsKind, constexpr ElementsKind>(e: constexpr ElementsKind):
    ElementsKind {
  return Int32Constant(e);
}
FromConstexpr<Object, constexpr string>(s: constexpr string): Object {
  return StringConstant(s);
}
FromConstexpr<NativeContextSlot, constexpr NativeContextSlot>(
    c: constexpr NativeContextSlot): NativeContextSlot {
  return IntPtrConstant(c);
}
FromConstexpr<ContextSlot, constexpr ContextSlot>(c: constexpr ContextSlot):
    ContextSlot {
  return IntPtrConstant(c);
}

macro Convert<To: type, From: type>(i: From): To {
  return i;
}

macro Convert<To: type, From: type>(i: From): To labels Overflow {
  return i;
}

extern macro ConvertElementsKindToInt(ElementsKind): int32;
Convert<int32, ElementsKind>(elementsKind: ElementsKind): int32 {
  return ConvertElementsKindToInt(elementsKind);
}
Convert<Number, int32>(i: int32): Number {
  return ChangeInt32ToTagged(i);
}
Convert<intptr, int32>(i: int32): intptr {
  return ChangeInt32ToIntPtr(i);
}
Convert<Smi, int32>(i: int32): Smi {
  return SmiFromInt32(i);
}
Convert<Number, uint32>(ui: uint32): Number {
  return ChangeUint32ToTagged(ui);
}
Convert<Smi, uint32>(ui: uint32): Smi {
  return SmiFromInt32(Signed(ui));
}
Convert<uintptr, uint32>(ui: uint32): uintptr {
  return ChangeUint32ToWord(ui);
}
Convert<int32, uint8>(i: uint8): int32 {
  return Signed(Convert<uint32>(i));
}
Convert<int32, uint16>(i: uint16): int32 {
  return Signed(Convert<uint32>(i));
}
Convert<int32, uint31>(i: uint31): int32 {
  return Signed(Convert<uint32>(i));
}
Convert<int32, intptr>(i: intptr): int32 {
  return TruncateIntPtrToInt32(i);
}
Convert<Smi, intptr>(i: intptr): Smi {
  return SmiTag(i);
}
Convert<uint32, uintptr>(ui: uintptr): uint32 {
  return Unsigned(TruncateIntPtrToInt32(Signed(ui)));
}
Convert<intptr, Smi>(s: Smi): intptr {
  return SmiUntag(s);
}
Convert<uintptr, PositiveSmi>(ps: PositiveSmi): uintptr {
  return Unsigned(SmiUntag(ps));
}
Convert<intptr, uintptr>(ui: uintptr): intptr {
  const i = Signed(ui);
  assert(i >= 0);
  return i;
}
Convert<PositiveSmi, intptr>(i: intptr): PositiveSmi {
  assert(IsValidPositiveSmi(i));
  return %RawDownCast<PositiveSmi>(SmiTag(i));
}
Convert<PositiveSmi, uintptr>(ui: uintptr): PositiveSmi labels IfOverflow {
  if (ui > kSmiMaxValue) deferred {
      goto IfOverflow;
    }
  return %RawDownCast<PositiveSmi>(SmiTag(Signed(ui)));
}
Convert<PositiveSmi, intptr>(i: intptr): PositiveSmi labels IfOverflow {
  if (IsValidPositiveSmi(i)) {
    return %RawDownCast<PositiveSmi>(SmiTag(i));
  } else
    deferred {
      goto IfOverflow;
    }
}
Convert<int32, Smi>(s: Smi): int32 {
  return SmiToInt32(s);
}
Convert<float64, HeapNumber>(h: HeapNumber): float64 {
  return LoadHeapNumberValue(h);
}
Convert<float64, Number>(n: Number): float64 {
  return ChangeNumberToFloat64(n);
}
Convert<uintptr, Number>(n: Number): uintptr {
  return ChangeNonnegativeNumberToUintPtr(n);
}
Convert<float64, float32>(f: float32): float64 {
  return ChangeFloat32ToFloat64(f);
}
Convert<float32, float64>(f: float64): float32 {
  return TruncateFloat64ToFloat32(f);
}
Convert<float32, Number>(n: Number): float32 {
  return Convert<float32>(ChangeNumberToFloat64(n));
}
Convert<Number, float64>(d: float64): Number {
  return AllocateHeapNumberWithValue(d);
}
Convert<float64, uintptr>(ui: uintptr): float64 {
  return ChangeUintPtrToFloat64(ui);
}
Convert<Number, uintptr>(ui: uintptr): Number {
  return ChangeUintPtrToTagged(ui);
}
Convert<uintptr, float64>(d: float64): uintptr {
  return ChangeFloat64ToUintPtr(d);
}
Convert<uintptr, intptr>(i: intptr): uintptr {
  return Unsigned(i);
}
Convert<uintptr, RawPtr>(r: RawPtr): uintptr {
  return Unsigned(r);
}
Convert<intptr, RawPtr>(r: RawPtr): intptr {
  return Signed(r);
}
Convert<bint, int32>(v: int32): bint {
  return IntPtrToBInt(Convert<intptr>(v));
}
extern macro IntPtrToBInt(intptr): bint;
Convert<bint, intptr>(v: intptr): bint {
  return IntPtrToBInt(v);
}
extern macro SmiToBInt(Smi): bint;
Convert<bint, Smi>(v: Smi): bint {
  return SmiToBInt(v);
}

macro BranchIf<A: type, B: type>(implicit context: Context)(o: B): never
    labels True, False {
  Cast<A>(o) otherwise False;
  goto True;
}

macro BranchIfNot<A: type, B: type>(implicit context: Context)(o: B): never
    labels True, False {
  Cast<A>(o) otherwise True;
  goto False;
}

macro Is<A: type, B: type>(implicit context: Context)(o: B): bool {
  return (BranchIf<A, B>(o)) ? true : false;
}

macro UnsafeCast<A: type>(implicit context: Context)(o: Object): A {
  assert(Is<A>(o));
  return %RawDownCast<A>(o);
}

UnsafeCast<Object>(o: Object): Object {
  return o;
}

const kFixedArrayMap: Map =
    %RawDownCast<Map>(LoadRoot(kFixedArrayMapRootIndex));
const kCOWMap: Map = %RawDownCast<Map>(LoadRoot(kFixedCOWArrayMapRootIndex));
const kEmptyByteArray: ByteArray =
    %RawDownCast<ByteArray>(LoadRoot(kEmptyByteArrayRootIndex));
const kEmptyFixedArray: FixedArray =
    %RawDownCast<FixedArray>(LoadRoot(kEmptyFixedArrayRootIndex));

extern macro IsPrototypeInitialArrayPrototype(implicit context: Context)(Map):
    bool;
extern macro IsNoElementsProtectorCellInvalid(): bool;
extern macro IsArrayIteratorProtectorCellInvalid(): bool;
extern macro IsArraySpeciesProtectorCellInvalid(): bool;
extern macro IsTypedArraySpeciesProtectorCellInvalid(): bool;
extern macro IsPromiseSpeciesProtectorCellInvalid(): bool;
extern macro IsMockArrayBufferAllocatorFlag(): bool;
extern macro IsPrototypeTypedArrayPrototype(implicit context: Context)(Map):
    bool;

extern operator '.data_ptr' macro LoadJSTypedArrayBackingStore(JSTypedArray):
    RawPtr;

extern operator '.elements_kind' macro LoadMapElementsKind(Map): ElementsKind;
extern operator '.elements_kind' macro LoadElementsKind(JSTypedArray):
    ElementsKind;

extern operator '.length' macro LoadFastJSArrayLength(FastJSArray): Smi;
operator '.length=' macro StoreFastJSArrayLength(
    array: FastJSArray, length: Smi) {
  const array: JSArray = array;
  array.length = length;
}

extern operator '.objects[]' macro LoadFixedArrayElement(
    FixedArray, intptr): Object;
extern operator '.objects[]' macro LoadFixedArrayElement(
    FixedArray, Smi): Object;
extern operator '.objects[]' macro LoadFixedArrayElement(
    FixedArray, constexpr int31): Object;
extern operator '.objects[]=' macro StoreFixedArrayElement(
    FixedArray, intptr, Smi): void;
extern operator '.objects[]=' macro StoreFixedArrayElement(
    FixedArray, Smi, Smi): void;
extern operator '.objects[]=' macro StoreFixedArrayElement(
    FixedArray, intptr, HeapObject): void;
extern operator '.objects[]=' macro StoreFixedArrayElement(
    FixedArray, intptr, Object): void;
extern operator '.objects[]=' macro StoreFixedArrayElement(
    FixedArray, constexpr int31, Smi): void;
extern operator '.objects[]=' macro StoreFixedArrayElement(
    FixedArray, constexpr int31, HeapObject): void;
extern operator '.objects[]=' macro StoreFixedArrayElement(
    FixedArray, Smi, Object): void;
extern macro StoreFixedArrayElement(
    FixedArray, Smi, Object, constexpr WriteBarrierMode): void;
extern macro StoreFixedArrayElement(
    FixedArray, Smi, Smi, constexpr WriteBarrierMode): void;
extern macro StoreFixedArrayElement(
    FixedArray, constexpr int31, Object, constexpr WriteBarrierMode): void;
extern macro StoreFixedArrayElement(
    FixedArray, constexpr int31, Smi, constexpr WriteBarrierMode): void;
extern macro StoreFixedArrayElement(
    FixedArray, intptr, Object, constexpr WriteBarrierMode): void;
extern macro StoreFixedArrayElement(
    FixedArray, intptr, Smi, constexpr WriteBarrierMode): void;
extern operator '.floats[]=' macro StoreFixedDoubleArrayElement(
    FixedDoubleArray, intptr, float64): void;
extern operator '.floats[]=' macro StoreFixedDoubleArrayElementSmi(
    FixedDoubleArray, Smi, float64): void;
operator '.floats[]=' macro StoreFixedDoubleArrayElementSmi(
    a: FixedDoubleArray, i: Smi, n: Number): void {
  StoreFixedDoubleArrayElementSmi(a, i, Convert<float64>(n));
}
operator '[]=' macro StoreFixedDoubleArrayDirect(
    a: FixedDoubleArray, i: Smi, v: Number) {
  a.floats[i] = Convert<float64>(v);
}
operator '[]=' macro StoreFixedArrayDirect(a: FixedArray, i: Smi, v: Object) {
  a.objects[i] = v;
}

extern macro GetNumberDictionaryNumberOfElements(NumberDictionary): Smi;
extern macro GetIteratorMethod(implicit context: Context)(HeapObject): Object
    labels IfIteratorUndefined;

extern macro LoadConstructorOrBackPointer(Map): Object;

extern macro BasicLoadNumberDictionaryElement(NumberDictionary, intptr): Object
    labels NotData, IfHole;
extern macro BasicStoreNumberDictionaryElement(NumberDictionary, intptr, Object)
    labels NotData, IfHole, ReadOnly;

extern macro IsFastElementsKind(ElementsKind): bool;
extern macro IsDoubleElementsKind(ElementsKind): bool;
extern macro IsFastSmiOrTaggedElementsKind(ElementsKind): bool;
extern macro IsFastSmiElementsKind(ElementsKind): bool;
extern macro IsHoleyFastElementsKind(ElementsKind): bool;

macro FastHoleyElementsKind(kind: ElementsKind): ElementsKind {
  if (kind == PACKED_SMI_ELEMENTS) {
    return HOLEY_SMI_ELEMENTS;
  } else if (kind == PACKED_DOUBLE_ELEMENTS) {
    return HOLEY_DOUBLE_ELEMENTS;
  }
  assert(kind == PACKED_ELEMENTS);
  return HOLEY_ELEMENTS;
}

macro AllowDoubleElements(kind: ElementsKind): ElementsKind {
  if (kind == PACKED_SMI_ELEMENTS) {
    return PACKED_DOUBLE_ELEMENTS;
  } else if (kind == HOLEY_SMI_ELEMENTS) {
    return HOLEY_DOUBLE_ELEMENTS;
  }
  return kind;
}

macro AllowNonNumberElements(kind: ElementsKind): ElementsKind {
  if (kind == PACKED_SMI_ELEMENTS) {
    return PACKED_ELEMENTS;
  } else if (kind == HOLEY_SMI_ELEMENTS) {
    return HOLEY_ELEMENTS;
  } else if (kind == PACKED_DOUBLE_ELEMENTS) {
    return PACKED_ELEMENTS;
  } else if (kind == HOLEY_DOUBLE_ELEMENTS) {
    return HOLEY_ELEMENTS;
  }
  return kind;
}

extern macro AllocateZeroedFixedArray(intptr): FixedArray;
extern macro AllocateZeroedFixedDoubleArray(intptr): FixedDoubleArray;
extern macro CalculateNewElementsCapacity(Smi): Smi;
extern macro CalculateNewElementsCapacity(intptr): intptr;

extern macro AllocateFixedArrayWithHoles(
    intptr, constexpr AllocationFlags): FixedArray;
extern macro AllocateFixedDoubleArrayWithHoles(
    intptr, constexpr AllocationFlags): FixedDoubleArray;
extern macro CopyFixedArrayElements(
    constexpr ElementsKind, FixedArray, constexpr ElementsKind, FixedArray,
    intptr, intptr, intptr): void;
extern macro CopyFixedArrayElements(
    constexpr ElementsKind, FixedArray, constexpr ElementsKind, FixedArray, Smi,
    Smi, Smi): void;

extern macro AllocateJSArray(
    constexpr ElementsKind, Map, intptr, Smi,
    constexpr AllocationFlags): JSArray;
extern macro AllocateJSArray(constexpr ElementsKind, Map, intptr, Smi): JSArray;
extern macro AllocateJSArray(constexpr ElementsKind, Map, Smi, Smi): JSArray;
extern macro AllocateJSArray(Map, FixedArrayBase, Smi): JSArray;
extern macro AllocateJSObjectFromMap(Map): JSObject;
extern macro AllocateJSObjectFromMap(
    Map, FixedArray, FixedArray, constexpr AllocationFlags,
    constexpr SlackTrackingMode): JSObject;

extern macro LoadDoubleWithHoleCheck(FixedDoubleArray, Smi): float64
    labels IfHole;
extern macro LoadDoubleWithHoleCheck(FixedDoubleArray, intptr): float64
    labels IfHole;
extern macro StoreFixedDoubleArrayHoleSmi(FixedDoubleArray, Smi): void;

macro GetObjectFunction(implicit context: Context)(): JSFunction {
  return UnsafeCast<JSFunction>(
      LoadNativeContext(context)[OBJECT_FUNCTION_INDEX]);
}
macro GetArrayBufferFunction(implicit context: Context)(): Constructor {
  return UnsafeCast<Constructor>(
      LoadNativeContext(context)[ARRAY_BUFFER_FUN_INDEX]);
}
macro GetArrayBufferNoInitFunction(implicit context: Context)(): JSFunction {
  return UnsafeCast<JSFunction>(
      LoadNativeContext(context)[ARRAY_BUFFER_NOINIT_FUN_INDEX]);
}
macro GetFastPackedElementsJSArrayMap(implicit context: Context)(): Map {
  return UnsafeCast<Map>(
      LoadNativeContext(context)[JS_ARRAY_PACKED_ELEMENTS_MAP_INDEX]);
}
macro GetFastPackedSmiElementsJSArrayMap(implicit context: Context)(): Map {
  return UnsafeCast<Map>(
      LoadNativeContext(context)[JS_ARRAY_PACKED_SMI_ELEMENTS_MAP_INDEX]);
}
macro GetProxyRevocableResultMap(implicit context: Context)(): Map {
  return UnsafeCast<Map>(
      LoadNativeContext(context)[PROXY_REVOCABLE_RESULT_MAP_INDEX]);
}
macro GetIteratorResultMap(implicit context: Context)(): Map {
  return UnsafeCast<Map>(LoadNativeContext(context)[ITERATOR_RESULT_MAP_INDEX]);
}
macro GetInitialStringIteratorMap(implicit context: Context)(): Map {
  return UnsafeCast<Map>(
      LoadNativeContext(context)[INITIAL_STRING_ITERATOR_MAP_INDEX]);
}
macro GetReflectApply(implicit context: Context)(): Callable {
  return UnsafeCast<Callable>(LoadNativeContext(context)[REFLECT_APPLY_INDEX]);
}
macro GetRegExpLastMatchInfo(implicit context: Context)(): RegExpMatchInfo {
  return %RawDownCast<RegExpMatchInfo>(
      LoadNativeContext(context)[REGEXP_LAST_MATCH_INFO_INDEX]);
}

extern transitioning macro Call(Context, Callable, Object): Object;
extern transitioning macro Call(Context, Callable, Object, Object): Object;
extern transitioning macro Call(
    Context, Callable, Object, Object, Object): Object;
extern transitioning macro Call(
    Context, Callable, Object, Object, Object, Object): Object;
extern transitioning macro Call(
    Context, Callable, Object, Object, Object, Object, Object): Object;
extern transitioning macro Call(
    Context, Callable, Object, Object, Object, Object, Object, Object): Object;

extern builtin CloneFastJSArray(Context, FastJSArrayForCopy): JSArray;
extern macro ExtractFixedArray(FixedArrayBase, Smi, Smi, Smi): FixedArrayBase;
extern macro ExtractFixedArray(
    FixedArrayBase, Smi, Smi, Smi,
    constexpr ExtractFixedArrayFlags): FixedArrayBase;

extern macro ExtractFixedArray(
    FixedArray, intptr, intptr, intptr,
    constexpr ExtractFixedArrayFlags): FixedArray;

extern builtin ExtractFastJSArray(Context, JSArray, Smi, Smi): JSArray;

extern macro MoveElements(
    constexpr ElementsKind, FixedArrayBase, intptr, intptr, intptr): void;
macro TorqueMoveElementsSmi(
    elements: FixedArray, dstIndex: intptr, srcIndex: intptr,
    count: intptr): void {
  MoveElements(HOLEY_SMI_ELEMENTS, elements, dstIndex, srcIndex, count);
}
macro TorqueMoveElements(
    elements: FixedArray, dstIndex: intptr, srcIndex: intptr,
    count: intptr): void {
  MoveElements(HOLEY_ELEMENTS, elements, dstIndex, srcIndex, count);
}
macro TorqueMoveElements(
    elements: FixedDoubleArray, dstIndex: intptr, srcIndex: intptr,
    count: intptr): void {
  MoveElements(HOLEY_DOUBLE_ELEMENTS, elements, dstIndex, srcIndex, count);
}

extern macro CopyElements(
    constexpr ElementsKind, FixedArrayBase, intptr, FixedArrayBase, intptr,
    intptr): void;
macro TorqueCopyElements(
    dstElements: FixedArray, dstIndex: intptr, srcElements: FixedArray,
    srcIndex: intptr, count: intptr): void {
  CopyElements(
      HOLEY_ELEMENTS, dstElements, dstIndex, srcElements, srcIndex, count);
}
macro TorqueCopyElements(
    dstElements: FixedDoubleArray, dstIndex: intptr,
    srcElements: FixedDoubleArray, srcIndex: intptr, count: intptr): void {
  CopyElements(
      HOLEY_DOUBLE_ELEMENTS, dstElements, dstIndex, srcElements, srcIndex,
      count);
}

macro LoadElementNoHole<T: type>(a: JSArray, index: Smi): Object
    labels IfHole;

LoadElementNoHole<FixedArray>(implicit context: Context)(
    a: JSArray, index: Smi): Object
    labels IfHole {
  try {
    let elements: FixedArray =
        Cast<FixedArray>(a.elements) otherwise Unexpected;
    let e: Object = elements.objects[index];
    if (e == Hole) {
      goto IfHole;
    }
    return e;
  }
  label Unexpected {
    unreachable;
  }
}

LoadElementNoHole<FixedDoubleArray>(implicit context: Context)(
    a: JSArray, index: Smi): Object
    labels IfHole {
  try {
    let elements: FixedDoubleArray =
        Cast<FixedDoubleArray>(a.elements) otherwise Unexpected;
    let e: float64 = LoadDoubleWithHoleCheck(elements, index) otherwise IfHole;
    return AllocateHeapNumberWithValue(e);
  }
  label Unexpected {
    unreachable;
  }
}

struct FastJSArrayWitness {
  Get(): FastJSArray {
    return this.unstable;
  }

  Recheck() labels CastError {
    if (this.stable.map != this.map) goto CastError;
    // We don't need to check elements kind or whether the prototype
    // has changed away from the default JSArray prototype, because
    // if the map remains the same then those properties hold.
    //
    // However, we have to make sure there are no elements in the
    // prototype chain.
    if (IsNoElementsProtectorCellInvalid()) goto CastError;
    this.unstable = %RawDownCast<FastJSArray>(this.stable);
  }

  LoadElementNoHole(implicit context: Context)(k: Smi): Object
      labels FoundHole {
    if (this.hasDoubles) {
      return LoadElementNoHole<FixedDoubleArray>(this.unstable, k)
          otherwise FoundHole;
    } else {
      return LoadElementNoHole<FixedArray>(this.unstable, k)
          otherwise FoundHole;
    }
  }

  StoreHole(k: Smi) {
    if (this.hasDoubles) {
      const elements = Cast<FixedDoubleArray>(this.unstable.elements)
          otherwise unreachable;
      StoreFixedDoubleArrayHoleSmi(elements, k);
    } else {
      const elements = Cast<FixedArray>(this.unstable.elements)
          otherwise unreachable;
      StoreFixedArrayElement(elements, k, Hole);
    }
  }

  LoadElementOrUndefined(implicit context: Context)(k: Smi): Object {
    try {
      return this.LoadElementNoHole(k) otherwise FoundHole;
    }
    label FoundHole {
      return Undefined;
    }
  }

  EnsureArrayPushable(implicit context: Context)() labels Failed {
    EnsureArrayPushable(this.map) otherwise Failed;
    array::EnsureWriteableFastElements(this.unstable);
    this.arrayIsPushable = true;
  }

  ChangeLength(newLength: Smi) {
    assert(this.arrayIsPushable);
    this.unstable.length = newLength;
  }

  Push(value: Object) labels Failed {
    assert(this.arrayIsPushable);
    if (this.hasDoubles) {
      BuildAppendJSArray(HOLEY_DOUBLE_ELEMENTS, this.unstable, value)
          otherwise Failed;
    } else if (this.hasSmis) {
      BuildAppendJSArray(HOLEY_SMI_ELEMENTS, this.unstable, value)
          otherwise Failed;
    } else {
      assert(
          this.map.elements_kind == HOLEY_ELEMENTS ||
          this.map.elements_kind == PACKED_ELEMENTS);
      BuildAppendJSArray(HOLEY_ELEMENTS, this.unstable, value)
          otherwise Failed;
    }
  }

  MoveElements(dst: intptr, src: intptr, length: intptr) {
    assert(this.arrayIsPushable);
    if (this.hasDoubles) {
      let elements: FixedDoubleArray =
          Cast<FixedDoubleArray>(this.unstable.elements)
          otherwise unreachable;
      TorqueMoveElements(elements, dst, src, length);
    } else {
      let elements: FixedArray = Cast<FixedArray>(this.unstable.elements)
          otherwise unreachable;
      if (this.hasSmis) {
        TorqueMoveElementsSmi(elements, dst, src, length);
      } else {
        TorqueMoveElements(elements, dst, src, length);
      }
    }
  }

  const stable: JSArray;
  unstable: FastJSArray;
  const map: Map;
  const hasDoubles: bool;
  const hasSmis: bool;
  arrayIsPushable: bool;
}

macro NewFastJSArrayWitness(array: FastJSArray): FastJSArrayWitness {
  let kind = array.map.elements_kind;
  return FastJSArrayWitness{
    stable: array,
    unstable: array,
    map: array.map,
    hasDoubles: !IsElementsKindLessThanOrEqual(kind, HOLEY_ELEMENTS),
    hasSmis: IsElementsKindLessThanOrEqual(kind, HOLEY_SMI_ELEMENTS),
    arrayIsPushable: false
  };
}

extern macro TransitionElementsKind(
    JSObject, Map, constexpr ElementsKind,
    constexpr ElementsKind): void labels Bailout;
extern macro PerformStackCheck(implicit context: Context)(): void;

extern macro IsCallable(HeapObject): bool;
extern macro IsConstructor(HeapObject): bool;
extern macro IsJSArray(HeapObject): bool;
extern macro IsJSProxy(HeapObject): bool;
extern macro IsJSRegExp(HeapObject): bool;
extern macro IsMap(HeapObject): bool;
extern macro IsJSFunction(HeapObject): bool;
extern macro IsJSObject(HeapObject): bool;
extern macro IsJSTypedArray(HeapObject): bool;
extern macro IsNumberDictionary(HeapObject): bool;
extern macro IsContext(HeapObject): bool;
extern macro IsJSReceiver(HeapObject): bool;
extern macro TaggedIsCallable(Object): bool;
extern macro IsDetachedBuffer(JSArrayBuffer): bool;
extern macro IsHeapNumber(HeapObject): bool;
extern macro IsFixedArray(HeapObject): bool;
extern macro IsName(HeapObject): bool;
extern macro IsPrivateSymbol(HeapObject): bool;
extern macro IsNumber(Object): bool;
extern macro IsNumberNormalized(Number): bool;
extern macro IsOddball(HeapObject): bool;
extern macro IsSymbol(HeapObject): bool;
extern macro IsJSArrayMap(Map): bool;
extern macro IsExtensibleMap(Map): bool;
extern macro IsJSValue(HeapObject): bool;
extern macro IsCustomElementsReceiverInstanceType(int32): bool;
extern macro Typeof(Object): Object;

// Return true iff number is NaN.
macro NumberIsNaN(number: Number): bool {
  typeswitch (number) {
    case (Smi): {
      return false;
    }
    case (hn: HeapNumber): {
      let value: float64 = Convert<float64>(hn);
      return value != value;
    }
  }
}

extern macro GotoIfForceSlowPath() labels Taken;
extern macro BranchIfToBooleanIsTrue(Object): never
    labels Taken, NotTaken;

macro ToBoolean(obj: Object): bool {
  if (BranchIfToBooleanIsTrue(obj)) {
    return true;
  } else {
    return false;
  }
}

transitioning macro ToIndex(input: Object, context: Context): Number
    labels RangeError {
  if (input == Undefined) {
    return 0;
  }

  let value: Number = ToInteger_Inline(context, input, kTruncateMinusZero);
  if (value < 0 || value > kMaxSafeInteger) {
    goto RangeError;
  }

  return value;
}

transitioning macro GetLengthProperty(implicit context: Context)(o: Object):
    Number {
  try {
    typeswitch (o) {
      case (a: JSArray): {
        return a.length;
      }
      case (a: JSArgumentsObjectWithLength): {
        goto ToLength(a.length);
      }
      case (Object): deferred {
        goto ToLength(GetProperty(o, kLengthString));
      }
    }
  }
  label ToLength(length: Object) deferred {
    return ToLength_Inline(context, length);
  }
}

transitioning macro GetMethod(implicit context: Context)(
    o: Object, name: constexpr string): Callable labels IfNullOrUndefined {
  const value = GetProperty(o, name);
  if (value == Undefined || value == Null) goto IfNullOrUndefined;
  return Cast<Callable>(value)
      otherwise ThrowTypeError(kPropertyNotFunction, value, name, o);
}

extern macro NumberToString(Number): String;
extern macro IsOneByteStringInstanceType(InstanceType): bool;
extern macro AllocateSeqOneByteString(implicit context: Context)(uint32):
    String;
extern macro AllocateSeqTwoByteString(implicit context: Context)(uint32):
    String;
extern macro ConvertToRelativeIndex(implicit context: Context)(
    Object, intptr): intptr;

extern builtin ObjectToString(Context, Object): Object;
extern builtin StringRepeat(Context, String, Number): String;

struct KeyValuePair {
  key: Object;
  value: Object;
}

// Macro definitions for compatibility that expose functionality to the CSA
// using "legacy" APIs. In Torque code, these should not be used.
@export
macro IsFastJSArray(o: Object, context: Context): bool {
  try {
    // Long-term, it's likely not a good idea to have this slow-path test here,
    // since it fundamentally breaks the type system.
    GotoIfForceSlowPath() otherwise ForceSlow;
  }
  label ForceSlow {
    return false;
  }

  return Is<FastJSArray>(o);
}

@export
macro BranchIfFastJSArray(o: Object, context: Context): never labels True,
    False {
  // Long-term, it's likely not a good idea to have this slow-path test here,
  // since it fundamentally breaks the type system.
  GotoIfForceSlowPath() otherwise False;
  BranchIf<FastJSArray>(o) otherwise True, False;
}

@export
macro BranchIfFastJSArrayForRead(o: Object, context: Context):
    never labels True, False {
  // Long-term, it's likely not a good idea to have this slow-path test here,
  // since it fundamentally breaks the type system.
  GotoIfForceSlowPath() otherwise False;
  BranchIf<FastJSArrayForRead>(o) otherwise True, False;
}

macro BranchIfNotFastJSArray(o: Object, context: Context): never
    labels True, False {
  BranchIfNot<FastJSArray>(o) otherwise True, False;
}

macro BranchIfFastJSArrayForCopy(o: Object, context: Context): never
    labels True, False {
  // Long-term, it's likely not a good idea to have this slow-path test here,
  // since it fundamentally breaks the type system.
  GotoIfForceSlowPath() otherwise False;
  BranchIf<FastJSArrayForCopy>(o) otherwise True, False;
}

@export
macro IsFastJSArrayWithNoCustomIteration(context: Context, o: Object): bool {
  return Is<FastJSArrayWithNoCustomIteration>(o);
}

@export
macro IsFastJSArrayForReadWithNoCustomIteration(context: Context, o: Object):
    bool {
  return Is<FastJSArrayForReadWithNoCustomIteration>(o);
}

extern transitioning runtime
CreateDataProperty(implicit context: Context)(JSReceiver, Object, Object);

namespace runtime {
  extern runtime
  GetDerivedMap(Context, JSFunction, JSReceiver): Map;
}

transitioning builtin FastCreateDataProperty(implicit context: Context)(
    receiver: JSReceiver, key: Object, value: Object): Object {
  try {
    let array = Cast<FastJSArray>(receiver) otherwise Slow;
    const index: Smi = Cast<Smi>(key) otherwise goto Slow;
    if (index < 0 || index > array.length) goto Slow;
    array::EnsureWriteableFastElements(array);
    const isAppend = index == array.length;
    const kind = array.map.elements_kind;
    // We may have to transition a.
    // For now, if transition is required, jump away to slow.
    if (IsFastSmiElementsKind(kind)) {
      const smiValue = Cast<Smi>(value) otherwise Slow;
      if (isAppend) {
        BuildAppendJSArray(HOLEY_SMI_ELEMENTS, array, value) otherwise Slow;
      } else {
        const elements = Cast<FixedArray>(array.elements) otherwise unreachable;
        elements[index] = smiValue;
      }
    } else if (IsDoubleElementsKind(kind)) {
      const numberValue = Cast<Number>(value) otherwise Slow;
      if (isAppend) {
        BuildAppendJSArray(HOLEY_DOUBLE_ELEMENTS, array, value)
            otherwise Slow;
      } else {
        const doubleElements = Cast<FixedDoubleArray>(array.elements)
            otherwise unreachable;
        doubleElements[index] = numberValue;
      }
    } else {
      assert(IsFastSmiOrTaggedElementsKind(kind));
      if (isAppend) {
        BuildAppendJSArray(HOLEY_ELEMENTS, array, value) otherwise Slow;
      } else {
        const elements = Cast<FixedArray>(array.elements) otherwise unreachable;
        elements[index] = value;
      }
    }
  }
  label Slow {
    CreateDataProperty(receiver, key, value);
  }
  return Undefined;
}

@export
transitioning macro ToStringImpl(context: Context, o: Object): String {
  let result: Object = o;
  while (true) {
    typeswitch (result) {
      case (num: Number): {
        return NumberToString(num);
      }
      case (str: String): {
        return str;
      }
      case (oddball: Oddball): {
        return oddball.to_string;
      }
      case (JSReceiver): {
        result = NonPrimitiveToPrimitive_String(context, result);
        continue;
      }
      case (Symbol): {
        ThrowTypeError(kSymbolToString);
      }
      case (Object): {
        return ToStringRT(context, o);
      }
    }
  }
  unreachable;
}

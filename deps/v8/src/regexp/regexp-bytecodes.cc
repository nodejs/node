// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/regexp/regexp-bytecodes.h"

#include <cctype>

#include "src/regexp/regexp-bytecode-analysis.h"
#include "src/regexp/regexp-bytecodes-inl.h"
#include "src/utils/ostreams.h"
#include "src/utils/utils.h"

namespace v8 {
namespace internal {

namespace {

std::ostream& operator<<(std::ostream& os,
                         RegExpMacroAssembler::StackCheckFlag val) {
  switch (val) {
    case RegExpMacroAssembler::StackCheckFlag::kNoStackLimitCheck:
      return os << "NoCheck";
    case RegExpMacroAssembler::StackCheckFlag::kCheckStackLimit:
      return os << "Check";
  }
}

std::ostream& operator<<(std::ostream& os, StandardCharacterSet val) {
  switch (val) {
    case StandardCharacterSet::kWhitespace:
      return os << "Whitespace";
    case StandardCharacterSet::kNotWhitespace:
      return os << "NotWhitespace";
    case StandardCharacterSet::kDigit:
      return os << "Digit";
    case StandardCharacterSet::kNotDigit:
      return os << "NotDigit";
    case StandardCharacterSet::kLineTerminator:
      return os << "LineTerminator";
    case StandardCharacterSet::kNotLineTerminator:
      return os << "NotLineTerminator";
    case StandardCharacterSet::kWord:
      return os << "Word";
    case StandardCharacterSet::kNotWord:
      return os << "NotWord";
    case StandardCharacterSet::kEverything:
      return os << "Everything";
  }
}

}  // namespace

void RegExpBytecodeDisassembleSingle(const uint8_t* code_base,
                                     const uint8_t* pc) {
  StdoutStream os;
  DisallowGarbageCollection no_gc;
  RegExpBytecode bytecode = RegExpBytecodes::FromPtr(pc);
  os << RegExpBytecodes::Name(bytecode);

  RegExpBytecodes::DispatchOnBytecode(bytecode, [&]<RegExpBytecode bc>() {
    RegExpBytecodeOperands<bc>::ForEachOperand([&]<auto op>() {
      constexpr RegExpBytecodeOperandType type =
          RegExpBytecodeOperands<bc>::Type(op);
      os << ", " << RegExpBytecodeOperands<bc>::Name(op) << ": ";

      auto val = RegExpBytecodeOperands<bc>::template Get<op>(pc, no_gc);
      if constexpr (type == RegExpBytecodeOperandType::kBitTable) {
        for (int i = 0; i < RegExpBytecodeOperands<bc>::Size(op); i++) {
          os << AsHex(val[i], 2);
        }
      } else if constexpr (type == RegExpBytecodeOperandType::kChar) {
        os << AsUC32(val);
      } else if constexpr (std::is_enum_v<decltype(val)>) {
        os << val;
      } else {
        os << AsHex(val, 2);
      }
    });
  });
  os << "\n";
}

void RegExpBytecodeDisassemble(const uint8_t* code_base, uint32_t length,
                               const char* pattern) {
  RegExpBytecodeDisassemble(code_base, length, pattern, nullptr);
}

void RegExpBytecodeDisassemble(const uint8_t* code_base, uint32_t length,
                               const char* pattern,
                               RegExpBytecodeAnalysis* analysis) {
  PrintF("[generated bytecode for regexp pattern: '%s']\n", pattern);

  uint32_t offset = 0;

  // TODO(pthier): Consider using the RegExpBytecodeIterator.
  while (offset < length) {
    if (analysis) {
      uint32_t block_id = analysis->GetBlockId(offset);
      if (analysis->BlockStart(block_id) == offset) {
        analysis->PrintBlock(block_id);
      }
    }
    const uint8_t* const pc = code_base + offset;
    PrintF("%p  %4x  ", pc, offset);
    RegExpBytecodeDisassembleSingle(code_base, pc);
    offset += RegExpBytecodes::Size(RegExpBytecodes::FromPtr(pc));
  }
}

}  // namespace internal
}  // namespace v8

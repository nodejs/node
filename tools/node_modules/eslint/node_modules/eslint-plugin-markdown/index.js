'use strict';

var path = require('path');
var require$$0$1 = require('util');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend$1 = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

var bail_1 = bail;

function bail(err) {
  if (err) {
    throw err
  }
}

var own$5 = {}.hasOwnProperty;

var unistUtilStringifyPosition = stringify;

function stringify(value) {
  /* Nothing. */
  if (!value || typeof value !== 'object') {
    return null
  }

  /* Node. */
  if (own$5.call(value, 'position') || own$5.call(value, 'type')) {
    return position(value.position)
  }

  /* Position. */
  if (own$5.call(value, 'start') || own$5.call(value, 'end')) {
    return position(value)
  }

  /* Point. */
  if (own$5.call(value, 'line') || own$5.call(value, 'column')) {
    return point(value)
  }

  /* ? */
  return null
}

function point(point) {
  if (!point || typeof point !== 'object') {
    point = {};
  }

  return index(point.line) + ':' + index(point.column)
}

function position(pos) {
  if (!pos || typeof pos !== 'object') {
    pos = {};
  }

  return point(pos.start) + '-' + point(pos.end)
}

function index(value) {
  return value && typeof value === 'number' ? value : 1
}

var vfileMessage = VMessage;

// Inherit from `Error#`.
function VMessagePrototype() {}
VMessagePrototype.prototype = Error.prototype;
VMessage.prototype = new VMessagePrototype();

// Message properties.
var proto$3 = VMessage.prototype;

proto$3.file = '';
proto$3.name = '';
proto$3.reason = '';
proto$3.message = '';
proto$3.stack = '';
proto$3.fatal = null;
proto$3.column = null;
proto$3.line = null;

// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function VMessage(reason, position, origin) {
  var parts;
  var range;
  var location;

  if (typeof position === 'string') {
    origin = position;
    position = null;
  }

  parts = parseOrigin(origin);
  range = unistUtilStringifyPosition(position) || '1:1';

  location = {
    start: {line: null, column: null},
    end: {line: null, column: null}
  };

  // Node.
  if (position && position.position) {
    position = position.position;
  }

  if (position) {
    // Position.
    if (position.start) {
      location = position;
      position = position.start;
    } else {
      // Point.
      location.start = position;
    }
  }

  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }

  this.message = reason;
  this.name = range;
  this.reason = reason;
  this.line = position ? position.line : null;
  this.column = position ? position.column : null;
  this.location = location;
  this.source = parts[0];
  this.ruleId = parts[1];
}

function parseOrigin(origin) {
  var result = [null, null];
  var index;

  if (typeof origin === 'string') {
    index = origin.indexOf(':');

    if (index === -1) {
      result[1] = origin;
    } else {
      result[0] = origin.slice(0, index);
      result[1] = origin.slice(index + 1);
    }
  }

  return result
}

function replaceExt(npath, ext) {
  if (typeof npath !== 'string') {
    return npath;
  }

  if (npath.length === 0) {
    return npath;
  }

  var nFileName = path__default['default'].basename(npath, path__default['default'].extname(npath)) + ext;
  return path__default['default'].join(path__default['default'].dirname(npath), nFileName);
}

var replaceExt_1 = replaceExt;

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
};

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

var core = VFile;

var own$4 = {}.hasOwnProperty;
var proto$2 = VFile.prototype;

proto$2.toString = toString$2;

/* Order of setting (least specific to most), we need this because
 * otherwise `{stem: 'a', path: '~/b.js'}` would throw, as a path
 * is needed before a stem can be set. */
var order$1 = [
  'history',
  'path',
  'basename',
  'stem',
  'extname',
  'dirname'
];

/* Construct a new file. */
function VFile(options) {
  var prop;
  var index;
  var length;

  if (!options) {
    options = {};
  } else if (typeof options === 'string' || isBuffer_1(options)) {
    options = {contents: options};
  } else if ('message' in options && 'messages' in options) {
    return options;
  }

  if (!(this instanceof VFile)) {
    return new VFile(options);
  }

  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = process.cwd();

  /* Set path related properties in the correct order. */
  index = -1;
  length = order$1.length;

  while (++index < length) {
    prop = order$1[index];

    if (own$4.call(options, prop)) {
      this[prop] = options[prop];
    }
  }

  /* Set non-path related properties. */
  for (prop in options) {
    if (order$1.indexOf(prop) === -1) {
      this[prop] = options[prop];
    }
  }
}

/* Access full path (`~/index.min.js`). */
Object.defineProperty(proto$2, 'path', {
  get: function () {
    return this.history[this.history.length - 1];
  },
  set: function (path) {
    assertNonEmpty(path, 'path');

    if (path !== this.path) {
      this.history.push(path);
    }
  }
});

/* Access parent path (`~`). */
Object.defineProperty(proto$2, 'dirname', {
  get: function () {
    return typeof this.path === 'string' ? path__default['default'].dirname(this.path) : undefined;
  },
  set: function (dirname) {
    assertPath(this.path, 'dirname');
    this.path = path__default['default'].join(dirname || '', this.basename);
  }
});

/* Access basename (`index.min.js`). */
Object.defineProperty(proto$2, 'basename', {
  get: function () {
    return typeof this.path === 'string' ? path__default['default'].basename(this.path) : undefined;
  },
  set: function (basename) {
    assertNonEmpty(basename, 'basename');
    assertPart(basename, 'basename');
    this.path = path__default['default'].join(this.dirname || '', basename);
  }
});

/* Access extname (`.js`). */
Object.defineProperty(proto$2, 'extname', {
  get: function () {
    return typeof this.path === 'string' ? path__default['default'].extname(this.path) : undefined;
  },
  set: function (extname) {
    var ext = extname || '';

    assertPart(ext, 'extname');
    assertPath(this.path, 'extname');

    if (ext) {
      if (ext.charAt(0) !== '.') {
        throw new Error('`extname` must start with `.`');
      }

      if (ext.indexOf('.', 1) !== -1) {
        throw new Error('`extname` cannot contain multiple dots');
      }
    }

    this.path = replaceExt_1(this.path, ext);
  }
});

/* Access stem (`index.min`). */
Object.defineProperty(proto$2, 'stem', {
  get: function () {
    return typeof this.path === 'string' ? path__default['default'].basename(this.path, this.extname) : undefined;
  },
  set: function (stem) {
    assertNonEmpty(stem, 'stem');
    assertPart(stem, 'stem');
    this.path = path__default['default'].join(this.dirname || '', stem + (this.extname || ''));
  }
});

/* Get the value of the file. */
function toString$2(encoding) {
  var value = this.contents || '';
  return isBuffer_1(value) ? value.toString(encoding) : String(value);
}

/* Assert that `part` is not a path (i.e., does
 * not contain `path.sep`). */
function assertPart(part, name) {
  if (part.indexOf(path__default['default'].sep) !== -1) {
    throw new Error('`' + name + '` cannot be a path: did not expect `' + path__default['default'].sep + '`');
  }
}

/* Assert that `part` is not empty. */
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty');
  }
}

/* Assert `path` exists. */
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too');
  }
}

var vfile = core;

var proto$1 = core.prototype;

proto$1.message = message;
proto$1.info = info;
proto$1.fail = fail;

/* Slight backwards compatibility.  Remove in the future. */
proto$1.warn = message;

/* Create a message with `reason` at `position`.
 * When an error is passed in as `reason`, copies the stack. */
function message(reason, position, origin) {
  var filePath = this.path;
  var message = new vfileMessage(reason, position, origin);

  if (filePath) {
    message.name = filePath + ':' + message.name;
    message.file = filePath;
  }

  message.fatal = false;

  this.messages.push(message);

  return message;
}

/* Fail. Creates a vmessage, associates it with the file,
 * and throws it. */
function fail() {
  var message = this.message.apply(this, arguments);

  message.fatal = true;

  throw message;
}

/* Info. Creates a vmessage, associates it with the file,
 * and marks the fatality as null. */
function info() {
  var message = this.message.apply(this, arguments);

  message.fatal = null;

  return message;
}

var slice$2 = [].slice;

var wrap_1 = wrap;

// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function wrap(fn, callback) {
  var invoked;

  return wrapped

  function wrapped() {
    var params = slice$2.call(arguments, 0);
    var callback = fn.length > params.length;
    var result;

    if (callback) {
      params.push(done);
    }

    try {
      result = fn.apply(null, params);
    } catch (error) {
      // Well, this is quite the pickle.
      // `fn` received a callback and invoked it (thus continuing the pipeline),
      // but later also threw an error.
      // We‚Äôre not about to restart the pipeline again, so the only thing left
      // to do is to throw the thing instead.
      if (callback && invoked) {
        throw error
      }

      return done(error)
    }

    if (!callback) {
      if (result && typeof result.then === 'function') {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }

  // Invoke `next`, only once.
  function done() {
    if (!invoked) {
      invoked = true;

      callback.apply(null, arguments);
    }
  }

  // Invoke `done` with one value.
  // Tracks if an error is passed, too.
  function then(value) {
    done(null, value);
  }
}

var trough_1 = trough;

trough.wrap = wrap_1;

var slice$1 = [].slice;

// Create new middleware.
function trough() {
  var fns = [];
  var middleware = {};

  middleware.run = run;
  middleware.use = use;

  return middleware

  // Run `fns`.  Last argument must be a completion handler.
  function run() {
    var index = -1;
    var input = slice$1.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];

    if (typeof done !== 'function') {
      throw new Error('Expected function as last argument, not ' + done)
    }

    next.apply(null, [null].concat(input));

    // Run the next `fn`, if any.
    function next(err) {
      var fn = fns[++index];
      var params = slice$1.call(arguments, 0);
      var values = params.slice(1);
      var length = input.length;
      var pos = -1;

      if (err) {
        done(err);
        return
      }

      // Copy non-nully input into values.
      while (++pos < length) {
        if (values[pos] === null || values[pos] === undefined) {
          values[pos] = input[pos];
        }
      }

      input = values;

      // Next or done.
      if (fn) {
        wrap_1(fn, next).apply(null, input);
      } else {
        done.apply(null, [null].concat(input));
      }
    }
  }

  // Add `fn` to the list.
  function use(fn) {
    if (typeof fn !== 'function') {
      throw new Error('Expected `fn` to be a function, not ' + fn)
    }

    fns.push(fn);

    return middleware
  }
}

var toString$1 = Object.prototype.toString;

var xIsString = isString;

function isString(obj) {
    return toString$1.call(obj) === "[object String]"
}

var toString = Object.prototype.toString;

var isPlainObj = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};

/* Dependencies. */







/* Expose a frozen processor. */
var unified_1 = unified().freeze();

var slice = [].slice;
var own$3 = {}.hasOwnProperty;

/* Process pipeline. */
var pipeline = trough_1()
  .use(pipelineParse)
  .use(pipelineRun)
  .use(pipelineStringify);

function pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}

function pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);

  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}

function pipelineStringify(p, ctx) {
  ctx.file.contents = p.stringify(ctx.tree, ctx.file);
}

/* Function to create the first processor. */
function unified() {
  var attachers = [];
  var transformers = trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;

  /* Data management. */
  processor.data = data;

  /* Lock. */
  processor.freeze = freeze;

  /* Plug-ins. */
  processor.attachers = attachers;
  processor.use = use;

  /* API. */
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;

  /* Expose. */
  return processor

  /* Create a new processor based on the processor
   * in the current scope. */
  function processor() {
    var destination = unified();
    var length = attachers.length;
    var index = -1;

    while (++index < length) {
      destination.use.apply(null, attachers[index]);
    }

    destination.data(extend$1(true, {}, namespace));

    return destination
  }

  /* Freeze: used to signal a processor that has finished
   * configuration.
   *
   * For example, take unified itself.  It‚Äôs frozen.
   * Plug-ins should not be added to it.  Rather, it should
   * be extended, by invoking it, before modifying it.
   *
   * In essence, always invoke this when exporting a
   * processor. */
  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;

    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;

      if (options === false) {
        continue
      }

      if (options === true) {
        values[1] = undefined;
      }

      transformer = plugin.apply(processor, values.slice(1));

      if (typeof transformer === 'function') {
        transformers.use(transformer);
      }
    }

    frozen = true;
    freezeIndex = Infinity;

    return processor
  }

  /* Data management.
   * Getter / setter for processor-specific informtion. */
  function data(key, value) {
    if (xIsString(key)) {
      /* Set `key`. */
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen);

        namespace[key] = value;

        return processor
      }

      /* Get `key`. */
      return (own$3.call(namespace, key) && namespace[key]) || null
    }

    /* Set space. */
    if (key) {
      assertUnfrozen('data', frozen);
      namespace = key;
      return processor
    }

    /* Get space. */
    return namespace
  }

  /* Plug-in management.
   *
   * Pass it:
   * *   an attacher and options,
   * *   a preset,
   * *   a list of presets, attachers, and arguments (list
   *     of attachers and options). */
  function use(value) {
    var settings;

    assertUnfrozen('use', frozen);

    if (value === null || value === undefined) ; else if (typeof value === 'function') {
      addPlugin.apply(null, arguments);
    } else if (typeof value === 'object') {
      if ('length' in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = extend$1(namespace.settings || {}, settings);
    }

    return processor

    function addPreset(result) {
      addList(result.plugins);

      if (result.settings) {
        settings = extend$1(settings || {}, result.settings);
      }
    }

    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value);
      } else if (typeof value === 'object') {
        if ('length' in value) {
          addPlugin.apply(null, value);
        } else {
          addPreset(value);
        }
      } else {
        throw new Error('Expected usable value, not `' + value + '`')
      }
    }

    function addList(plugins) {
      var length;
      var index;

      if (plugins === null || plugins === undefined) ; else if (typeof plugins === 'object' && 'length' in plugins) {
        length = plugins.length;
        index = -1;

        while (++index < length) {
          add(plugins[index]);
        }
      } else {
        throw new Error('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    function addPlugin(plugin, value) {
      var entry = find(plugin);

      if (entry) {
        if (isPlainObj(entry[1]) && isPlainObj(value)) {
          value = extend$1(entry[1], value);
        }

        entry[1] = value;
      } else {
        attachers.push(slice.call(arguments));
      }
    }
  }

  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;

    while (++index < length) {
      entry = attachers[index];

      if (entry[0] === plugin) {
        return entry
      }
    }
  }

  /* Parse a file (in string or VFile representation)
   * into a Unist node using the `Parser` on the
   * processor. */
  function parse(doc) {
    var file = vfile(doc);
    var Parser;

    freeze();
    Parser = processor.Parser;
    assertParser('parse', Parser);

    if (newable(Parser)) {
      return new Parser(String(file), file).parse()
    }

    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  /* Run transforms on a Unist node representation of a file
   * (in string or VFile representation), async. */
  function run(node, file, cb) {
    assertNode(node);
    freeze();

    if (!cb && typeof file === 'function') {
      cb = file;
      file = null;
    }

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb);

    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done);

      function done(err, tree, file) {
        tree = tree || node;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file);
        }
      }
    }
  }

  /* Run transforms on a Unist node representation of a file
   * (in string or VFile representation), sync. */
  function runSync(node, file) {
    var complete = false;
    var result;

    run(node, file, done);

    assertDone('runSync', 'run', complete);

    return result

    function done(err, tree) {
      complete = true;
      bail_1(err);
      result = tree;
    }
  }

  /* Stringify a Unist node representation of a file
   * (in string or VFile representation) into a string
   * using the `Compiler` on the processor. */
  function stringify(node, doc) {
    var file = vfile(doc);
    var Compiler;

    freeze();
    Compiler = processor.Compiler;
    assertCompiler('stringify', Compiler);
    assertNode(node);

    if (newable(Compiler)) {
      return new Compiler(node, file).compile()
    }

    return Compiler(node, file) // eslint-disable-line new-cap
  }

  /* Parse a file (in string or VFile representation)
   * into a Unist node using the `Parser` on the processor,
   * then run transforms on that node, and compile the
   * resulting node using the `Compiler` on the processor,
   * and store that result on the VFile. */
  function process(doc, cb) {
    freeze();
    assertParser('process', processor.Parser);
    assertCompiler('process', processor.Compiler);

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb);

    function executor(resolve, reject) {
      var file = vfile(doc);

      pipeline.run(processor, {file: file}, done);

      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }

  /* Process the given document (in string or VFile
   * representation), sync. */
  function processSync(doc) {
    var complete = false;
    var file;

    freeze();
    assertParser('processSync', processor.Parser);
    assertCompiler('processSync', processor.Compiler);
    file = vfile(doc);

    process(file, done);

    assertDone('processSync', 'process', complete);

    return file

    function done(err) {
      complete = true;
      bail_1(err);
    }
  }
}

/* Check if `func` is a constructor. */
function newable(value) {
  return typeof value === 'function' && keys$1(value.prototype)
}

/* Check if `value` is an object with keys. */
function keys$1(value) {
  var key;
  for (key in value) {
    return true
  }
  return false
}

/* Assert a parser is available. */
function assertParser(name, Parser) {
  if (typeof Parser !== 'function') {
    throw new Error('Cannot `' + name + '` without `Parser`')
  }
}

/* Assert a compiler is available. */
function assertCompiler(name, Compiler) {
  if (typeof Compiler !== 'function') {
    throw new Error('Cannot `' + name + '` without `Compiler`')
  }
}

/* Assert the processor is not frozen. */
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      [
        'Cannot invoke `' + name + '` on a frozen processor.\nCreate a new ',
        'processor first, by invoking it: use `processor()` instead of ',
        '`processor`.'
      ].join('')
    )
  }
}

/* Assert `node` is a Unist node. */
function assertNode(node) {
  if (!node || !xIsString(node.type)) {
    throw new Error('Expected node, got `' + node + '`')
  }
}

/* Assert that `complete` is `true`. */
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}

var immutable = extend;

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

var inherits = createCommonjsModule(function (module) {
try {
  var util = require$$0__default['default'];
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = inherits_browser;
}
});

var unherit_1 = unherit;

// Create a custom constructor which can be modified without affecting the
// original class.
function unherit(Super) {
  var result;
  var key;
  var value;

  inherits(Of, Super);
  inherits(From, Of);

  // Clone values.
  result = Of.prototype;

  for (key in result) {
    value = result[key];

    if (value && typeof value === 'object') {
      result[key] = 'concat' in value ? value.concat() : immutable(value);
    }
  }

  return Of

  // Constructor accepting a single argument, which itself is an `arguments`
  // object.
  function From(parameters) {
    return Super.apply(this, parameters)
  }

  // Constructor accepting variadic arguments.
  function Of() {
    if (!(this instanceof Of)) {
      return new From(arguments)
    }

    return Super.apply(this, arguments)
  }
}

var stateToggle = factory$4;

// Construct a state `toggler`: a function which inverses `property` in context
// based on its current value.
// The by `toggler` returned function restores that value.
function factory$4(key, state, ctx) {
  return enter

  function enter() {
    var context = ctx || this;
    var current = context[key];

    context[key] = !state;

    return exit

    function exit() {
      context[key] = current;
    }
  }
}

var vfileLocation = factory$3;

function factory$3(file) {
  var contents = indices(String(file));

  return {
    toPosition: offsetToPositionFactory(contents),
    toOffset: positionToOffsetFactory(contents)
  }
}

// Factory to get the line and column-based `position` for `offset` in the bound
// indices.
function offsetToPositionFactory(indices) {
  return offsetToPosition

  // Get the line and column-based `position` for `offset` in the bound indices.
  function offsetToPosition(offset) {
    var index = -1;
    var length = indices.length;

    if (offset < 0) {
      return {}
    }

    while (++index < length) {
      if (indices[index] > offset) {
        return {
          line: index + 1,
          column: offset - (indices[index - 1] || 0) + 1,
          offset: offset
        }
      }
    }

    return {}
  }
}

// Factory to get the `offset` for a line and column-based `position` in the
// bound indices.
function positionToOffsetFactory(indices) {
  return positionToOffset

  // Get the `offset` for a line and column-based `position` in the bound
  // indices.
  function positionToOffset(position) {
    var line = position && position.line;
    var column = position && position.column;

    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
      return (indices[line - 2] || 0) + column - 1 || 0
    }

    return -1
  }
}

// Get indices of line-breaks in `value`.
function indices(value) {
  var result = [];
  var index = value.indexOf('\n');

  while (index !== -1) {
    result.push(index + 1);
    index = value.indexOf('\n', index + 1);
  }

  result.push(value.length + 1);

  return result
}

var _unescape = factory$2;

/* Factory to de-escape a value, based on a list at `key`
 * in `ctx`. */
function factory$2(ctx, key) {
  return unescape;

  /* De-escape a string using the expression at `key`
   * in `ctx`. */
  function unescape(value) {
    var prev = 0;
    var index = value.indexOf('\\');
    var escape = ctx[key];
    var queue = [];
    var character;

    while (index !== -1) {
      queue.push(value.slice(prev, index));
      prev = index + 1;
      character = value.charAt(prev);

      /* If the following character is not a valid escape,
       * add the slash. */
      if (!character || escape.indexOf(character) === -1) {
        queue.push('\\');
      }

      index = value.indexOf('\\', prev);
    }

    queue.push(value.slice(prev));

    return queue.join('');
  }
}

var AElig$1 = "√Ü";
var AMP$1 = "&";
var Aacute$1 = "√Å";
var Acirc$1 = "√Ç";
var Agrave$1 = "√Ä";
var Aring$1 = "√Ö";
var Atilde$1 = "√É";
var Auml$1 = "√Ñ";
var COPY$1 = "¬©";
var Ccedil$1 = "√á";
var ETH$1 = "√ê";
var Eacute$1 = "√â";
var Ecirc$1 = "√ä";
var Egrave$1 = "√à";
var Euml$1 = "√ã";
var GT$1 = ">";
var Iacute$1 = "√ç";
var Icirc$1 = "√é";
var Igrave$1 = "√å";
var Iuml$1 = "√è";
var LT$1 = "<";
var Ntilde$1 = "√ë";
var Oacute$1 = "√ì";
var Ocirc$1 = "√î";
var Ograve$1 = "√í";
var Oslash$1 = "√ò";
var Otilde$1 = "√ï";
var Ouml$1 = "√ñ";
var QUOT$1 = "\"";
var REG$1 = "¬Æ";
var THORN$1 = "√û";
var Uacute$1 = "√ö";
var Ucirc$1 = "√õ";
var Ugrave$1 = "√ô";
var Uuml$1 = "√ú";
var Yacute$1 = "√ù";
var aacute$1 = "√°";
var acirc$1 = "√¢";
var acute$1 = "¬¥";
var aelig$1 = "√¶";
var agrave$1 = "√†";
var amp$1 = "&";
var aring$1 = "√•";
var atilde$1 = "√£";
var auml$1 = "√§";
var brvbar$1 = "¬¶";
var ccedil$1 = "√ß";
var cedil$1 = "¬∏";
var cent$1 = "¬¢";
var copy$1 = "¬©";
var curren$1 = "¬§";
var deg$1 = "¬∞";
var divide$1 = "√∑";
var eacute$1 = "√©";
var ecirc$1 = "√™";
var egrave$1 = "√®";
var eth$1 = "√∞";
var euml$1 = "√´";
var frac12$1 = "¬Ω";
var frac14$1 = "¬º";
var frac34$1 = "¬æ";
var gt$1 = ">";
var iacute$1 = "√≠";
var icirc$1 = "√Æ";
var iexcl$1 = "¬°";
var igrave$1 = "√¨";
var iquest$1 = "¬ø";
var iuml$1 = "√Ø";
var laquo$1 = "¬´";
var lt$1 = "<";
var macr$1 = "¬Ø";
var micro$1 = "¬µ";
var middot$1 = "¬∑";
var nbsp$1 = "¬†";
var not$1 = "¬¨";
var ntilde$1 = "√±";
var oacute$1 = "√≥";
var ocirc$1 = "√¥";
var ograve$1 = "√≤";
var ordf$1 = "¬™";
var ordm$1 = "¬∫";
var oslash$1 = "√∏";
var otilde$1 = "√µ";
var ouml$1 = "√∂";
var para$1 = "¬∂";
var plusmn$1 = "¬±";
var pound$1 = "¬£";
var quot$1 = "\"";
var raquo$1 = "¬ª";
var reg$1 = "¬Æ";
var sect$1 = "¬ß";
var shy$1 = "¬≠";
var sup1$1 = "¬π";
var sup2$1 = "¬≤";
var sup3$1 = "¬≥";
var szlig$1 = "√ü";
var thorn$1 = "√æ";
var times$1 = "√ó";
var uacute$1 = "√∫";
var ucirc$1 = "√ª";
var ugrave$1 = "√π";
var uml$1 = "¬®";
var uuml$1 = "√º";
var yacute$1 = "√Ω";
var yen$1 = "¬•";
var yuml$1 = "√ø";
var legacy = {
	AElig: AElig$1,
	AMP: AMP$1,
	Aacute: Aacute$1,
	Acirc: Acirc$1,
	Agrave: Agrave$1,
	Aring: Aring$1,
	Atilde: Atilde$1,
	Auml: Auml$1,
	COPY: COPY$1,
	Ccedil: Ccedil$1,
	ETH: ETH$1,
	Eacute: Eacute$1,
	Ecirc: Ecirc$1,
	Egrave: Egrave$1,
	Euml: Euml$1,
	GT: GT$1,
	Iacute: Iacute$1,
	Icirc: Icirc$1,
	Igrave: Igrave$1,
	Iuml: Iuml$1,
	LT: LT$1,
	Ntilde: Ntilde$1,
	Oacute: Oacute$1,
	Ocirc: Ocirc$1,
	Ograve: Ograve$1,
	Oslash: Oslash$1,
	Otilde: Otilde$1,
	Ouml: Ouml$1,
	QUOT: QUOT$1,
	REG: REG$1,
	THORN: THORN$1,
	Uacute: Uacute$1,
	Ucirc: Ucirc$1,
	Ugrave: Ugrave$1,
	Uuml: Uuml$1,
	Yacute: Yacute$1,
	aacute: aacute$1,
	acirc: acirc$1,
	acute: acute$1,
	aelig: aelig$1,
	agrave: agrave$1,
	amp: amp$1,
	aring: aring$1,
	atilde: atilde$1,
	auml: auml$1,
	brvbar: brvbar$1,
	ccedil: ccedil$1,
	cedil: cedil$1,
	cent: cent$1,
	copy: copy$1,
	curren: curren$1,
	deg: deg$1,
	divide: divide$1,
	eacute: eacute$1,
	ecirc: ecirc$1,
	egrave: egrave$1,
	eth: eth$1,
	euml: euml$1,
	frac12: frac12$1,
	frac14: frac14$1,
	frac34: frac34$1,
	gt: gt$1,
	iacute: iacute$1,
	icirc: icirc$1,
	iexcl: iexcl$1,
	igrave: igrave$1,
	iquest: iquest$1,
	iuml: iuml$1,
	laquo: laquo$1,
	lt: lt$1,
	macr: macr$1,
	micro: micro$1,
	middot: middot$1,
	nbsp: nbsp$1,
	not: not$1,
	ntilde: ntilde$1,
	oacute: oacute$1,
	ocirc: ocirc$1,
	ograve: ograve$1,
	ordf: ordf$1,
	ordm: ordm$1,
	oslash: oslash$1,
	otilde: otilde$1,
	ouml: ouml$1,
	para: para$1,
	plusmn: plusmn$1,
	pound: pound$1,
	quot: quot$1,
	raquo: raquo$1,
	reg: reg$1,
	sect: sect$1,
	shy: shy$1,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	szlig: szlig$1,
	thorn: thorn$1,
	times: times$1,
	uacute: uacute$1,
	ucirc: ucirc$1,
	ugrave: ugrave$1,
	uml: uml$1,
	uuml: uuml$1,
	yacute: yacute$1,
	yen: yen$1,
	yuml: yuml$1
};

var invalid = {
	"0": "ÔøΩ",
	"128": "‚Ç¨",
	"130": "‚Äö",
	"131": "∆í",
	"132": "‚Äû",
	"133": "‚Ä¶",
	"134": "‚Ä†",
	"135": "‚Ä°",
	"136": "ÀÜ",
	"137": "‚Ä∞",
	"138": "≈†",
	"139": "‚Äπ",
	"140": "≈í",
	"142": "≈Ω",
	"145": "‚Äò",
	"146": "‚Äô",
	"147": "‚Äú",
	"148": "‚Äù",
	"149": "‚Ä¢",
	"150": "‚Äì",
	"151": "‚Äî",
	"152": "Àú",
	"153": "‚Ñ¢",
	"154": "≈°",
	"155": "‚Ä∫",
	"156": "≈ì",
	"158": "≈æ",
	"159": "≈∏"
};

var isDecimal = decimal;

// Check if the given character code, or the character code at the first
// character, is decimal.
function decimal(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return code >= 48 && code <= 57 /* 0-9 */
}

var isHexadecimal = hexadecimal;

// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function hexadecimal(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return (
    (code >= 97 /* a */ && code <= 102) /* z */ ||
    (code >= 65 /* A */ && code <= 70) /* Z */ ||
    (code >= 48 /* A */ && code <= 57) /* Z */
  )
}

var isAlphabetical = alphabetical;

// Check if the given character code, or the character code at the first
// character, is alphabetical.
function alphabetical(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return (
    (code >= 97 && code <= 122) /* a-z */ ||
    (code >= 65 && code <= 90) /* A-Z */
  )
}

var isAlphanumerical = alphanumerical;

// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function alphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character)
}

var AEli = "√Ü";
var AElig = "√Ü";
var AM = "&";
var AMP = "&";
var Aacut = "√Å";
var Aacute = "√Å";
var Abreve = "ƒÇ";
var Acir = "√Ç";
var Acirc = "√Ç";
var Acy = "–ê";
var Afr = "ùîÑ";
var Agrav = "√Ä";
var Agrave = "√Ä";
var Alpha = "Œë";
var Amacr = "ƒÄ";
var And = "‚©ì";
var Aogon = "ƒÑ";
var Aopf = "ùî∏";
var ApplyFunction = "‚Å°";
var Arin = "√Ö";
var Aring = "√Ö";
var Ascr = "ùíú";
var Assign = "‚âî";
var Atild = "√É";
var Atilde = "√É";
var Aum = "√Ñ";
var Auml = "√Ñ";
var Backslash = "‚àñ";
var Barv = "‚´ß";
var Barwed = "‚åÜ";
var Bcy = "–ë";
var Because = "‚àµ";
var Bernoullis = "‚Ñ¨";
var Beta = "Œí";
var Bfr = "ùîÖ";
var Bopf = "ùîπ";
var Breve = "Àò";
var Bscr = "‚Ñ¨";
var Bumpeq = "‚âé";
var CHcy = "–ß";
var COP = "¬©";
var COPY = "¬©";
var Cacute = "ƒÜ";
var Cap = "‚ãí";
var CapitalDifferentialD = "‚ÖÖ";
var Cayleys = "‚Ñ≠";
var Ccaron = "ƒå";
var Ccedi = "√á";
var Ccedil = "√á";
var Ccirc = "ƒà";
var Cconint = "‚à∞";
var Cdot = "ƒä";
var Cedilla = "¬∏";
var CenterDot = "¬∑";
var Cfr = "‚Ñ≠";
var Chi = "Œß";
var CircleDot = "‚äô";
var CircleMinus = "‚äñ";
var CirclePlus = "‚äï";
var CircleTimes = "‚äó";
var ClockwiseContourIntegral = "‚à≤";
var CloseCurlyDoubleQuote = "‚Äù";
var CloseCurlyQuote = "‚Äô";
var Colon = "‚à∑";
var Colone = "‚©¥";
var Congruent = "‚â°";
var Conint = "‚àØ";
var ContourIntegral = "‚àÆ";
var Copf = "‚ÑÇ";
var Coproduct = "‚àê";
var CounterClockwiseContourIntegral = "‚à≥";
var Cross = "‚®Ø";
var Cscr = "ùíû";
var Cup = "‚ãì";
var CupCap = "‚âç";
var DD = "‚ÖÖ";
var DDotrahd = "‚§ë";
var DJcy = "–Ç";
var DScy = "–Ö";
var DZcy = "–è";
var Dagger = "‚Ä°";
var Darr = "‚Ü°";
var Dashv = "‚´§";
var Dcaron = "ƒé";
var Dcy = "–î";
var Del = "‚àá";
var Delta = "Œî";
var Dfr = "ùîá";
var DiacriticalAcute = "¬¥";
var DiacriticalDot = "Àô";
var DiacriticalDoubleAcute = "Àù";
var DiacriticalGrave = "`";
var DiacriticalTilde = "Àú";
var Diamond = "‚ãÑ";
var DifferentialD = "‚ÖÜ";
var Dopf = "ùîª";
var Dot = "¬®";
var DotDot = "‚Éú";
var DotEqual = "‚âê";
var DoubleContourIntegral = "‚àØ";
var DoubleDot = "¬®";
var DoubleDownArrow = "‚áì";
var DoubleLeftArrow = "‚áê";
var DoubleLeftRightArrow = "‚áî";
var DoubleLeftTee = "‚´§";
var DoubleLongLeftArrow = "‚ü∏";
var DoubleLongLeftRightArrow = "‚ü∫";
var DoubleLongRightArrow = "‚üπ";
var DoubleRightArrow = "‚áí";
var DoubleRightTee = "‚ä®";
var DoubleUpArrow = "‚áë";
var DoubleUpDownArrow = "‚áï";
var DoubleVerticalBar = "‚à•";
var DownArrow = "‚Üì";
var DownArrowBar = "‚§ì";
var DownArrowUpArrow = "‚áµ";
var DownBreve = "Ãë";
var DownLeftRightVector = "‚•ê";
var DownLeftTeeVector = "‚•û";
var DownLeftVector = "‚ÜΩ";
var DownLeftVectorBar = "‚•ñ";
var DownRightTeeVector = "‚•ü";
var DownRightVector = "‚áÅ";
var DownRightVectorBar = "‚•ó";
var DownTee = "‚ä§";
var DownTeeArrow = "‚Üß";
var Downarrow = "‚áì";
var Dscr = "ùíü";
var Dstrok = "ƒê";
var ENG = "≈ä";
var ET = "√ê";
var ETH = "√ê";
var Eacut = "√â";
var Eacute = "√â";
var Ecaron = "ƒö";
var Ecir = "√ä";
var Ecirc = "√ä";
var Ecy = "–≠";
var Edot = "ƒñ";
var Efr = "ùîà";
var Egrav = "√à";
var Egrave = "√à";
var Element = "‚àà";
var Emacr = "ƒí";
var EmptySmallSquare = "‚óª";
var EmptyVerySmallSquare = "‚ñ´";
var Eogon = "ƒò";
var Eopf = "ùîº";
var Epsilon = "Œï";
var Equal = "‚©µ";
var EqualTilde = "‚âÇ";
var Equilibrium = "‚áå";
var Escr = "‚Ñ∞";
var Esim = "‚©≥";
var Eta = "Œó";
var Eum = "√ã";
var Euml = "√ã";
var Exists = "‚àÉ";
var ExponentialE = "‚Öá";
var Fcy = "–§";
var Ffr = "ùîâ";
var FilledSmallSquare = "‚óº";
var FilledVerySmallSquare = "‚ñ™";
var Fopf = "ùîΩ";
var ForAll = "‚àÄ";
var Fouriertrf = "‚Ñ±";
var Fscr = "‚Ñ±";
var GJcy = "–É";
var G = ">";
var GT = ">";
var Gamma = "Œì";
var Gammad = "œú";
var Gbreve = "ƒû";
var Gcedil = "ƒ¢";
var Gcirc = "ƒú";
var Gcy = "–ì";
var Gdot = "ƒ†";
var Gfr = "ùîä";
var Gg = "‚ãô";
var Gopf = "ùîæ";
var GreaterEqual = "‚â•";
var GreaterEqualLess = "‚ãõ";
var GreaterFullEqual = "‚âß";
var GreaterGreater = "‚™¢";
var GreaterLess = "‚â∑";
var GreaterSlantEqual = "‚©æ";
var GreaterTilde = "‚â≥";
var Gscr = "ùí¢";
var Gt = "‚â´";
var HARDcy = "–™";
var Hacek = "Àá";
var Hat = "^";
var Hcirc = "ƒ§";
var Hfr = "‚Ñå";
var HilbertSpace = "‚Ñã";
var Hopf = "‚Ñç";
var HorizontalLine = "‚îÄ";
var Hscr = "‚Ñã";
var Hstrok = "ƒ¶";
var HumpDownHump = "‚âé";
var HumpEqual = "‚âè";
var IEcy = "–ï";
var IJlig = "ƒ≤";
var IOcy = "–Å";
var Iacut = "√ç";
var Iacute = "√ç";
var Icir = "√é";
var Icirc = "√é";
var Icy = "–ò";
var Idot = "ƒ∞";
var Ifr = "‚Ñë";
var Igrav = "√å";
var Igrave = "√å";
var Im = "‚Ñë";
var Imacr = "ƒ™";
var ImaginaryI = "‚Öà";
var Implies = "‚áí";
var Int = "‚à¨";
var Integral = "‚à´";
var Intersection = "‚ãÇ";
var InvisibleComma = "‚Å£";
var InvisibleTimes = "‚Å¢";
var Iogon = "ƒÆ";
var Iopf = "ùïÄ";
var Iota = "Œô";
var Iscr = "‚Ñê";
var Itilde = "ƒ®";
var Iukcy = "–Ü";
var Ium = "√è";
var Iuml = "√è";
var Jcirc = "ƒ¥";
var Jcy = "–ô";
var Jfr = "ùîç";
var Jopf = "ùïÅ";
var Jscr = "ùí•";
var Jsercy = "–à";
var Jukcy = "–Ñ";
var KHcy = "–•";
var KJcy = "–å";
var Kappa = "Œö";
var Kcedil = "ƒ∂";
var Kcy = "–ö";
var Kfr = "ùîé";
var Kopf = "ùïÇ";
var Kscr = "ùí¶";
var LJcy = "–â";
var L = "<";
var LT = "<";
var Lacute = "ƒπ";
var Lambda = "Œõ";
var Lang = "‚ü™";
var Laplacetrf = "‚Ñí";
var Larr = "‚Üû";
var Lcaron = "ƒΩ";
var Lcedil = "ƒª";
var Lcy = "–õ";
var LeftAngleBracket = "‚ü®";
var LeftArrow = "‚Üê";
var LeftArrowBar = "‚á§";
var LeftArrowRightArrow = "‚áÜ";
var LeftCeiling = "‚åà";
var LeftDoubleBracket = "‚ü¶";
var LeftDownTeeVector = "‚•°";
var LeftDownVector = "‚áÉ";
var LeftDownVectorBar = "‚•ô";
var LeftFloor = "‚åä";
var LeftRightArrow = "‚Üî";
var LeftRightVector = "‚•é";
var LeftTee = "‚ä£";
var LeftTeeArrow = "‚Ü§";
var LeftTeeVector = "‚•ö";
var LeftTriangle = "‚ä≤";
var LeftTriangleBar = "‚ßè";
var LeftTriangleEqual = "‚ä¥";
var LeftUpDownVector = "‚•ë";
var LeftUpTeeVector = "‚•†";
var LeftUpVector = "‚Üø";
var LeftUpVectorBar = "‚•ò";
var LeftVector = "‚Üº";
var LeftVectorBar = "‚•í";
var Leftarrow = "‚áê";
var Leftrightarrow = "‚áî";
var LessEqualGreater = "‚ãö";
var LessFullEqual = "‚â¶";
var LessGreater = "‚â∂";
var LessLess = "‚™°";
var LessSlantEqual = "‚©Ω";
var LessTilde = "‚â≤";
var Lfr = "ùîè";
var Ll = "‚ãò";
var Lleftarrow = "‚áö";
var Lmidot = "ƒø";
var LongLeftArrow = "‚üµ";
var LongLeftRightArrow = "‚ü∑";
var LongRightArrow = "‚ü∂";
var Longleftarrow = "‚ü∏";
var Longleftrightarrow = "‚ü∫";
var Longrightarrow = "‚üπ";
var Lopf = "ùïÉ";
var LowerLeftArrow = "‚Üô";
var LowerRightArrow = "‚Üò";
var Lscr = "‚Ñí";
var Lsh = "‚Ü∞";
var Lstrok = "≈Å";
var Lt = "‚â™";
var Mcy = "–ú";
var MediumSpace = "‚Åü";
var Mellintrf = "‚Ñ≥";
var Mfr = "ùîê";
var MinusPlus = "‚àì";
var Mopf = "ùïÑ";
var Mscr = "‚Ñ≥";
var Mu = "Œú";
var NJcy = "–ä";
var Nacute = "≈É";
var Ncaron = "≈á";
var Ncedil = "≈Ö";
var Ncy = "–ù";
var NegativeMediumSpace = "‚Äã";
var NegativeThickSpace = "‚Äã";
var NegativeThinSpace = "‚Äã";
var NegativeVeryThinSpace = "‚Äã";
var NestedGreaterGreater = "‚â´";
var NestedLessLess = "‚â™";
var NewLine = "\n";
var Nfr = "ùîë";
var NoBreak = "‚Å†";
var NonBreakingSpace = "¬†";
var Nopf = "‚Ñï";
var Not = "‚´¨";
var NotCongruent = "‚â¢";
var NotCupCap = "‚â≠";
var NotDoubleVerticalBar = "‚à¶";
var NotElement = "‚àâ";
var NotEqual = "‚â†";
var NotEqualTilde = "‚âÇÃ∏";
var NotExists = "‚àÑ";
var NotGreater = "‚âØ";
var NotGreaterEqual = "‚â±";
var NotGreaterFullEqual = "‚âßÃ∏";
var NotGreaterGreater = "‚â´Ã∏";
var NotGreaterLess = "‚âπ";
var NotGreaterSlantEqual = "‚©æÃ∏";
var NotGreaterTilde = "‚âµ";
var NotHumpDownHump = "‚âéÃ∏";
var NotHumpEqual = "‚âèÃ∏";
var NotLeftTriangle = "‚ã™";
var NotLeftTriangleBar = "‚ßèÃ∏";
var NotLeftTriangleEqual = "‚ã¨";
var NotLess = "‚âÆ";
var NotLessEqual = "‚â∞";
var NotLessGreater = "‚â∏";
var NotLessLess = "‚â™Ã∏";
var NotLessSlantEqual = "‚©ΩÃ∏";
var NotLessTilde = "‚â¥";
var NotNestedGreaterGreater = "‚™¢Ã∏";
var NotNestedLessLess = "‚™°Ã∏";
var NotPrecedes = "‚äÄ";
var NotPrecedesEqual = "‚™ØÃ∏";
var NotPrecedesSlantEqual = "‚ã†";
var NotReverseElement = "‚àå";
var NotRightTriangle = "‚ã´";
var NotRightTriangleBar = "‚ßêÃ∏";
var NotRightTriangleEqual = "‚ã≠";
var NotSquareSubset = "‚äèÃ∏";
var NotSquareSubsetEqual = "‚ã¢";
var NotSquareSuperset = "‚äêÃ∏";
var NotSquareSupersetEqual = "‚ã£";
var NotSubset = "‚äÇ‚Éí";
var NotSubsetEqual = "‚äà";
var NotSucceeds = "‚äÅ";
var NotSucceedsEqual = "‚™∞Ã∏";
var NotSucceedsSlantEqual = "‚ã°";
var NotSucceedsTilde = "‚âøÃ∏";
var NotSuperset = "‚äÉ‚Éí";
var NotSupersetEqual = "‚äâ";
var NotTilde = "‚âÅ";
var NotTildeEqual = "‚âÑ";
var NotTildeFullEqual = "‚âá";
var NotTildeTilde = "‚ââ";
var NotVerticalBar = "‚à§";
var Nscr = "ùí©";
var Ntild = "√ë";
var Ntilde = "√ë";
var Nu = "Œù";
var OElig = "≈í";
var Oacut = "√ì";
var Oacute = "√ì";
var Ocir = "√î";
var Ocirc = "√î";
var Ocy = "–û";
var Odblac = "≈ê";
var Ofr = "ùîí";
var Ograv = "√í";
var Ograve = "√í";
var Omacr = "≈å";
var Omega = "Œ©";
var Omicron = "Œü";
var Oopf = "ùïÜ";
var OpenCurlyDoubleQuote = "‚Äú";
var OpenCurlyQuote = "‚Äò";
var Or = "‚©î";
var Oscr = "ùí™";
var Oslas = "√ò";
var Oslash = "√ò";
var Otild = "√ï";
var Otilde = "√ï";
var Otimes = "‚®∑";
var Oum = "√ñ";
var Ouml = "√ñ";
var OverBar = "‚Äæ";
var OverBrace = "‚èû";
var OverBracket = "‚é¥";
var OverParenthesis = "‚èú";
var PartialD = "‚àÇ";
var Pcy = "–ü";
var Pfr = "ùîì";
var Phi = "Œ¶";
var Pi = "Œ†";
var PlusMinus = "¬±";
var Poincareplane = "‚Ñå";
var Popf = "‚Ñô";
var Pr = "‚™ª";
var Precedes = "‚â∫";
var PrecedesEqual = "‚™Ø";
var PrecedesSlantEqual = "‚âº";
var PrecedesTilde = "‚âæ";
var Prime = "‚Ä≥";
var Product = "‚àè";
var Proportion = "‚à∑";
var Proportional = "‚àù";
var Pscr = "ùí´";
var Psi = "Œ®";
var QUO = "\"";
var QUOT = "\"";
var Qfr = "ùîî";
var Qopf = "‚Ñö";
var Qscr = "ùí¨";
var RBarr = "‚§ê";
var RE = "¬Æ";
var REG = "¬Æ";
var Racute = "≈î";
var Rang = "‚ü´";
var Rarr = "‚Ü†";
var Rarrtl = "‚§ñ";
var Rcaron = "≈ò";
var Rcedil = "≈ñ";
var Rcy = "–†";
var Re = "‚Ñú";
var ReverseElement = "‚àã";
var ReverseEquilibrium = "‚áã";
var ReverseUpEquilibrium = "‚•Ø";
var Rfr = "‚Ñú";
var Rho = "Œ°";
var RightAngleBracket = "‚ü©";
var RightArrow = "‚Üí";
var RightArrowBar = "‚á•";
var RightArrowLeftArrow = "‚áÑ";
var RightCeiling = "‚åâ";
var RightDoubleBracket = "‚üß";
var RightDownTeeVector = "‚•ù";
var RightDownVector = "‚áÇ";
var RightDownVectorBar = "‚•ï";
var RightFloor = "‚åã";
var RightTee = "‚ä¢";
var RightTeeArrow = "‚Ü¶";
var RightTeeVector = "‚•õ";
var RightTriangle = "‚ä≥";
var RightTriangleBar = "‚ßê";
var RightTriangleEqual = "‚äµ";
var RightUpDownVector = "‚•è";
var RightUpTeeVector = "‚•ú";
var RightUpVector = "‚Üæ";
var RightUpVectorBar = "‚•î";
var RightVector = "‚áÄ";
var RightVectorBar = "‚•ì";
var Rightarrow = "‚áí";
var Ropf = "‚Ñù";
var RoundImplies = "‚•∞";
var Rrightarrow = "‚áõ";
var Rscr = "‚Ñõ";
var Rsh = "‚Ü±";
var RuleDelayed = "‚ß¥";
var SHCHcy = "–©";
var SHcy = "–®";
var SOFTcy = "–¨";
var Sacute = "≈ö";
var Sc = "‚™º";
var Scaron = "≈†";
var Scedil = "≈û";
var Scirc = "≈ú";
var Scy = "–°";
var Sfr = "ùîñ";
var ShortDownArrow = "‚Üì";
var ShortLeftArrow = "‚Üê";
var ShortRightArrow = "‚Üí";
var ShortUpArrow = "‚Üë";
var Sigma = "Œ£";
var SmallCircle = "‚àò";
var Sopf = "ùïä";
var Sqrt = "‚àö";
var Square = "‚ñ°";
var SquareIntersection = "‚äì";
var SquareSubset = "‚äè";
var SquareSubsetEqual = "‚äë";
var SquareSuperset = "‚äê";
var SquareSupersetEqual = "‚äí";
var SquareUnion = "‚äî";
var Sscr = "ùíÆ";
var Star = "‚ãÜ";
var Sub = "‚ãê";
var Subset = "‚ãê";
var SubsetEqual = "‚äÜ";
var Succeeds = "‚âª";
var SucceedsEqual = "‚™∞";
var SucceedsSlantEqual = "‚âΩ";
var SucceedsTilde = "‚âø";
var SuchThat = "‚àã";
var Sum = "‚àë";
var Sup = "‚ãë";
var Superset = "‚äÉ";
var SupersetEqual = "‚äá";
var Supset = "‚ãë";
var THOR = "√û";
var THORN = "√û";
var TRADE = "‚Ñ¢";
var TSHcy = "–ã";
var TScy = "–¶";
var Tab = "\t";
var Tau = "Œ§";
var Tcaron = "≈§";
var Tcedil = "≈¢";
var Tcy = "–¢";
var Tfr = "ùîó";
var Therefore = "‚à¥";
var Theta = "Œò";
var ThickSpace = "‚Åü‚Ää";
var ThinSpace = "‚Äâ";
var Tilde = "‚àº";
var TildeEqual = "‚âÉ";
var TildeFullEqual = "‚âÖ";
var TildeTilde = "‚âà";
var Topf = "ùïã";
var TripleDot = "‚Éõ";
var Tscr = "ùíØ";
var Tstrok = "≈¶";
var Uacut = "√ö";
var Uacute = "√ö";
var Uarr = "‚Üü";
var Uarrocir = "‚•â";
var Ubrcy = "–é";
var Ubreve = "≈¨";
var Ucir = "√õ";
var Ucirc = "√õ";
var Ucy = "–£";
var Udblac = "≈∞";
var Ufr = "ùîò";
var Ugrav = "√ô";
var Ugrave = "√ô";
var Umacr = "≈™";
var UnderBar = "_";
var UnderBrace = "‚èü";
var UnderBracket = "‚éµ";
var UnderParenthesis = "‚èù";
var Union = "‚ãÉ";
var UnionPlus = "‚äé";
var Uogon = "≈≤";
var Uopf = "ùïå";
var UpArrow = "‚Üë";
var UpArrowBar = "‚§í";
var UpArrowDownArrow = "‚áÖ";
var UpDownArrow = "‚Üï";
var UpEquilibrium = "‚•Æ";
var UpTee = "‚ä•";
var UpTeeArrow = "‚Ü•";
var Uparrow = "‚áë";
var Updownarrow = "‚áï";
var UpperLeftArrow = "‚Üñ";
var UpperRightArrow = "‚Üó";
var Upsi = "œí";
var Upsilon = "Œ•";
var Uring = "≈Æ";
var Uscr = "ùí∞";
var Utilde = "≈®";
var Uum = "√ú";
var Uuml = "√ú";
var VDash = "‚ä´";
var Vbar = "‚´´";
var Vcy = "–í";
var Vdash = "‚ä©";
var Vdashl = "‚´¶";
var Vee = "‚ãÅ";
var Verbar = "‚Äñ";
var Vert = "‚Äñ";
var VerticalBar = "‚à£";
var VerticalLine = "|";
var VerticalSeparator = "‚ùò";
var VerticalTilde = "‚âÄ";
var VeryThinSpace = "‚Ää";
var Vfr = "ùîô";
var Vopf = "ùïç";
var Vscr = "ùí±";
var Vvdash = "‚ä™";
var Wcirc = "≈¥";
var Wedge = "‚ãÄ";
var Wfr = "ùîö";
var Wopf = "ùïé";
var Wscr = "ùí≤";
var Xfr = "ùîõ";
var Xi = "Œû";
var Xopf = "ùïè";
var Xscr = "ùí≥";
var YAcy = "–Ø";
var YIcy = "–á";
var YUcy = "–Æ";
var Yacut = "√ù";
var Yacute = "√ù";
var Ycirc = "≈∂";
var Ycy = "–´";
var Yfr = "ùîú";
var Yopf = "ùïê";
var Yscr = "ùí¥";
var Yuml = "≈∏";
var ZHcy = "–ñ";
var Zacute = "≈π";
var Zcaron = "≈Ω";
var Zcy = "–ó";
var Zdot = "≈ª";
var ZeroWidthSpace = "‚Äã";
var Zeta = "Œñ";
var Zfr = "‚Ñ®";
var Zopf = "‚Ñ§";
var Zscr = "ùíµ";
var aacut = "√°";
var aacute = "√°";
var abreve = "ƒÉ";
var ac = "‚àæ";
var acE = "‚àæÃ≥";
var acd = "‚àø";
var acir = "√¢";
var acirc = "√¢";
var acut = "¬¥";
var acute = "¬¥";
var acy = "–∞";
var aeli = "√¶";
var aelig = "√¶";
var af = "‚Å°";
var afr = "ùîû";
var agrav = "√†";
var agrave = "√†";
var alefsym = "‚Ñµ";
var aleph = "‚Ñµ";
var alpha = "Œ±";
var amacr = "ƒÅ";
var amalg = "‚®ø";
var am = "&";
var amp = "&";
var and = "‚àß";
var andand = "‚©ï";
var andd = "‚©ú";
var andslope = "‚©ò";
var andv = "‚©ö";
var ang = "‚à†";
var ange = "‚¶§";
var angle = "‚à†";
var angmsd = "‚à°";
var angmsdaa = "‚¶®";
var angmsdab = "‚¶©";
var angmsdac = "‚¶™";
var angmsdad = "‚¶´";
var angmsdae = "‚¶¨";
var angmsdaf = "‚¶≠";
var angmsdag = "‚¶Æ";
var angmsdah = "‚¶Ø";
var angrt = "‚àü";
var angrtvb = "‚äæ";
var angrtvbd = "‚¶ù";
var angsph = "‚à¢";
var angst = "√Ö";
var angzarr = "‚çº";
var aogon = "ƒÖ";
var aopf = "ùïí";
var ap = "‚âà";
var apE = "‚©∞";
var apacir = "‚©Ø";
var ape = "‚âä";
var apid = "‚âã";
var apos = "'";
var approx = "‚âà";
var approxeq = "‚âä";
var arin = "√•";
var aring = "√•";
var ascr = "ùí∂";
var ast = "*";
var asymp = "‚âà";
var asympeq = "‚âç";
var atild = "√£";
var atilde = "√£";
var aum = "√§";
var auml = "√§";
var awconint = "‚à≥";
var awint = "‚®ë";
var bNot = "‚´≠";
var backcong = "‚âå";
var backepsilon = "œ∂";
var backprime = "‚Äµ";
var backsim = "‚àΩ";
var backsimeq = "‚ãç";
var barvee = "‚äΩ";
var barwed = "‚åÖ";
var barwedge = "‚åÖ";
var bbrk = "‚éµ";
var bbrktbrk = "‚é∂";
var bcong = "‚âå";
var bcy = "–±";
var bdquo = "‚Äû";
var becaus = "‚àµ";
var because = "‚àµ";
var bemptyv = "‚¶∞";
var bepsi = "œ∂";
var bernou = "‚Ñ¨";
var beta = "Œ≤";
var beth = "‚Ñ∂";
var between = "‚â¨";
var bfr = "ùîü";
var bigcap = "‚ãÇ";
var bigcirc = "‚óØ";
var bigcup = "‚ãÉ";
var bigodot = "‚®Ä";
var bigoplus = "‚®Å";
var bigotimes = "‚®Ç";
var bigsqcup = "‚®Ü";
var bigstar = "‚òÖ";
var bigtriangledown = "‚ñΩ";
var bigtriangleup = "‚ñ≥";
var biguplus = "‚®Ñ";
var bigvee = "‚ãÅ";
var bigwedge = "‚ãÄ";
var bkarow = "‚§ç";
var blacklozenge = "‚ß´";
var blacksquare = "‚ñ™";
var blacktriangle = "‚ñ¥";
var blacktriangledown = "‚ñæ";
var blacktriangleleft = "‚óÇ";
var blacktriangleright = "‚ñ∏";
var blank = "‚ê£";
var blk12 = "‚ñí";
var blk14 = "‚ñë";
var blk34 = "‚ñì";
var block = "‚ñà";
var bne = "=‚É•";
var bnequiv = "‚â°‚É•";
var bnot = "‚åê";
var bopf = "ùïì";
var bot = "‚ä•";
var bottom = "‚ä•";
var bowtie = "‚ãà";
var boxDL = "‚ïó";
var boxDR = "‚ïî";
var boxDl = "‚ïñ";
var boxDr = "‚ïì";
var boxH = "‚ïê";
var boxHD = "‚ï¶";
var boxHU = "‚ï©";
var boxHd = "‚ï§";
var boxHu = "‚ïß";
var boxUL = "‚ïù";
var boxUR = "‚ïö";
var boxUl = "‚ïú";
var boxUr = "‚ïô";
var boxV = "‚ïë";
var boxVH = "‚ï¨";
var boxVL = "‚ï£";
var boxVR = "‚ï†";
var boxVh = "‚ï´";
var boxVl = "‚ï¢";
var boxVr = "‚ïü";
var boxbox = "‚ßâ";
var boxdL = "‚ïï";
var boxdR = "‚ïí";
var boxdl = "‚îê";
var boxdr = "‚îå";
var boxh = "‚îÄ";
var boxhD = "‚ï•";
var boxhU = "‚ï®";
var boxhd = "‚î¨";
var boxhu = "‚î¥";
var boxminus = "‚äü";
var boxplus = "‚äû";
var boxtimes = "‚ä†";
var boxuL = "‚ïõ";
var boxuR = "‚ïò";
var boxul = "‚îò";
var boxur = "‚îî";
var boxv = "‚îÇ";
var boxvH = "‚ï™";
var boxvL = "‚ï°";
var boxvR = "‚ïû";
var boxvh = "‚îº";
var boxvl = "‚î§";
var boxvr = "‚îú";
var bprime = "‚Äµ";
var breve = "Àò";
var brvba = "¬¶";
var brvbar = "¬¶";
var bscr = "ùí∑";
var bsemi = "‚Åè";
var bsim = "‚àΩ";
var bsime = "‚ãç";
var bsol = "\\";
var bsolb = "‚ßÖ";
var bsolhsub = "‚üà";
var bull = "‚Ä¢";
var bullet = "‚Ä¢";
var bump = "‚âé";
var bumpE = "‚™Æ";
var bumpe = "‚âè";
var bumpeq = "‚âè";
var cacute = "ƒá";
var cap = "‚à©";
var capand = "‚©Ñ";
var capbrcup = "‚©â";
var capcap = "‚©ã";
var capcup = "‚©á";
var capdot = "‚©Ä";
var caps = "‚à©Ô∏Ä";
var caret = "‚ÅÅ";
var caron = "Àá";
var ccaps = "‚©ç";
var ccaron = "ƒç";
var ccedi = "√ß";
var ccedil = "√ß";
var ccirc = "ƒâ";
var ccups = "‚©å";
var ccupssm = "‚©ê";
var cdot = "ƒã";
var cedi = "¬∏";
var cedil = "¬∏";
var cemptyv = "‚¶≤";
var cen = "¬¢";
var cent = "¬¢";
var centerdot = "¬∑";
var cfr = "ùî†";
var chcy = "—á";
var check = "‚úì";
var checkmark = "‚úì";
var chi = "œá";
var cir = "‚óã";
var cirE = "‚ßÉ";
var circ = "ÀÜ";
var circeq = "‚âó";
var circlearrowleft = "‚Ü∫";
var circlearrowright = "‚Üª";
var circledR = "¬Æ";
var circledS = "‚ìà";
var circledast = "‚äõ";
var circledcirc = "‚äö";
var circleddash = "‚äù";
var cire = "‚âó";
var cirfnint = "‚®ê";
var cirmid = "‚´Ø";
var cirscir = "‚ßÇ";
var clubs = "‚ô£";
var clubsuit = "‚ô£";
var colon = ":";
var colone = "‚âî";
var coloneq = "‚âî";
var comma = ",";
var commat = "@";
var comp = "‚àÅ";
var compfn = "‚àò";
var complement = "‚àÅ";
var complexes = "‚ÑÇ";
var cong = "‚âÖ";
var congdot = "‚©≠";
var conint = "‚àÆ";
var copf = "ùïî";
var coprod = "‚àê";
var cop = "¬©";
var copy = "¬©";
var copysr = "‚Ñó";
var crarr = "‚Üµ";
var cross = "‚úó";
var cscr = "ùí∏";
var csub = "‚´è";
var csube = "‚´ë";
var csup = "‚´ê";
var csupe = "‚´í";
var ctdot = "‚ãØ";
var cudarrl = "‚§∏";
var cudarrr = "‚§µ";
var cuepr = "‚ãû";
var cuesc = "‚ãü";
var cularr = "‚Ü∂";
var cularrp = "‚§Ω";
var cup = "‚à™";
var cupbrcap = "‚©à";
var cupcap = "‚©Ü";
var cupcup = "‚©ä";
var cupdot = "‚äç";
var cupor = "‚©Ö";
var cups = "‚à™Ô∏Ä";
var curarr = "‚Ü∑";
var curarrm = "‚§º";
var curlyeqprec = "‚ãû";
var curlyeqsucc = "‚ãü";
var curlyvee = "‚ãé";
var curlywedge = "‚ãè";
var curre = "¬§";
var curren = "¬§";
var curvearrowleft = "‚Ü∂";
var curvearrowright = "‚Ü∑";
var cuvee = "‚ãé";
var cuwed = "‚ãè";
var cwconint = "‚à≤";
var cwint = "‚à±";
var cylcty = "‚å≠";
var dArr = "‚áì";
var dHar = "‚••";
var dagger = "‚Ä†";
var daleth = "‚Ñ∏";
var darr = "‚Üì";
var dash = "‚Äê";
var dashv = "‚ä£";
var dbkarow = "‚§è";
var dblac = "Àù";
var dcaron = "ƒè";
var dcy = "–¥";
var dd = "‚ÖÜ";
var ddagger = "‚Ä°";
var ddarr = "‚áä";
var ddotseq = "‚©∑";
var de = "¬∞";
var deg = "¬∞";
var delta = "Œ¥";
var demptyv = "‚¶±";
var dfisht = "‚•ø";
var dfr = "ùî°";
var dharl = "‚áÉ";
var dharr = "‚áÇ";
var diam = "‚ãÑ";
var diamond = "‚ãÑ";
var diamondsuit = "‚ô¶";
var diams = "‚ô¶";
var die = "¬®";
var digamma = "œù";
var disin = "‚ã≤";
var div = "√∑";
var divid = "√∑";
var divide = "√∑";
var divideontimes = "‚ãá";
var divonx = "‚ãá";
var djcy = "—í";
var dlcorn = "‚åû";
var dlcrop = "‚åç";
var dollar = "$";
var dopf = "ùïï";
var dot = "Àô";
var doteq = "‚âê";
var doteqdot = "‚âë";
var dotminus = "‚à∏";
var dotplus = "‚àî";
var dotsquare = "‚ä°";
var doublebarwedge = "‚åÜ";
var downarrow = "‚Üì";
var downdownarrows = "‚áä";
var downharpoonleft = "‚áÉ";
var downharpoonright = "‚áÇ";
var drbkarow = "‚§ê";
var drcorn = "‚åü";
var drcrop = "‚åå";
var dscr = "ùíπ";
var dscy = "—ï";
var dsol = "‚ß∂";
var dstrok = "ƒë";
var dtdot = "‚ã±";
var dtri = "‚ñø";
var dtrif = "‚ñæ";
var duarr = "‚áµ";
var duhar = "‚•Ø";
var dwangle = "‚¶¶";
var dzcy = "—ü";
var dzigrarr = "‚üø";
var eDDot = "‚©∑";
var eDot = "‚âë";
var eacut = "√©";
var eacute = "√©";
var easter = "‚©Æ";
var ecaron = "ƒõ";
var ecir = "√™";
var ecirc = "√™";
var ecolon = "‚âï";
var ecy = "—ç";
var edot = "ƒó";
var ee = "‚Öá";
var efDot = "‚âí";
var efr = "ùî¢";
var eg = "‚™ö";
var egrav = "√®";
var egrave = "√®";
var egs = "‚™ñ";
var egsdot = "‚™ò";
var el = "‚™ô";
var elinters = "‚èß";
var ell = "‚Ñì";
var els = "‚™ï";
var elsdot = "‚™ó";
var emacr = "ƒì";
var empty = "‚àÖ";
var emptyset = "‚àÖ";
var emptyv = "‚àÖ";
var emsp13 = "‚ÄÑ";
var emsp14 = "‚ÄÖ";
var emsp = "‚ÄÉ";
var eng = "≈ã";
var ensp = "‚ÄÇ";
var eogon = "ƒô";
var eopf = "ùïñ";
var epar = "‚ãï";
var eparsl = "‚ß£";
var eplus = "‚©±";
var epsi = "Œµ";
var epsilon = "Œµ";
var epsiv = "œµ";
var eqcirc = "‚âñ";
var eqcolon = "‚âï";
var eqsim = "‚âÇ";
var eqslantgtr = "‚™ñ";
var eqslantless = "‚™ï";
var equals = "=";
var equest = "‚âü";
var equiv = "‚â°";
var equivDD = "‚©∏";
var eqvparsl = "‚ß•";
var erDot = "‚âì";
var erarr = "‚•±";
var escr = "‚ÑØ";
var esdot = "‚âê";
var esim = "‚âÇ";
var eta = "Œ∑";
var et = "√∞";
var eth = "√∞";
var eum = "√´";
var euml = "√´";
var euro = "‚Ç¨";
var excl = "!";
var exist = "‚àÉ";
var expectation = "‚Ñ∞";
var exponentiale = "‚Öá";
var fallingdotseq = "‚âí";
var fcy = "—Ñ";
var female = "‚ôÄ";
var ffilig = "Ô¨É";
var fflig = "Ô¨Ä";
var ffllig = "Ô¨Ñ";
var ffr = "ùî£";
var filig = "Ô¨Å";
var fjlig = "fj";
var flat = "‚ô≠";
var fllig = "Ô¨Ç";
var fltns = "‚ñ±";
var fnof = "∆í";
var fopf = "ùïó";
var forall = "‚àÄ";
var fork = "‚ãî";
var forkv = "‚´ô";
var fpartint = "‚®ç";
var frac1 = "¬º";
var frac12 = "¬Ω";
var frac13 = "‚Öì";
var frac14 = "¬º";
var frac15 = "‚Öï";
var frac16 = "‚Öô";
var frac18 = "‚Öõ";
var frac23 = "‚Öî";
var frac25 = "‚Öñ";
var frac3 = "¬æ";
var frac34 = "¬æ";
var frac35 = "‚Öó";
var frac38 = "‚Öú";
var frac45 = "‚Öò";
var frac56 = "‚Öö";
var frac58 = "‚Öù";
var frac78 = "‚Öû";
var frasl = "‚ÅÑ";
var frown = "‚å¢";
var fscr = "ùíª";
var gE = "‚âß";
var gEl = "‚™å";
var gacute = "«µ";
var gamma = "Œ≥";
var gammad = "œù";
var gap = "‚™Ü";
var gbreve = "ƒü";
var gcirc = "ƒù";
var gcy = "–≥";
var gdot = "ƒ°";
var ge = "‚â•";
var gel = "‚ãõ";
var geq = "‚â•";
var geqq = "‚âß";
var geqslant = "‚©æ";
var ges = "‚©æ";
var gescc = "‚™©";
var gesdot = "‚™Ä";
var gesdoto = "‚™Ç";
var gesdotol = "‚™Ñ";
var gesl = "‚ãõÔ∏Ä";
var gesles = "‚™î";
var gfr = "ùî§";
var gg = "‚â´";
var ggg = "‚ãô";
var gimel = "‚Ñ∑";
var gjcy = "—ì";
var gl = "‚â∑";
var glE = "‚™í";
var gla = "‚™•";
var glj = "‚™§";
var gnE = "‚â©";
var gnap = "‚™ä";
var gnapprox = "‚™ä";
var gne = "‚™à";
var gneq = "‚™à";
var gneqq = "‚â©";
var gnsim = "‚ãß";
var gopf = "ùïò";
var grave = "`";
var gscr = "‚Ñä";
var gsim = "‚â≥";
var gsime = "‚™é";
var gsiml = "‚™ê";
var g = ">";
var gt = ">";
var gtcc = "‚™ß";
var gtcir = "‚©∫";
var gtdot = "‚ãó";
var gtlPar = "‚¶ï";
var gtquest = "‚©º";
var gtrapprox = "‚™Ü";
var gtrarr = "‚•∏";
var gtrdot = "‚ãó";
var gtreqless = "‚ãõ";
var gtreqqless = "‚™å";
var gtrless = "‚â∑";
var gtrsim = "‚â≥";
var gvertneqq = "‚â©Ô∏Ä";
var gvnE = "‚â©Ô∏Ä";
var hArr = "‚áî";
var hairsp = "‚Ää";
var half = "¬Ω";
var hamilt = "‚Ñã";
var hardcy = "—ä";
var harr = "‚Üî";
var harrcir = "‚•à";
var harrw = "‚Ü≠";
var hbar = "‚Ñè";
var hcirc = "ƒ•";
var hearts = "‚ô•";
var heartsuit = "‚ô•";
var hellip = "‚Ä¶";
var hercon = "‚äπ";
var hfr = "ùî•";
var hksearow = "‚§•";
var hkswarow = "‚§¶";
var hoarr = "‚áø";
var homtht = "‚àª";
var hookleftarrow = "‚Ü©";
var hookrightarrow = "‚Ü™";
var hopf = "ùïô";
var horbar = "‚Äï";
var hscr = "ùíΩ";
var hslash = "‚Ñè";
var hstrok = "ƒß";
var hybull = "‚ÅÉ";
var hyphen = "‚Äê";
var iacut = "√≠";
var iacute = "√≠";
var ic = "‚Å£";
var icir = "√Æ";
var icirc = "√Æ";
var icy = "–∏";
var iecy = "–µ";
var iexc = "¬°";
var iexcl = "¬°";
var iff = "‚áî";
var ifr = "ùî¶";
var igrav = "√¨";
var igrave = "√¨";
var ii = "‚Öà";
var iiiint = "‚®å";
var iiint = "‚à≠";
var iinfin = "‚ßú";
var iiota = "‚Ñ©";
var ijlig = "ƒ≥";
var imacr = "ƒ´";
var image = "‚Ñë";
var imagline = "‚Ñê";
var imagpart = "‚Ñë";
var imath = "ƒ±";
var imof = "‚ä∑";
var imped = "∆µ";
var incare = "‚ÑÖ";
var infin = "‚àû";
var infintie = "‚ßù";
var inodot = "ƒ±";
var int = "‚à´";
var intcal = "‚ä∫";
var integers = "‚Ñ§";
var intercal = "‚ä∫";
var intlarhk = "‚®ó";
var intprod = "‚®º";
var iocy = "—ë";
var iogon = "ƒØ";
var iopf = "ùïö";
var iota = "Œπ";
var iprod = "‚®º";
var iques = "¬ø";
var iquest = "¬ø";
var iscr = "ùíæ";
var isin = "‚àà";
var isinE = "‚ãπ";
var isindot = "‚ãµ";
var isins = "‚ã¥";
var isinsv = "‚ã≥";
var isinv = "‚àà";
var it = "‚Å¢";
var itilde = "ƒ©";
var iukcy = "—ñ";
var ium = "√Ø";
var iuml = "√Ø";
var jcirc = "ƒµ";
var jcy = "–π";
var jfr = "ùîß";
var jmath = "»∑";
var jopf = "ùïõ";
var jscr = "ùíø";
var jsercy = "—ò";
var jukcy = "—î";
var kappa = "Œ∫";
var kappav = "œ∞";
var kcedil = "ƒ∑";
var kcy = "–∫";
var kfr = "ùî®";
var kgreen = "ƒ∏";
var khcy = "—Ö";
var kjcy = "—ú";
var kopf = "ùïú";
var kscr = "ùìÄ";
var lAarr = "‚áö";
var lArr = "‚áê";
var lAtail = "‚§õ";
var lBarr = "‚§é";
var lE = "‚â¶";
var lEg = "‚™ã";
var lHar = "‚•¢";
var lacute = "ƒ∫";
var laemptyv = "‚¶¥";
var lagran = "‚Ñí";
var lambda = "Œª";
var lang = "‚ü®";
var langd = "‚¶ë";
var langle = "‚ü®";
var lap = "‚™Ö";
var laqu = "¬´";
var laquo = "¬´";
var larr = "‚Üê";
var larrb = "‚á§";
var larrbfs = "‚§ü";
var larrfs = "‚§ù";
var larrhk = "‚Ü©";
var larrlp = "‚Ü´";
var larrpl = "‚§π";
var larrsim = "‚•≥";
var larrtl = "‚Ü¢";
var lat = "‚™´";
var latail = "‚§ô";
var late = "‚™≠";
var lates = "‚™≠Ô∏Ä";
var lbarr = "‚§å";
var lbbrk = "‚ù≤";
var lbrace = "{";
var lbrack = "[";
var lbrke = "‚¶ã";
var lbrksld = "‚¶è";
var lbrkslu = "‚¶ç";
var lcaron = "ƒæ";
var lcedil = "ƒº";
var lceil = "‚åà";
var lcub = "{";
var lcy = "–ª";
var ldca = "‚§∂";
var ldquo = "‚Äú";
var ldquor = "‚Äû";
var ldrdhar = "‚•ß";
var ldrushar = "‚•ã";
var ldsh = "‚Ü≤";
var le = "‚â§";
var leftarrow = "‚Üê";
var leftarrowtail = "‚Ü¢";
var leftharpoondown = "‚ÜΩ";
var leftharpoonup = "‚Üº";
var leftleftarrows = "‚áá";
var leftrightarrow = "‚Üî";
var leftrightarrows = "‚áÜ";
var leftrightharpoons = "‚áã";
var leftrightsquigarrow = "‚Ü≠";
var leftthreetimes = "‚ãã";
var leg = "‚ãö";
var leq = "‚â§";
var leqq = "‚â¶";
var leqslant = "‚©Ω";
var les = "‚©Ω";
var lescc = "‚™®";
var lesdot = "‚©ø";
var lesdoto = "‚™Å";
var lesdotor = "‚™É";
var lesg = "‚ãöÔ∏Ä";
var lesges = "‚™ì";
var lessapprox = "‚™Ö";
var lessdot = "‚ãñ";
var lesseqgtr = "‚ãö";
var lesseqqgtr = "‚™ã";
var lessgtr = "‚â∂";
var lesssim = "‚â≤";
var lfisht = "‚•º";
var lfloor = "‚åä";
var lfr = "ùî©";
var lg = "‚â∂";
var lgE = "‚™ë";
var lhard = "‚ÜΩ";
var lharu = "‚Üº";
var lharul = "‚•™";
var lhblk = "‚ñÑ";
var ljcy = "—ô";
var ll = "‚â™";
var llarr = "‚áá";
var llcorner = "‚åû";
var llhard = "‚•´";
var lltri = "‚ó∫";
var lmidot = "≈Ä";
var lmoust = "‚é∞";
var lmoustache = "‚é∞";
var lnE = "‚â®";
var lnap = "‚™â";
var lnapprox = "‚™â";
var lne = "‚™á";
var lneq = "‚™á";
var lneqq = "‚â®";
var lnsim = "‚ã¶";
var loang = "‚ü¨";
var loarr = "‚áΩ";
var lobrk = "‚ü¶";
var longleftarrow = "‚üµ";
var longleftrightarrow = "‚ü∑";
var longmapsto = "‚üº";
var longrightarrow = "‚ü∂";
var looparrowleft = "‚Ü´";
var looparrowright = "‚Ü¨";
var lopar = "‚¶Ö";
var lopf = "ùïù";
var loplus = "‚®≠";
var lotimes = "‚®¥";
var lowast = "‚àó";
var lowbar = "_";
var loz = "‚óä";
var lozenge = "‚óä";
var lozf = "‚ß´";
var lpar = "(";
var lparlt = "‚¶ì";
var lrarr = "‚áÜ";
var lrcorner = "‚åü";
var lrhar = "‚áã";
var lrhard = "‚•≠";
var lrm = "‚Äé";
var lrtri = "‚äø";
var lsaquo = "‚Äπ";
var lscr = "ùìÅ";
var lsh = "‚Ü∞";
var lsim = "‚â≤";
var lsime = "‚™ç";
var lsimg = "‚™è";
var lsqb = "[";
var lsquo = "‚Äò";
var lsquor = "‚Äö";
var lstrok = "≈Ç";
var l = "<";
var lt = "<";
var ltcc = "‚™¶";
var ltcir = "‚©π";
var ltdot = "‚ãñ";
var lthree = "‚ãã";
var ltimes = "‚ãâ";
var ltlarr = "‚•∂";
var ltquest = "‚©ª";
var ltrPar = "‚¶ñ";
var ltri = "‚óÉ";
var ltrie = "‚ä¥";
var ltrif = "‚óÇ";
var lurdshar = "‚•ä";
var luruhar = "‚•¶";
var lvertneqq = "‚â®Ô∏Ä";
var lvnE = "‚â®Ô∏Ä";
var mDDot = "‚à∫";
var mac = "¬Ø";
var macr = "¬Ø";
var male = "‚ôÇ";
var malt = "‚ú†";
var maltese = "‚ú†";
var map = "‚Ü¶";
var mapsto = "‚Ü¶";
var mapstodown = "‚Üß";
var mapstoleft = "‚Ü§";
var mapstoup = "‚Ü•";
var marker = "‚ñÆ";
var mcomma = "‚®©";
var mcy = "–º";
var mdash = "‚Äî";
var measuredangle = "‚à°";
var mfr = "ùî™";
var mho = "‚Ñß";
var micr = "¬µ";
var micro = "¬µ";
var mid = "‚à£";
var midast = "*";
var midcir = "‚´∞";
var middo = "¬∑";
var middot = "¬∑";
var minus = "‚àí";
var minusb = "‚äü";
var minusd = "‚à∏";
var minusdu = "‚®™";
var mlcp = "‚´õ";
var mldr = "‚Ä¶";
var mnplus = "‚àì";
var models = "‚äß";
var mopf = "ùïû";
var mp = "‚àì";
var mscr = "ùìÇ";
var mstpos = "‚àæ";
var mu = "Œº";
var multimap = "‚ä∏";
var mumap = "‚ä∏";
var nGg = "‚ãôÃ∏";
var nGt = "‚â´‚Éí";
var nGtv = "‚â´Ã∏";
var nLeftarrow = "‚áç";
var nLeftrightarrow = "‚áé";
var nLl = "‚ãòÃ∏";
var nLt = "‚â™‚Éí";
var nLtv = "‚â™Ã∏";
var nRightarrow = "‚áè";
var nVDash = "‚äØ";
var nVdash = "‚äÆ";
var nabla = "‚àá";
var nacute = "≈Ñ";
var nang = "‚à†‚Éí";
var nap = "‚ââ";
var napE = "‚©∞Ã∏";
var napid = "‚âãÃ∏";
var napos = "≈â";
var napprox = "‚ââ";
var natur = "‚ôÆ";
var natural = "‚ôÆ";
var naturals = "‚Ñï";
var nbs = "¬†";
var nbsp = "¬†";
var nbump = "‚âéÃ∏";
var nbumpe = "‚âèÃ∏";
var ncap = "‚©É";
var ncaron = "≈à";
var ncedil = "≈Ü";
var ncong = "‚âá";
var ncongdot = "‚©≠Ã∏";
var ncup = "‚©Ç";
var ncy = "–Ω";
var ndash = "‚Äì";
var ne = "‚â†";
var neArr = "‚áó";
var nearhk = "‚§§";
var nearr = "‚Üó";
var nearrow = "‚Üó";
var nedot = "‚âêÃ∏";
var nequiv = "‚â¢";
var nesear = "‚§®";
var nesim = "‚âÇÃ∏";
var nexist = "‚àÑ";
var nexists = "‚àÑ";
var nfr = "ùî´";
var ngE = "‚âßÃ∏";
var nge = "‚â±";
var ngeq = "‚â±";
var ngeqq = "‚âßÃ∏";
var ngeqslant = "‚©æÃ∏";
var nges = "‚©æÃ∏";
var ngsim = "‚âµ";
var ngt = "‚âØ";
var ngtr = "‚âØ";
var nhArr = "‚áé";
var nharr = "‚ÜÆ";
var nhpar = "‚´≤";
var ni = "‚àã";
var nis = "‚ãº";
var nisd = "‚ã∫";
var niv = "‚àã";
var njcy = "—ö";
var nlArr = "‚áç";
var nlE = "‚â¶Ã∏";
var nlarr = "‚Üö";
var nldr = "‚Ä•";
var nle = "‚â∞";
var nleftarrow = "‚Üö";
var nleftrightarrow = "‚ÜÆ";
var nleq = "‚â∞";
var nleqq = "‚â¶Ã∏";
var nleqslant = "‚©ΩÃ∏";
var nles = "‚©ΩÃ∏";
var nless = "‚âÆ";
var nlsim = "‚â¥";
var nlt = "‚âÆ";
var nltri = "‚ã™";
var nltrie = "‚ã¨";
var nmid = "‚à§";
var nopf = "ùïü";
var no = "¬¨";
var not = "¬¨";
var notin = "‚àâ";
var notinE = "‚ãπÃ∏";
var notindot = "‚ãµÃ∏";
var notinva = "‚àâ";
var notinvb = "‚ã∑";
var notinvc = "‚ã∂";
var notni = "‚àå";
var notniva = "‚àå";
var notnivb = "‚ãæ";
var notnivc = "‚ãΩ";
var npar = "‚à¶";
var nparallel = "‚à¶";
var nparsl = "‚´Ω‚É•";
var npart = "‚àÇÃ∏";
var npolint = "‚®î";
var npr = "‚äÄ";
var nprcue = "‚ã†";
var npre = "‚™ØÃ∏";
var nprec = "‚äÄ";
var npreceq = "‚™ØÃ∏";
var nrArr = "‚áè";
var nrarr = "‚Üõ";
var nrarrc = "‚§≥Ã∏";
var nrarrw = "‚ÜùÃ∏";
var nrightarrow = "‚Üõ";
var nrtri = "‚ã´";
var nrtrie = "‚ã≠";
var nsc = "‚äÅ";
var nsccue = "‚ã°";
var nsce = "‚™∞Ã∏";
var nscr = "ùìÉ";
var nshortmid = "‚à§";
var nshortparallel = "‚à¶";
var nsim = "‚âÅ";
var nsime = "‚âÑ";
var nsimeq = "‚âÑ";
var nsmid = "‚à§";
var nspar = "‚à¶";
var nsqsube = "‚ã¢";
var nsqsupe = "‚ã£";
var nsub = "‚äÑ";
var nsubE = "‚´ÖÃ∏";
var nsube = "‚äà";
var nsubset = "‚äÇ‚Éí";
var nsubseteq = "‚äà";
var nsubseteqq = "‚´ÖÃ∏";
var nsucc = "‚äÅ";
var nsucceq = "‚™∞Ã∏";
var nsup = "‚äÖ";
var nsupE = "‚´ÜÃ∏";
var nsupe = "‚äâ";
var nsupset = "‚äÉ‚Éí";
var nsupseteq = "‚äâ";
var nsupseteqq = "‚´ÜÃ∏";
var ntgl = "‚âπ";
var ntild = "√±";
var ntilde = "√±";
var ntlg = "‚â∏";
var ntriangleleft = "‚ã™";
var ntrianglelefteq = "‚ã¨";
var ntriangleright = "‚ã´";
var ntrianglerighteq = "‚ã≠";
var nu = "ŒΩ";
var num = "#";
var numero = "‚Ññ";
var numsp = "‚Äá";
var nvDash = "‚ä≠";
var nvHarr = "‚§Ñ";
var nvap = "‚âç‚Éí";
var nvdash = "‚ä¨";
var nvge = "‚â•‚Éí";
var nvgt = ">‚Éí";
var nvinfin = "‚ßû";
var nvlArr = "‚§Ç";
var nvle = "‚â§‚Éí";
var nvlt = "<‚Éí";
var nvltrie = "‚ä¥‚Éí";
var nvrArr = "‚§É";
var nvrtrie = "‚äµ‚Éí";
var nvsim = "‚àº‚Éí";
var nwArr = "‚áñ";
var nwarhk = "‚§£";
var nwarr = "‚Üñ";
var nwarrow = "‚Üñ";
var nwnear = "‚§ß";
var oS = "‚ìà";
var oacut = "√≥";
var oacute = "√≥";
var oast = "‚äõ";
var ocir = "√¥";
var ocirc = "√¥";
var ocy = "–æ";
var odash = "‚äù";
var odblac = "≈ë";
var odiv = "‚®∏";
var odot = "‚äô";
var odsold = "‚¶º";
var oelig = "≈ì";
var ofcir = "‚¶ø";
var ofr = "ùî¨";
var ogon = "Àõ";
var ograv = "√≤";
var ograve = "√≤";
var ogt = "‚ßÅ";
var ohbar = "‚¶µ";
var ohm = "Œ©";
var oint = "‚àÆ";
var olarr = "‚Ü∫";
var olcir = "‚¶æ";
var olcross = "‚¶ª";
var oline = "‚Äæ";
var olt = "‚ßÄ";
var omacr = "≈ç";
var omega = "œâ";
var omicron = "Œø";
var omid = "‚¶∂";
var ominus = "‚äñ";
var oopf = "ùï†";
var opar = "‚¶∑";
var operp = "‚¶π";
var oplus = "‚äï";
var or = "‚à®";
var orarr = "‚Üª";
var ord = "¬∫";
var order = "‚Ñ¥";
var orderof = "‚Ñ¥";
var ordf = "¬™";
var ordm = "¬∫";
var origof = "‚ä∂";
var oror = "‚©ñ";
var orslope = "‚©ó";
var orv = "‚©õ";
var oscr = "‚Ñ¥";
var oslas = "√∏";
var oslash = "√∏";
var osol = "‚äò";
var otild = "√µ";
var otilde = "√µ";
var otimes = "‚äó";
var otimesas = "‚®∂";
var oum = "√∂";
var ouml = "√∂";
var ovbar = "‚åΩ";
var par = "¬∂";
var para = "¬∂";
var parallel = "‚à•";
var parsim = "‚´≥";
var parsl = "‚´Ω";
var part = "‚àÇ";
var pcy = "–ø";
var percnt = "%";
var period = ".";
var permil = "‚Ä∞";
var perp = "‚ä•";
var pertenk = "‚Ä±";
var pfr = "ùî≠";
var phi = "œÜ";
var phiv = "œï";
var phmmat = "‚Ñ≥";
var phone = "‚òé";
var pi = "œÄ";
var pitchfork = "‚ãî";
var piv = "œñ";
var planck = "‚Ñè";
var planckh = "‚Ñé";
var plankv = "‚Ñè";
var plus = "+";
var plusacir = "‚®£";
var plusb = "‚äû";
var pluscir = "‚®¢";
var plusdo = "‚àî";
var plusdu = "‚®•";
var pluse = "‚©≤";
var plusm = "¬±";
var plusmn = "¬±";
var plussim = "‚®¶";
var plustwo = "‚®ß";
var pm = "¬±";
var pointint = "‚®ï";
var popf = "ùï°";
var poun = "¬£";
var pound = "¬£";
var pr = "‚â∫";
var prE = "‚™≥";
var prap = "‚™∑";
var prcue = "‚âº";
var pre = "‚™Ø";
var prec = "‚â∫";
var precapprox = "‚™∑";
var preccurlyeq = "‚âº";
var preceq = "‚™Ø";
var precnapprox = "‚™π";
var precneqq = "‚™µ";
var precnsim = "‚ã®";
var precsim = "‚âæ";
var prime = "‚Ä≤";
var primes = "‚Ñô";
var prnE = "‚™µ";
var prnap = "‚™π";
var prnsim = "‚ã®";
var prod = "‚àè";
var profalar = "‚åÆ";
var profline = "‚åí";
var profsurf = "‚åì";
var prop = "‚àù";
var propto = "‚àù";
var prsim = "‚âæ";
var prurel = "‚ä∞";
var pscr = "ùìÖ";
var psi = "œà";
var puncsp = "‚Äà";
var qfr = "ùîÆ";
var qint = "‚®å";
var qopf = "ùï¢";
var qprime = "‚Åó";
var qscr = "ùìÜ";
var quaternions = "‚Ñç";
var quatint = "‚®ñ";
var quest = "?";
var questeq = "‚âü";
var quo = "\"";
var quot = "\"";
var rAarr = "‚áõ";
var rArr = "‚áí";
var rAtail = "‚§ú";
var rBarr = "‚§è";
var rHar = "‚•§";
var race = "‚àΩÃ±";
var racute = "≈ï";
var radic = "‚àö";
var raemptyv = "‚¶≥";
var rang = "‚ü©";
var rangd = "‚¶í";
var range = "‚¶•";
var rangle = "‚ü©";
var raqu = "¬ª";
var raquo = "¬ª";
var rarr = "‚Üí";
var rarrap = "‚•µ";
var rarrb = "‚á•";
var rarrbfs = "‚§†";
var rarrc = "‚§≥";
var rarrfs = "‚§û";
var rarrhk = "‚Ü™";
var rarrlp = "‚Ü¨";
var rarrpl = "‚•Ö";
var rarrsim = "‚•¥";
var rarrtl = "‚Ü£";
var rarrw = "‚Üù";
var ratail = "‚§ö";
var ratio = "‚à∂";
var rationals = "‚Ñö";
var rbarr = "‚§ç";
var rbbrk = "‚ù≥";
var rbrace = "}";
var rbrack = "]";
var rbrke = "‚¶å";
var rbrksld = "‚¶é";
var rbrkslu = "‚¶ê";
var rcaron = "≈ô";
var rcedil = "≈ó";
var rceil = "‚åâ";
var rcub = "}";
var rcy = "—Ä";
var rdca = "‚§∑";
var rdldhar = "‚•©";
var rdquo = "‚Äù";
var rdquor = "‚Äù";
var rdsh = "‚Ü≥";
var real = "‚Ñú";
var realine = "‚Ñõ";
var realpart = "‚Ñú";
var reals = "‚Ñù";
var rect = "‚ñ≠";
var re$2 = "¬Æ";
var reg = "¬Æ";
var rfisht = "‚•Ω";
var rfloor = "‚åã";
var rfr = "ùîØ";
var rhard = "‚áÅ";
var rharu = "‚áÄ";
var rharul = "‚•¨";
var rho = "œÅ";
var rhov = "œ±";
var rightarrow = "‚Üí";
var rightarrowtail = "‚Ü£";
var rightharpoondown = "‚áÅ";
var rightharpoonup = "‚áÄ";
var rightleftarrows = "‚áÑ";
var rightleftharpoons = "‚áå";
var rightrightarrows = "‚áâ";
var rightsquigarrow = "‚Üù";
var rightthreetimes = "‚ãå";
var ring = "Àö";
var risingdotseq = "‚âì";
var rlarr = "‚áÑ";
var rlhar = "‚áå";
var rlm = "‚Äè";
var rmoust = "‚é±";
var rmoustache = "‚é±";
var rnmid = "‚´Æ";
var roang = "‚ü≠";
var roarr = "‚áæ";
var robrk = "‚üß";
var ropar = "‚¶Ü";
var ropf = "ùï£";
var roplus = "‚®Æ";
var rotimes = "‚®µ";
var rpar = ")";
var rpargt = "‚¶î";
var rppolint = "‚®í";
var rrarr = "‚áâ";
var rsaquo = "‚Ä∫";
var rscr = "ùìá";
var rsh = "‚Ü±";
var rsqb = "]";
var rsquo = "‚Äô";
var rsquor = "‚Äô";
var rthree = "‚ãå";
var rtimes = "‚ãä";
var rtri = "‚ñπ";
var rtrie = "‚äµ";
var rtrif = "‚ñ∏";
var rtriltri = "‚ßé";
var ruluhar = "‚•®";
var rx = "‚Ñû";
var sacute = "≈õ";
var sbquo = "‚Äö";
var sc = "‚âª";
var scE = "‚™¥";
var scap = "‚™∏";
var scaron = "≈°";
var sccue = "‚âΩ";
var sce = "‚™∞";
var scedil = "≈ü";
var scirc = "≈ù";
var scnE = "‚™∂";
var scnap = "‚™∫";
var scnsim = "‚ã©";
var scpolint = "‚®ì";
var scsim = "‚âø";
var scy = "—Å";
var sdot = "‚ãÖ";
var sdotb = "‚ä°";
var sdote = "‚©¶";
var seArr = "‚áò";
var searhk = "‚§•";
var searr = "‚Üò";
var searrow = "‚Üò";
var sec = "¬ß";
var sect = "¬ß";
var semi = ";";
var seswar = "‚§©";
var setminus = "‚àñ";
var setmn = "‚àñ";
var sext = "‚ú∂";
var sfr = "ùî∞";
var sfrown = "‚å¢";
var sharp = "‚ôØ";
var shchcy = "—â";
var shcy = "—à";
var shortmid = "‚à£";
var shortparallel = "‚à•";
var sh = "¬≠";
var shy = "¬≠";
var sigma = "œÉ";
var sigmaf = "œÇ";
var sigmav = "œÇ";
var sim = "‚àº";
var simdot = "‚©™";
var sime = "‚âÉ";
var simeq = "‚âÉ";
var simg = "‚™û";
var simgE = "‚™†";
var siml = "‚™ù";
var simlE = "‚™ü";
var simne = "‚âÜ";
var simplus = "‚®§";
var simrarr = "‚•≤";
var slarr = "‚Üê";
var smallsetminus = "‚àñ";
var smashp = "‚®≥";
var smeparsl = "‚ß§";
var smid = "‚à£";
var smile = "‚å£";
var smt = "‚™™";
var smte = "‚™¨";
var smtes = "‚™¨Ô∏Ä";
var softcy = "—å";
var sol = "/";
var solb = "‚ßÑ";
var solbar = "‚åø";
var sopf = "ùï§";
var spades = "‚ô†";
var spadesuit = "‚ô†";
var spar = "‚à•";
var sqcap = "‚äì";
var sqcaps = "‚äìÔ∏Ä";
var sqcup = "‚äî";
var sqcups = "‚äîÔ∏Ä";
var sqsub = "‚äè";
var sqsube = "‚äë";
var sqsubset = "‚äè";
var sqsubseteq = "‚äë";
var sqsup = "‚äê";
var sqsupe = "‚äí";
var sqsupset = "‚äê";
var sqsupseteq = "‚äí";
var squ = "‚ñ°";
var square = "‚ñ°";
var squarf = "‚ñ™";
var squf = "‚ñ™";
var srarr = "‚Üí";
var sscr = "ùìà";
var ssetmn = "‚àñ";
var ssmile = "‚å£";
var sstarf = "‚ãÜ";
var star = "‚òÜ";
var starf = "‚òÖ";
var straightepsilon = "œµ";
var straightphi = "œï";
var strns = "¬Ø";
var sub = "‚äÇ";
var subE = "‚´Ö";
var subdot = "‚™Ω";
var sube = "‚äÜ";
var subedot = "‚´É";
var submult = "‚´Å";
var subnE = "‚´ã";
var subne = "‚ää";
var subplus = "‚™ø";
var subrarr = "‚•π";
var subset = "‚äÇ";
var subseteq = "‚äÜ";
var subseteqq = "‚´Ö";
var subsetneq = "‚ää";
var subsetneqq = "‚´ã";
var subsim = "‚´á";
var subsub = "‚´ï";
var subsup = "‚´ì";
var succ = "‚âª";
var succapprox = "‚™∏";
var succcurlyeq = "‚âΩ";
var succeq = "‚™∞";
var succnapprox = "‚™∫";
var succneqq = "‚™∂";
var succnsim = "‚ã©";
var succsim = "‚âø";
var sum = "‚àë";
var sung = "‚ô™";
var sup = "‚äÉ";
var sup1 = "¬π";
var sup2 = "¬≤";
var sup3 = "¬≥";
var supE = "‚´Ü";
var supdot = "‚™æ";
var supdsub = "‚´ò";
var supe = "‚äá";
var supedot = "‚´Ñ";
var suphsol = "‚üâ";
var suphsub = "‚´ó";
var suplarr = "‚•ª";
var supmult = "‚´Ç";
var supnE = "‚´å";
var supne = "‚äã";
var supplus = "‚´Ä";
var supset = "‚äÉ";
var supseteq = "‚äá";
var supseteqq = "‚´Ü";
var supsetneq = "‚äã";
var supsetneqq = "‚´å";
var supsim = "‚´à";
var supsub = "‚´î";
var supsup = "‚´ñ";
var swArr = "‚áô";
var swarhk = "‚§¶";
var swarr = "‚Üô";
var swarrow = "‚Üô";
var swnwar = "‚§™";
var szli = "√ü";
var szlig = "√ü";
var target = "‚åñ";
var tau = "œÑ";
var tbrk = "‚é¥";
var tcaron = "≈•";
var tcedil = "≈£";
var tcy = "—Ç";
var tdot = "‚Éõ";
var telrec = "‚åï";
var tfr = "ùî±";
var there4 = "‚à¥";
var therefore = "‚à¥";
var theta = "Œ∏";
var thetasym = "œë";
var thetav = "œë";
var thickapprox = "‚âà";
var thicksim = "‚àº";
var thinsp = "‚Äâ";
var thkap = "‚âà";
var thksim = "‚àº";
var thor = "√æ";
var thorn = "√æ";
var tilde = "Àú";
var time = "√ó";
var times = "√ó";
var timesb = "‚ä†";
var timesbar = "‚®±";
var timesd = "‚®∞";
var tint = "‚à≠";
var toea = "‚§®";
var top = "‚ä§";
var topbot = "‚å∂";
var topcir = "‚´±";
var topf = "ùï•";
var topfork = "‚´ö";
var tosa = "‚§©";
var tprime = "‚Ä¥";
var trade = "‚Ñ¢";
var triangle = "‚ñµ";
var triangledown = "‚ñø";
var triangleleft = "‚óÉ";
var trianglelefteq = "‚ä¥";
var triangleq = "‚âú";
var triangleright = "‚ñπ";
var trianglerighteq = "‚äµ";
var tridot = "‚ó¨";
var trie = "‚âú";
var triminus = "‚®∫";
var triplus = "‚®π";
var trisb = "‚ßç";
var tritime = "‚®ª";
var trpezium = "‚è¢";
var tscr = "ùìâ";
var tscy = "—Ü";
var tshcy = "—õ";
var tstrok = "≈ß";
var twixt = "‚â¨";
var twoheadleftarrow = "‚Üû";
var twoheadrightarrow = "‚Ü†";
var uArr = "‚áë";
var uHar = "‚•£";
var uacut = "√∫";
var uacute = "√∫";
var uarr = "‚Üë";
var ubrcy = "—û";
var ubreve = "≈≠";
var ucir = "√ª";
var ucirc = "√ª";
var ucy = "—É";
var udarr = "‚áÖ";
var udblac = "≈±";
var udhar = "‚•Æ";
var ufisht = "‚•æ";
var ufr = "ùî≤";
var ugrav = "√π";
var ugrave = "√π";
var uharl = "‚Üø";
var uharr = "‚Üæ";
var uhblk = "‚ñÄ";
var ulcorn = "‚åú";
var ulcorner = "‚åú";
var ulcrop = "‚åè";
var ultri = "‚ó∏";
var umacr = "≈´";
var um = "¬®";
var uml = "¬®";
var uogon = "≈≥";
var uopf = "ùï¶";
var uparrow = "‚Üë";
var updownarrow = "‚Üï";
var upharpoonleft = "‚Üø";
var upharpoonright = "‚Üæ";
var uplus = "‚äé";
var upsi = "œÖ";
var upsih = "œí";
var upsilon = "œÖ";
var upuparrows = "‚áà";
var urcorn = "‚åù";
var urcorner = "‚åù";
var urcrop = "‚åé";
var uring = "≈Ø";
var urtri = "‚óπ";
var uscr = "ùìä";
var utdot = "‚ã∞";
var utilde = "≈©";
var utri = "‚ñµ";
var utrif = "‚ñ¥";
var uuarr = "‚áà";
var uum = "√º";
var uuml = "√º";
var uwangle = "‚¶ß";
var vArr = "‚áï";
var vBar = "‚´®";
var vBarv = "‚´©";
var vDash = "‚ä®";
var vangrt = "‚¶ú";
var varepsilon = "œµ";
var varkappa = "œ∞";
var varnothing = "‚àÖ";
var varphi = "œï";
var varpi = "œñ";
var varpropto = "‚àù";
var varr = "‚Üï";
var varrho = "œ±";
var varsigma = "œÇ";
var varsubsetneq = "‚ääÔ∏Ä";
var varsubsetneqq = "‚´ãÔ∏Ä";
var varsupsetneq = "‚äãÔ∏Ä";
var varsupsetneqq = "‚´åÔ∏Ä";
var vartheta = "œë";
var vartriangleleft = "‚ä≤";
var vartriangleright = "‚ä≥";
var vcy = "–≤";
var vdash = "‚ä¢";
var vee = "‚à®";
var veebar = "‚äª";
var veeeq = "‚âö";
var vellip = "‚ãÆ";
var verbar = "|";
var vert = "|";
var vfr = "ùî≥";
var vltri = "‚ä≤";
var vnsub = "‚äÇ‚Éí";
var vnsup = "‚äÉ‚Éí";
var vopf = "ùïß";
var vprop = "‚àù";
var vrtri = "‚ä≥";
var vscr = "ùìã";
var vsubnE = "‚´ãÔ∏Ä";
var vsubne = "‚ääÔ∏Ä";
var vsupnE = "‚´åÔ∏Ä";
var vsupne = "‚äãÔ∏Ä";
var vzigzag = "‚¶ö";
var wcirc = "≈µ";
var wedbar = "‚©ü";
var wedge = "‚àß";
var wedgeq = "‚âô";
var weierp = "‚Ñò";
var wfr = "ùî¥";
var wopf = "ùï®";
var wp = "‚Ñò";
var wr = "‚âÄ";
var wreath = "‚âÄ";
var wscr = "ùìå";
var xcap = "‚ãÇ";
var xcirc = "‚óØ";
var xcup = "‚ãÉ";
var xdtri = "‚ñΩ";
var xfr = "ùîµ";
var xhArr = "‚ü∫";
var xharr = "‚ü∑";
var xi = "Œæ";
var xlArr = "‚ü∏";
var xlarr = "‚üµ";
var xmap = "‚üº";
var xnis = "‚ãª";
var xodot = "‚®Ä";
var xopf = "ùï©";
var xoplus = "‚®Å";
var xotime = "‚®Ç";
var xrArr = "‚üπ";
var xrarr = "‚ü∂";
var xscr = "ùìç";
var xsqcup = "‚®Ü";
var xuplus = "‚®Ñ";
var xutri = "‚ñ≥";
var xvee = "‚ãÅ";
var xwedge = "‚ãÄ";
var yacut = "√Ω";
var yacute = "√Ω";
var yacy = "—è";
var ycirc = "≈∑";
var ycy = "—ã";
var ye = "¬•";
var yen = "¬•";
var yfr = "ùî∂";
var yicy = "—ó";
var yopf = "ùï™";
var yscr = "ùìé";
var yucy = "—é";
var yum = "√ø";
var yuml = "√ø";
var zacute = "≈∫";
var zcaron = "≈æ";
var zcy = "–∑";
var zdot = "≈º";
var zeetrf = "‚Ñ®";
var zeta = "Œ∂";
var zfr = "ùî∑";
var zhcy = "–∂";
var zigrarr = "‚áù";
var zopf = "ùï´";
var zscr = "ùìè";
var zwj = "‚Äç";
var zwnj = "‚Äå";
var characterEntities = {
	AEli: AEli,
	AElig: AElig,
	AM: AM,
	AMP: AMP,
	Aacut: Aacut,
	Aacute: Aacute,
	Abreve: Abreve,
	Acir: Acir,
	Acirc: Acirc,
	Acy: Acy,
	Afr: Afr,
	Agrav: Agrav,
	Agrave: Agrave,
	Alpha: Alpha,
	Amacr: Amacr,
	And: And,
	Aogon: Aogon,
	Aopf: Aopf,
	ApplyFunction: ApplyFunction,
	Arin: Arin,
	Aring: Aring,
	Ascr: Ascr,
	Assign: Assign,
	Atild: Atild,
	Atilde: Atilde,
	Aum: Aum,
	Auml: Auml,
	Backslash: Backslash,
	Barv: Barv,
	Barwed: Barwed,
	Bcy: Bcy,
	Because: Because,
	Bernoullis: Bernoullis,
	Beta: Beta,
	Bfr: Bfr,
	Bopf: Bopf,
	Breve: Breve,
	Bscr: Bscr,
	Bumpeq: Bumpeq,
	CHcy: CHcy,
	COP: COP,
	COPY: COPY,
	Cacute: Cacute,
	Cap: Cap,
	CapitalDifferentialD: CapitalDifferentialD,
	Cayleys: Cayleys,
	Ccaron: Ccaron,
	Ccedi: Ccedi,
	Ccedil: Ccedil,
	Ccirc: Ccirc,
	Cconint: Cconint,
	Cdot: Cdot,
	Cedilla: Cedilla,
	CenterDot: CenterDot,
	Cfr: Cfr,
	Chi: Chi,
	CircleDot: CircleDot,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	Colon: Colon,
	Colone: Colone,
	Congruent: Congruent,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	Copf: Copf,
	Coproduct: Coproduct,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	Cross: Cross,
	Cscr: Cscr,
	Cup: Cup,
	CupCap: CupCap,
	DD: DD,
	DDotrahd: DDotrahd,
	DJcy: DJcy,
	DScy: DScy,
	DZcy: DZcy,
	Dagger: Dagger,
	Darr: Darr,
	Dashv: Dashv,
	Dcaron: Dcaron,
	Dcy: Dcy,
	Del: Del,
	Delta: Delta,
	Dfr: Dfr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	Diamond: Diamond,
	DifferentialD: DifferentialD,
	Dopf: Dopf,
	Dot: Dot,
	DotDot: DotDot,
	DotEqual: DotEqual,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrow: DownArrow,
	DownArrowBar: DownArrowBar,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVector: DownLeftVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVector: DownRightVector,
	DownRightVectorBar: DownRightVectorBar,
	DownTee: DownTee,
	DownTeeArrow: DownTeeArrow,
	Downarrow: Downarrow,
	Dscr: Dscr,
	Dstrok: Dstrok,
	ENG: ENG,
	ET: ET,
	ETH: ETH,
	Eacut: Eacut,
	Eacute: Eacute,
	Ecaron: Ecaron,
	Ecir: Ecir,
	Ecirc: Ecirc,
	Ecy: Ecy,
	Edot: Edot,
	Efr: Efr,
	Egrav: Egrav,
	Egrave: Egrave,
	Element: Element,
	Emacr: Emacr,
	EmptySmallSquare: EmptySmallSquare,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	Eogon: Eogon,
	Eopf: Eopf,
	Epsilon: Epsilon,
	Equal: Equal,
	EqualTilde: EqualTilde,
	Equilibrium: Equilibrium,
	Escr: Escr,
	Esim: Esim,
	Eta: Eta,
	Eum: Eum,
	Euml: Euml,
	Exists: Exists,
	ExponentialE: ExponentialE,
	Fcy: Fcy,
	Ffr: Ffr,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	Fopf: Fopf,
	ForAll: ForAll,
	Fouriertrf: Fouriertrf,
	Fscr: Fscr,
	GJcy: GJcy,
	G: G,
	GT: GT,
	Gamma: Gamma,
	Gammad: Gammad,
	Gbreve: Gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	Gcy: Gcy,
	Gdot: Gdot,
	Gfr: Gfr,
	Gg: Gg,
	Gopf: Gopf,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	Gt: Gt,
	HARDcy: HARDcy,
	Hacek: Hacek,
	Hat: Hat,
	Hcirc: Hcirc,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	Hopf: Hopf,
	HorizontalLine: HorizontalLine,
	Hscr: Hscr,
	Hstrok: Hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	IEcy: IEcy,
	IJlig: IJlig,
	IOcy: IOcy,
	Iacut: Iacut,
	Iacute: Iacute,
	Icir: Icir,
	Icirc: Icirc,
	Icy: Icy,
	Idot: Idot,
	Ifr: Ifr,
	Igrav: Igrav,
	Igrave: Igrave,
	Im: Im,
	Imacr: Imacr,
	ImaginaryI: ImaginaryI,
	Implies: Implies,
	Int: Int,
	Integral: Integral,
	Intersection: Intersection,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	Iogon: Iogon,
	Iopf: Iopf,
	Iota: Iota,
	Iscr: Iscr,
	Itilde: Itilde,
	Iukcy: Iukcy,
	Ium: Ium,
	Iuml: Iuml,
	Jcirc: Jcirc,
	Jcy: Jcy,
	Jfr: Jfr,
	Jopf: Jopf,
	Jscr: Jscr,
	Jsercy: Jsercy,
	Jukcy: Jukcy,
	KHcy: KHcy,
	KJcy: KJcy,
	Kappa: Kappa,
	Kcedil: Kcedil,
	Kcy: Kcy,
	Kfr: Kfr,
	Kopf: Kopf,
	Kscr: Kscr,
	LJcy: LJcy,
	L: L,
	LT: LT,
	Lacute: Lacute,
	Lambda: Lambda,
	Lang: Lang,
	Laplacetrf: Laplacetrf,
	Larr: Larr,
	Lcaron: Lcaron,
	Lcedil: Lcedil,
	Lcy: Lcy,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrow: LeftArrow,
	LeftArrowBar: LeftArrowBar,
	LeftArrowRightArrow: LeftArrowRightArrow,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVector: LeftDownVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftFloor: LeftFloor,
	LeftRightArrow: LeftRightArrow,
	LeftRightVector: LeftRightVector,
	LeftTee: LeftTee,
	LeftTeeArrow: LeftTeeArrow,
	LeftTeeVector: LeftTeeVector,
	LeftTriangle: LeftTriangle,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVector: LeftUpVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftVector: LeftVector,
	LeftVectorBar: LeftVectorBar,
	Leftarrow: Leftarrow,
	Leftrightarrow: Leftrightarrow,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	LessLess: LessLess,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	Lfr: Lfr,
	Ll: Ll,
	Lleftarrow: Lleftarrow,
	Lmidot: Lmidot,
	LongLeftArrow: LongLeftArrow,
	LongLeftRightArrow: LongLeftRightArrow,
	LongRightArrow: LongRightArrow,
	Longleftarrow: Longleftarrow,
	Longleftrightarrow: Longleftrightarrow,
	Longrightarrow: Longrightarrow,
	Lopf: Lopf,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	Lscr: Lscr,
	Lsh: Lsh,
	Lstrok: Lstrok,
	Lt: Lt,
	"Map": "‚§Ö",
	Mcy: Mcy,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	MinusPlus: MinusPlus,
	Mopf: Mopf,
	Mscr: Mscr,
	Mu: Mu,
	NJcy: NJcy,
	Nacute: Nacute,
	Ncaron: Ncaron,
	Ncedil: Ncedil,
	Ncy: Ncy,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	Nfr: Nfr,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	Nopf: Nopf,
	Not: Not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	Nscr: Nscr,
	Ntild: Ntild,
	Ntilde: Ntilde,
	Nu: Nu,
	OElig: OElig,
	Oacut: Oacut,
	Oacute: Oacute,
	Ocir: Ocir,
	Ocirc: Ocirc,
	Ocy: Ocy,
	Odblac: Odblac,
	Ofr: Ofr,
	Ograv: Ograv,
	Ograve: Ograve,
	Omacr: Omacr,
	Omega: Omega,
	Omicron: Omicron,
	Oopf: Oopf,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	Or: Or,
	Oscr: Oscr,
	Oslas: Oslas,
	Oslash: Oslash,
	Otild: Otild,
	Otilde: Otilde,
	Otimes: Otimes,
	Oum: Oum,
	Ouml: Ouml,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	PartialD: PartialD,
	Pcy: Pcy,
	Pfr: Pfr,
	Phi: Phi,
	Pi: Pi,
	PlusMinus: PlusMinus,
	Poincareplane: Poincareplane,
	Popf: Popf,
	Pr: Pr,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	Prime: Prime,
	Product: Product,
	Proportion: Proportion,
	Proportional: Proportional,
	Pscr: Pscr,
	Psi: Psi,
	QUO: QUO,
	QUOT: QUOT,
	Qfr: Qfr,
	Qopf: Qopf,
	Qscr: Qscr,
	RBarr: RBarr,
	RE: RE,
	REG: REG,
	Racute: Racute,
	Rang: Rang,
	Rarr: Rarr,
	Rarrtl: Rarrtl,
	Rcaron: Rcaron,
	Rcedil: Rcedil,
	Rcy: Rcy,
	Re: Re,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	Rfr: Rfr,
	Rho: Rho,
	RightAngleBracket: RightAngleBracket,
	RightArrow: RightArrow,
	RightArrowBar: RightArrowBar,
	RightArrowLeftArrow: RightArrowLeftArrow,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVector: RightDownVector,
	RightDownVectorBar: RightDownVectorBar,
	RightFloor: RightFloor,
	RightTee: RightTee,
	RightTeeArrow: RightTeeArrow,
	RightTeeVector: RightTeeVector,
	RightTriangle: RightTriangle,
	RightTriangleBar: RightTriangleBar,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVector: RightUpVector,
	RightUpVectorBar: RightUpVectorBar,
	RightVector: RightVector,
	RightVectorBar: RightVectorBar,
	Rightarrow: Rightarrow,
	Ropf: Ropf,
	RoundImplies: RoundImplies,
	Rrightarrow: Rrightarrow,
	Rscr: Rscr,
	Rsh: Rsh,
	RuleDelayed: RuleDelayed,
	SHCHcy: SHCHcy,
	SHcy: SHcy,
	SOFTcy: SOFTcy,
	Sacute: Sacute,
	Sc: Sc,
	Scaron: Scaron,
	Scedil: Scedil,
	Scirc: Scirc,
	Scy: Scy,
	Sfr: Sfr,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	Sigma: Sigma,
	SmallCircle: SmallCircle,
	Sopf: Sopf,
	Sqrt: Sqrt,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	Sscr: Sscr,
	Star: Star,
	Sub: Sub,
	Subset: Subset,
	SubsetEqual: SubsetEqual,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	SuchThat: SuchThat,
	Sum: Sum,
	Sup: Sup,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	Supset: Supset,
	THOR: THOR,
	THORN: THORN,
	TRADE: TRADE,
	TSHcy: TSHcy,
	TScy: TScy,
	Tab: Tab,
	Tau: Tau,
	Tcaron: Tcaron,
	Tcedil: Tcedil,
	Tcy: Tcy,
	Tfr: Tfr,
	Therefore: Therefore,
	Theta: Theta,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	Topf: Topf,
	TripleDot: TripleDot,
	Tscr: Tscr,
	Tstrok: Tstrok,
	Uacut: Uacut,
	Uacute: Uacute,
	Uarr: Uarr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	Ubreve: Ubreve,
	Ucir: Ucir,
	Ucirc: Ucirc,
	Ucy: Ucy,
	Udblac: Udblac,
	Ufr: Ufr,
	Ugrav: Ugrav,
	Ugrave: Ugrave,
	Umacr: Umacr,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	Uopf: Uopf,
	UpArrow: UpArrow,
	UpArrowBar: UpArrowBar,
	UpArrowDownArrow: UpArrowDownArrow,
	UpDownArrow: UpDownArrow,
	UpEquilibrium: UpEquilibrium,
	UpTee: UpTee,
	UpTeeArrow: UpTeeArrow,
	Uparrow: Uparrow,
	Updownarrow: Updownarrow,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	Upsi: Upsi,
	Upsilon: Upsilon,
	Uring: Uring,
	Uscr: Uscr,
	Utilde: Utilde,
	Uum: Uum,
	Uuml: Uuml,
	VDash: VDash,
	Vbar: Vbar,
	Vcy: Vcy,
	Vdash: Vdash,
	Vdashl: Vdashl,
	Vee: Vee,
	Verbar: Verbar,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	Vopf: Vopf,
	Vscr: Vscr,
	Vvdash: Vvdash,
	Wcirc: Wcirc,
	Wedge: Wedge,
	Wfr: Wfr,
	Wopf: Wopf,
	Wscr: Wscr,
	Xfr: Xfr,
	Xi: Xi,
	Xopf: Xopf,
	Xscr: Xscr,
	YAcy: YAcy,
	YIcy: YIcy,
	YUcy: YUcy,
	Yacut: Yacut,
	Yacute: Yacute,
	Ycirc: Ycirc,
	Ycy: Ycy,
	Yfr: Yfr,
	Yopf: Yopf,
	Yscr: Yscr,
	Yuml: Yuml,
	ZHcy: ZHcy,
	Zacute: Zacute,
	Zcaron: Zcaron,
	Zcy: Zcy,
	Zdot: Zdot,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	Zfr: Zfr,
	Zopf: Zopf,
	Zscr: Zscr,
	aacut: aacut,
	aacute: aacute,
	abreve: abreve,
	ac: ac,
	acE: acE,
	acd: acd,
	acir: acir,
	acirc: acirc,
	acut: acut,
	acute: acute,
	acy: acy,
	aeli: aeli,
	aelig: aelig,
	af: af,
	afr: afr,
	agrav: agrav,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	alpha: alpha,
	amacr: amacr,
	amalg: amalg,
	am: am,
	amp: amp,
	and: and,
	andand: andand,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsd: angmsd,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	aogon: aogon,
	aopf: aopf,
	ap: ap,
	apE: apE,
	apacir: apacir,
	ape: ape,
	apid: apid,
	apos: apos,
	approx: approx,
	approxeq: approxeq,
	arin: arin,
	aring: aring,
	ascr: ascr,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	atild: atild,
	atilde: atilde,
	aum: aum,
	auml: auml,
	awconint: awconint,
	awint: awint,
	bNot: bNot,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	barvee: barvee,
	barwed: barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	beta: beta,
	beth: beth,
	between: between,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bnot: bnot,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxDL: boxDL,
	boxDR: boxDR,
	boxDl: boxDl,
	boxDr: boxDr,
	boxH: boxH,
	boxHD: boxHD,
	boxHU: boxHU,
	boxHd: boxHd,
	boxHu: boxHu,
	boxUL: boxUL,
	boxUR: boxUR,
	boxUl: boxUl,
	boxUr: boxUr,
	boxV: boxV,
	boxVH: boxVH,
	boxVL: boxVL,
	boxVR: boxVR,
	boxVh: boxVh,
	boxVl: boxVl,
	boxVr: boxVr,
	boxbox: boxbox,
	boxdL: boxdL,
	boxdR: boxdR,
	boxdl: boxdl,
	boxdr: boxdr,
	boxh: boxh,
	boxhD: boxhD,
	boxhU: boxhU,
	boxhd: boxhd,
	boxhu: boxhu,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxuL: boxuL,
	boxuR: boxuR,
	boxul: boxul,
	boxur: boxur,
	boxv: boxv,
	boxvH: boxvH,
	boxvL: boxvL,
	boxvR: boxvR,
	boxvh: boxvh,
	boxvl: boxvl,
	boxvr: boxvr,
	bprime: bprime,
	breve: breve,
	brvba: brvba,
	brvbar: brvbar,
	bscr: bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsol: bsol,
	bsolb: bsolb,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	bumpeq: bumpeq,
	cacute: cacute,
	cap: cap,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	capcup: capcup,
	capdot: capdot,
	caps: caps,
	caret: caret,
	caron: caron,
	ccaps: ccaps,
	ccaron: ccaron,
	ccedi: ccedi,
	ccedil: ccedil,
	ccirc: ccirc,
	ccups: ccups,
	ccupssm: ccupssm,
	cdot: cdot,
	cedi: cedi,
	cedil: cedil,
	cemptyv: cemptyv,
	cen: cen,
	cent: cent,
	centerdot: centerdot,
	cfr: cfr,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	chi: chi,
	cir: cir,
	cirE: cirE,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledR: circledR,
	circledS: circledS,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	conint: conint,
	copf: copf,
	coprod: coprod,
	cop: cop,
	copy: copy,
	copysr: copysr,
	crarr: crarr,
	cross: cross,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cup: cup,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curre: curre,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dArr: dArr,
	dHar: dHar,
	dagger: dagger,
	daleth: daleth,
	darr: darr,
	dash: dash,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	dcaron: dcaron,
	dcy: dcy,
	dd: dd,
	ddagger: ddagger,
	ddarr: ddarr,
	ddotseq: ddotseq,
	de: de,
	deg: deg,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	dfr: dfr,
	dharl: dharl,
	dharr: dharr,
	diam: diam,
	diamond: diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	digamma: digamma,
	disin: disin,
	div: div,
	divid: divid,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	dopf: dopf,
	dot: dot,
	doteq: doteq,
	doteqdot: doteqdot,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	downarrow: downarrow,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	dscr: dscr,
	dscy: dscy,
	dsol: dsol,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	eDDot: eDDot,
	eDot: eDot,
	eacut: eacut,
	eacute: eacute,
	easter: easter,
	ecaron: ecaron,
	ecir: ecir,
	ecirc: ecirc,
	ecolon: ecolon,
	ecy: ecy,
	edot: edot,
	ee: ee,
	efDot: efDot,
	efr: efr,
	eg: eg,
	egrav: egrav,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	emptyv: emptyv,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	eng: eng,
	ensp: ensp,
	eogon: eogon,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	equals: equals,
	equest: equest,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erDot: erDot,
	erarr: erarr,
	escr: escr,
	esdot: esdot,
	esim: esim,
	eta: eta,
	et: et,
	eth: eth,
	eum: eum,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	expectation: expectation,
	exponentiale: exponentiale,
	fallingdotseq: fallingdotseq,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	ffr: ffr,
	filig: filig,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	fopf: fopf,
	forall: forall,
	fork: fork,
	forkv: forkv,
	fpartint: fpartint,
	frac1: frac1,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac3: frac3,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	gE: gE,
	gEl: gEl,
	gacute: gacute,
	gamma: gamma,
	gammad: gammad,
	gap: gap,
	gbreve: gbreve,
	gcirc: gcirc,
	gcy: gcy,
	gdot: gdot,
	ge: ge,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	ges: ges,
	gescc: gescc,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	gfr: gfr,
	gg: gg,
	ggg: ggg,
	gimel: gimel,
	gjcy: gjcy,
	gl: gl,
	glE: glE,
	gla: gla,
	glj: glj,
	gnE: gnE,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	gopf: gopf,
	grave: grave,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	g: g,
	gt: gt,
	gtcc: gtcc,
	gtcir: gtcir,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	hArr: hArr,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	hardcy: hardcy,
	harr: harr,
	harrcir: harrcir,
	harrw: harrw,
	hbar: hbar,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	horbar: horbar,
	hscr: hscr,
	hslash: hslash,
	hstrok: hstrok,
	hybull: hybull,
	hyphen: hyphen,
	iacut: iacut,
	iacute: iacute,
	ic: ic,
	icir: icir,
	icirc: icirc,
	icy: icy,
	iecy: iecy,
	iexc: iexc,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	igrav: igrav,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	ijlig: ijlig,
	imacr: imacr,
	image: image,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	imof: imof,
	imped: imped,
	"in": "‚àà",
	incare: incare,
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	int: int,
	intcal: intcal,
	integers: integers,
	intercal: intercal,
	intlarhk: intlarhk,
	intprod: intprod,
	iocy: iocy,
	iogon: iogon,
	iopf: iopf,
	iota: iota,
	iprod: iprod,
	iques: iques,
	iquest: iquest,
	iscr: iscr,
	isin: isin,
	isinE: isinE,
	isindot: isindot,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	itilde: itilde,
	iukcy: iukcy,
	ium: ium,
	iuml: iuml,
	jcirc: jcirc,
	jcy: jcy,
	jfr: jfr,
	jmath: jmath,
	jopf: jopf,
	jscr: jscr,
	jsercy: jsercy,
	jukcy: jukcy,
	kappa: kappa,
	kappav: kappav,
	kcedil: kcedil,
	kcy: kcy,
	kfr: kfr,
	kgreen: kgreen,
	khcy: khcy,
	kjcy: kjcy,
	kopf: kopf,
	kscr: kscr,
	lAarr: lAarr,
	lArr: lArr,
	lAtail: lAtail,
	lBarr: lBarr,
	lE: lE,
	lEg: lEg,
	lHar: lHar,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	lambda: lambda,
	lang: lang,
	langd: langd,
	langle: langle,
	lap: lap,
	laqu: laqu,
	laquo: laquo,
	larr: larr,
	larrb: larrb,
	larrbfs: larrbfs,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	lat: lat,
	latail: latail,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	lcaron: lcaron,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	leftarrow: leftarrow,
	leftarrowtail: leftarrowtail,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	leftthreetimes: leftthreetimes,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	les: les,
	lescc: lescc,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	lessgtr: lessgtr,
	lesssim: lesssim,
	lfisht: lfisht,
	lfloor: lfloor,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	ljcy: ljcy,
	ll: ll,
	llarr: llarr,
	llcorner: llcorner,
	llhard: llhard,
	lltri: lltri,
	lmidot: lmidot,
	lmoust: lmoust,
	lmoustache: lmoustache,
	lnE: lnE,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	longleftrightarrow: longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	lsh: lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	lstrok: lstrok,
	l: l,
	lt: lt,
	ltcc: ltcc,
	ltcir: ltcir,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltrPar: ltrPar,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	mDDot: mDDot,
	mac: mac,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	map: map,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	mcy: mcy,
	mdash: mdash,
	measuredangle: measuredangle,
	mfr: mfr,
	mho: mho,
	micr: micr,
	micro: micro,
	mid: mid,
	midast: midast,
	midcir: midcir,
	middo: middo,
	middot: middot,
	minus: minus,
	minusb: minusb,
	minusd: minusd,
	minusdu: minusdu,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	mstpos: mstpos,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nGg: nGg,
	nGt: nGt,
	nGtv: nGtv,
	nLeftarrow: nLeftarrow,
	nLeftrightarrow: nLeftrightarrow,
	nLl: nLl,
	nLt: nLt,
	nLtv: nLtv,
	nRightarrow: nRightarrow,
	nVDash: nVDash,
	nVdash: nVdash,
	nabla: nabla,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natur: natur,
	natural: natural,
	naturals: naturals,
	nbs: nbs,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	ncaron: ncaron,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	ncy: ncy,
	ndash: ndash,
	ne: ne,
	neArr: neArr,
	nearhk: nearhk,
	nearr: nearr,
	nearrow: nearrow,
	nedot: nedot,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	nexist: nexist,
	nexists: nexists,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	ngsim: ngsim,
	ngt: ngt,
	ngtr: ngtr,
	nhArr: nhArr,
	nharr: nharr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	njcy: njcy,
	nlArr: nlArr,
	nlE: nlE,
	nlarr: nlarr,
	nldr: nldr,
	nle: nle,
	nleftarrow: nleftarrow,
	nleftrightarrow: nleftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nlsim: nlsim,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nmid: nmid,
	nopf: nopf,
	no: no,
	not: not,
	notin: notin,
	notinE: notinE,
	notindot: notindot,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	npar: npar,
	nparallel: nparallel,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	npre: npre,
	nprec: nprec,
	npreceq: npreceq,
	nrArr: nrArr,
	nrarr: nrarr,
	nrarrc: nrarrc,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	ntild: ntild,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvDash: nvDash,
	nvHarr: nvHarr,
	nvap: nvap,
	nvdash: nvdash,
	nvge: nvge,
	nvgt: nvgt,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwArr: nwArr,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	oS: oS,
	oacut: oacut,
	oacute: oacute,
	oast: oast,
	ocir: ocir,
	ocirc: ocirc,
	ocy: ocy,
	odash: odash,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	oelig: oelig,
	ofcir: ofcir,
	ofr: ofr,
	ogon: ogon,
	ograv: ograv,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	omacr: omacr,
	omega: omega,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	oopf: oopf,
	opar: opar,
	operp: operp,
	oplus: oplus,
	or: or,
	orarr: orarr,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oscr: oscr,
	oslas: oslas,
	oslash: oslash,
	osol: osol,
	otild: otild,
	otilde: otilde,
	otimes: otimes,
	otimesas: otimesas,
	oum: oum,
	ouml: ouml,
	ovbar: ovbar,
	par: par,
	para: para,
	parallel: parallel,
	parsim: parsim,
	parsl: parsl,
	part: part,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	pfr: pfr,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plus: plus,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	plusm: plusm,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	pointint: pointint,
	popf: popf,
	poun: poun,
	pound: pound,
	pr: pr,
	prE: prE,
	prap: prap,
	prcue: prcue,
	pre: pre,
	prec: prec,
	precapprox: precapprox,
	preccurlyeq: preccurlyeq,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	precsim: precsim,
	prime: prime,
	primes: primes,
	prnE: prnE,
	prnap: prnap,
	prnsim: prnsim,
	prod: prod,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	pscr: pscr,
	psi: psi,
	puncsp: puncsp,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	qprime: qprime,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quo: quo,
	quot: quot,
	rAarr: rAarr,
	rArr: rArr,
	rAtail: rAtail,
	rBarr: rBarr,
	rHar: rHar,
	race: race,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raqu: raqu,
	raquo: raquo,
	rarr: rarr,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	rcaron: rcaron,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	rect: rect,
	re: re$2,
	reg: reg,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	rho: rho,
	rhov: rhov,
	rightarrow: rightarrow,
	rightarrowtail: rightarrowtail,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	rightthreetimes: rightthreetimes,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoust: rmoust,
	rmoustache: rmoustache,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	roplus: roplus,
	rotimes: rotimes,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	rsaquo: rsaquo,
	rscr: rscr,
	rsh: rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	ruluhar: ruluhar,
	rx: rx,
	sacute: sacute,
	sbquo: sbquo,
	sc: sc,
	scE: scE,
	scap: scap,
	scaron: scaron,
	sccue: sccue,
	sce: sce,
	scedil: scedil,
	scirc: scirc,
	scnE: scnE,
	scnap: scnap,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	scy: scy,
	sdot: sdot,
	sdotb: sdotb,
	sdote: sdote,
	seArr: seArr,
	searhk: searhk,
	searr: searr,
	searrow: searrow,
	sec: sec,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	shchcy: shchcy,
	shcy: shcy,
	shortmid: shortmid,
	shortparallel: shortparallel,
	sh: sh,
	shy: shy,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	softcy: softcy,
	sol: sol,
	solb: solb,
	solbar: solbar,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	squ: squ,
	square: square,
	squarf: squarf,
	squf: squf,
	srarr: srarr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	subE: subE,
	subdot: subdot,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succ: succ,
	succapprox: succapprox,
	succcurlyeq: succcurlyeq,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	sum: sum,
	sung: sung,
	sup: sup,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	supE: supE,
	supdot: supdot,
	supdsub: supdsub,
	supe: supe,
	supedot: supedot,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swArr: swArr,
	swarhk: swarhk,
	swarr: swarr,
	swarrow: swarrow,
	swnwar: swnwar,
	szli: szli,
	szlig: szlig,
	target: target,
	tau: tau,
	tbrk: tbrk,
	tcaron: tcaron,
	tcedil: tcedil,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	thor: thor,
	thorn: thorn,
	tilde: tilde,
	time: time,
	times: times,
	timesb: timesb,
	timesbar: timesbar,
	timesd: timesd,
	tint: tint,
	toea: toea,
	top: top,
	topbot: topbot,
	topcir: topcir,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	tscr: tscr,
	tscy: tscy,
	tshcy: tshcy,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	uArr: uArr,
	uHar: uHar,
	uacut: uacut,
	uacute: uacute,
	uarr: uarr,
	ubrcy: ubrcy,
	ubreve: ubreve,
	ucir: ucir,
	ucirc: ucirc,
	ucy: ucy,
	udarr: udarr,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	ufr: ufr,
	ugrav: ugrav,
	ugrave: ugrave,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	umacr: umacr,
	um: um,
	uml: uml,
	uogon: uogon,
	uopf: uopf,
	uparrow: uparrow,
	updownarrow: updownarrow,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	upsi: upsi,
	upsih: upsih,
	upsilon: upsilon,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	uring: uring,
	urtri: urtri,
	uscr: uscr,
	utdot: utdot,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	uum: uum,
	uuml: uuml,
	uwangle: uwangle,
	vArr: vArr,
	vBar: vBar,
	vBarv: vBarv,
	vDash: vDash,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vcy: vcy,
	vdash: vdash,
	vee: vee,
	veebar: veebar,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	vert: vert,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	vzigzag: vzigzag,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	wfr: wfr,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	xfr: xfr,
	xhArr: xhArr,
	xharr: xharr,
	xi: xi,
	xlArr: xlArr,
	xlarr: xlarr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrArr: xrArr,
	xrarr: xrarr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	yacut: yacut,
	yacute: yacute,
	yacy: yacy,
	ycirc: ycirc,
	ycy: ycy,
	ye: ye,
	yen: yen,
	yfr: yfr,
	yicy: yicy,
	yopf: yopf,
	yscr: yscr,
	yucy: yucy,
	yum: yum,
	yuml: yuml,
	zacute: zacute,
	zcaron: zcaron,
	zcy: zcy,
	zdot: zdot,
	zeetrf: zeetrf,
	zeta: zeta,
	zfr: zfr,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var decodeEntity_1 = decodeEntity;

var own$2 = {}.hasOwnProperty;

function decodeEntity(characters) {
  return own$2.call(characterEntities, characters)
    ? characterEntities[characters]
    : false
}

var parseEntities_1 = parseEntities;

var own$1 = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop = Function.prototype;

// Default settings.
var defaults$2 = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};

// Characters.
var tab = 9; // '\t'
var lineFeed = 10; // '\n'
var formFeed = 12; //  '\f'
var space = 32; // ' '
var ampersand = 38; //  '&'
var semicolon = 59; //  ';'
var lessThan = 60; //  '<'
var equalsTo = 61; //  '='
var numberSign = 35; //  '#'
var uppercaseX = 88; //  'X'
var lowercaseX = 120; //  'x'
var replacementCharacter = 65533; // 'ÔøΩ'

// Reference types.
var name = 'named';
var hexa = 'hexadecimal';
var deci = 'decimal';

// Map of bases.
var bases = {};

bases[hexa] = 16;
bases[deci] = 10;

// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var tests = {};

tests[name] = isAlphanumerical;
tests[deci] = isDecimal;
tests[hexa] = isHexadecimal;

// Warning types.
var namedNotTerminated = 1;
var numericNotTerminated = 2;
var namedEmpty = 3;
var numericEmpty = 4;
var namedUnknown = 5;
var numericDisallowed = 6;
var numericProhibited = 7;

// Warning messages.
var messages = {};

messages[namedNotTerminated] =
  'Named character references must be terminated by a semicolon';
messages[numericNotTerminated] =
  'Numeric character references must be terminated by a semicolon';
messages[namedEmpty] = 'Named character references cannot be empty';
messages[numericEmpty] = 'Numeric character references cannot be empty';
messages[namedUnknown] = 'Named character references must be known';
messages[numericDisallowed] =
  'Numeric character references cannot be disallowed';
messages[numericProhibited] =
  'Numeric character references cannot be outside the permissible Unicode range';

// Wrap to ensure clean parameters are given to `parse`.
function parseEntities(value, options) {
  var settings = {};
  var option;
  var key;

  if (!options) {
    options = {};
  }

  for (key in defaults$2) {
    option = options[key];
    settings[key] =
      option === null || option === undefined ? defaults$2[key] : option;
  }

  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }

  return parse$2(value, settings)
}

// Parse entities.
// eslint-disable-next-line complexity
function parse$2(value, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent = settings.indent || [];
  var length = value.length;
  var index = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line = pos.line || 1;
  var queue = '';
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters;
  var character;
  var reference;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start;
  var type;
  var test;
  var prev;
  var next;
  var diff;
  var end;

  if (typeof additional === 'string') {
    additional = additional.charCodeAt(0);
  }

  // Cache the current point.
  prev = now();

  // Wrap `handleWarning`.
  warning = handleWarning ? parseError : noop;

  // Ensure the algorithm walks over the first character and the end (inclusive).
  index--;
  length++;

  while (++index < length) {
    // If the previous character was a newline.
    if (character === lineFeed) {
      column = indent[lines] || 1;
    }

    character = value.charCodeAt(index);

    if (character === ampersand) {
      following = value.charCodeAt(index + 1);

      // The behaviour depends on the identity of the next character.
      if (
        following === tab ||
        following === lineFeed ||
        following === formFeed ||
        following === space ||
        following === ampersand ||
        following === lessThan ||
        following !== following ||
        (additional && following === additional)
      ) {
        // Not a character reference.
        // No characters are consumed, and nothing is returned.
        // This is not an error, either.
        queue += fromCharCode(character);
        column++;

        continue
      }

      start = index + 1;
      begin = start;
      end = start;

      if (following === numberSign) {
        // Numerical entity.
        end = ++begin;

        // The behaviour further depends on the next character.
        following = value.charCodeAt(end);

        if (following === uppercaseX || following === lowercaseX) {
          // ASCII hex digits.
          type = hexa;
          end = ++begin;
        } else {
          // ASCII digits.
          type = deci;
        }
      } else {
        // Named entity.
        type = name;
      }

      entityCharacters = '';
      entity = '';
      characters = '';
      test = tests[type];
      end--;

      while (++end < length) {
        following = value.charCodeAt(end);

        if (!test(following)) {
          break
        }

        characters += fromCharCode(following);

        // Check if we can match a legacy named reference.
        // If so, we cache that as the last viable named reference.
        // This ensures we do not need to walk backwards later.
        if (type === name && own$1.call(legacy, characters)) {
          entityCharacters = characters;
          entity = legacy[characters];
        }
      }

      terminated = value.charCodeAt(end) === semicolon;

      if (terminated) {
        end++;

        namedEntity = type === name ? decodeEntity_1(characters) : false;

        if (namedEntity) {
          entityCharacters = characters;
          entity = namedEntity;
        }
      }

      diff = 1 + end - start;

      if (!terminated && !nonTerminated) ; else if (!characters) {
        // An empty (possible) entity is valid, unless it‚Äôs numeric (thus an
        // ampersand followed by an octothorp).
        if (type !== name) {
          warning(numericEmpty, diff);
        }
      } else if (type === name) {
        // An ampersand followed by anything unknown, and not terminated, is
        // invalid.
        if (terminated && !entity) {
          warning(namedUnknown, 1);
        } else {
          // If theres something after an entity name which is not known, cap
          // the reference.
          if (entityCharacters !== characters) {
            end = begin + entityCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }

          // If the reference is not terminated, warn.
          if (!terminated) {
            reason = entityCharacters ? namedNotTerminated : namedEmpty;

            if (settings.attribute) {
              following = value.charCodeAt(end);

              if (following === equalsTo) {
                warning(reason, diff);
                entity = null;
              } else if (isAlphanumerical(following)) {
                entity = null;
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }

        reference = entity;
      } else {
        if (!terminated) {
          // All non-terminated numeric entities are not rendered, and trigger a
          // warning.
          warning(numericNotTerminated, diff);
        }

        // When terminated and number, parse as either hexadecimal or decimal.
        reference = parseInt(characters, bases[type]);

        // Trigger a warning when the parsed number is prohibited, and replace
        // with replacement character.
        if (prohibited(reference)) {
          warning(numericProhibited, diff);
          reference = fromCharCode(replacementCharacter);
        } else if (reference in invalid) {
          // Trigger a warning when the parsed number is disallowed, and replace
          // by an alternative.
          warning(numericDisallowed, diff);
          reference = invalid[reference];
        } else {
          // Parse the number.
          output = '';

          // Trigger a warning when the parsed number should not be used.
          if (disallowed(reference)) {
            warning(numericDisallowed, diff);
          }

          // Stringify the number.
          if (reference > 0xffff) {
            reference -= 0x10000;
            output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800);
            reference = 0xdc00 | (reference & 0x3ff);
          }

          reference = output + fromCharCode(reference);
        }
      }

      // Found it!
      // First eat the queued characters as normal text, then eat an entity.
      if (reference) {
        flush();

        prev = now();
        index = end - 1;
        column += end - start + 1;
        result.push(reference);
        next = now();
        next.offset++;

        if (handleReference) {
          handleReference.call(
            referenceContext,
            reference,
            {start: prev, end: next},
            value.slice(start - 1, end)
          );
        }

        prev = next;
      } else {
        // If we could not find a reference, queue the checked characters (as
        // normal characters), and move the pointer to their end.
        // This is possible because we can be certain neither newlines nor
        // ampersands are included.
        characters = value.slice(start - 1, end);
        queue += characters;
        column += characters.length;
        index = end - 1;
      }
    } else {
      // Handle anything other than an ampersand, including newlines and EOF.
      if (
        character === 10 // Line feed
      ) {
        line++;
        lines++;
        column = 0;
      }

      if (character === character) {
        queue += fromCharCode(character);
        column++;
      } else {
        flush();
      }
    }
  }

  // Return the reduced nodes, and any possible warnings.
  return result.join('')

  // Get current position.
  function now() {
    return {
      line: line,
      column: column,
      offset: index + (pos.offset || 0)
    }
  }

  // ‚ÄúThrow‚Äù a parse-error: a warning.
  function parseError(code, offset) {
    var position = now();

    position.column += offset;
    position.offset += offset;

    handleWarning.call(warningContext, messages[code], position, code);
  }

  // Flush `queue` (normal text).
  // Macro invoked before each entity and at the end of `value`.
  // Does nothing when `queue` is empty.
  function flush() {
    if (queue) {
      result.push(queue);

      if (handleText) {
        handleText.call(textContext, queue, {start: prev, end: now()});
      }

      queue = '';
    }
  }
}

// Check if `character` is outside the permissible unicode range.
function prohibited(code) {
  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff
}

// Check if `character` is disallowed.
function disallowed(code) {
  return (
    (code >= 0x0001 && code <= 0x0008) ||
    code === 0x000b ||
    (code >= 0x000d && code <= 0x001f) ||
    (code >= 0x007f && code <= 0x009f) ||
    (code >= 0xfdd0 && code <= 0xfdef) ||
    (code & 0xffff) === 0xffff ||
    (code & 0xffff) === 0xfffe
  )
}

var decode = factory$1;

/* Factory to create an entity decoder. */
function factory$1(ctx) {
  decoder.raw = decodeRaw;

  return decoder;

  /* Normalize `position` to add an `indent`. */
  function normalize(position) {
    var offsets = ctx.offset;
    var line = position.line;
    var result = [];

    while (++line) {
      if (!(line in offsets)) {
        break;
      }

      result.push((offsets[line] || 0) + 1);
    }

    return {
      start: position,
      indent: result
    };
  }

  /* Handle a warning.
   * See https://github.com/wooorm/parse-entities
   * for the warnings. */
  function handleWarning(reason, position, code) {
    if (code === 3) {
      return;
    }

    ctx.file.message(reason, position);
  }

  /* Decode `value` (at `position`) into text-nodes. */
  function decoder(value, position, handler) {
    parseEntities_1(value, {
      position: normalize(position),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }

  /* Decode `value` (at `position`) into a string. */
  function decodeRaw(value, position, options) {
    return parseEntities_1(value, immutable(options, {
      position: normalize(position),
      warning: handleWarning
    }));
  }
}

var tokenizer = factory;

var MERGEABLE_NODES = {
  text: mergeText,
  blockquote: mergeBlockquote
};

/* Check whether a node is mergeable with adjacent nodes. */
function mergeable(node) {
  var start;
  var end;

  if (node.type !== 'text' || !node.position) {
    return true;
  }

  start = node.position.start;
  end = node.position.end;

  /* Only merge nodes which occupy the same size as their
   * `value`. */
  return start.line !== end.line ||
      end.column - start.column === node.value.length;
}

/* Merge two text nodes: `node` into `prev`. */
function mergeText(prev, node) {
  prev.value += node.value;

  return prev;
}

/* Merge two blockquotes: `node` into `prev`, unless in
 * CommonMark mode. */
function mergeBlockquote(prev, node) {
  if (this.options.commonmark) {
    return node;
  }

  prev.children = prev.children.concat(node.children);

  return prev;
}

/* Construct a tokenizer.  This creates both
 * `tokenizeInline` and `tokenizeBlock`. */
function factory(type) {
  return tokenize;

  /* Tokenizer for a bound `type`. */
  function tokenize(value, location) {
    var self = this;
    var offset = self.offset;
    var tokens = [];
    var methods = self[type + 'Methods'];
    var tokenizers = self[type + 'Tokenizers'];
    var line = location.line;
    var column = location.column;
    var index;
    var length;
    var method;
    var name;
    var matched;
    var valueLength;

    /* Trim white space only lines. */
    if (!value) {
      return tokens;
    }

    /* Expose on `eat`. */
    eat.now = now;
    eat.file = self.file;

    /* Sync initial offset. */
    updatePosition('');

    /* Iterate over `value`, and iterate over all
     * tokenizers.  When one eats something, re-iterate
     * with the remaining value.  If no tokenizer eats,
     * something failed (should not happen) and an
     * exception is thrown. */
    while (value) {
      index = -1;
      length = methods.length;
      matched = false;

      while (++index < length) {
        name = methods[index];
        method = tokenizers[name];

        if (
          method &&
          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&
          (!method.notInList || !self.inList) &&
          (!method.notInBlock || !self.inBlock) &&
          (!method.notInLink || !self.inLink)
        ) {
          valueLength = value.length;

          method.apply(self, [eat, value]);

          matched = valueLength !== value.length;

          if (matched) {
            break;
          }
        }
      }

      /* istanbul ignore if */
      if (!matched) {
        self.file.fail(new Error('Infinite loop'), eat.now());
      }
    }

    self.eof = now();

    return tokens;

    /* Update line, column, and offset based on
     * `value`. */
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index = subvalue.indexOf('\n');

      while (index !== -1) {
        line++;
        lastIndex = index;
        index = subvalue.indexOf('\n', index + 1);
      }

      if (lastIndex === -1) {
        column += subvalue.length;
      } else {
        column = subvalue.length - lastIndex;
      }

      if (line in offset) {
        if (lastIndex !== -1) {
          column += offset[line];
        } else if (column <= offset[line]) {
          column = offset[line] + 1;
        }
      }
    }

    /* Get offset.  Called before the first character is
     * eaten to retrieve the range's offsets. */
    function getOffset() {
      var indentation = [];
      var pos = line + 1;

      /* Done.  Called when the last character is
       * eaten to retrieve the range‚Äôs offsets. */
      return function () {
        var last = line + 1;

        while (pos < last) {
          indentation.push((offset[pos] || 0) + 1);

          pos++;
        }

        return indentation;
      };
    }

    /* Get the current position. */
    function now() {
      var pos = {line: line, column: column};

      pos.offset = self.toOffset(pos);

      return pos;
    }

    /* Store position information for a node. */
    function Position(start) {
      this.start = start;
      this.end = now();
    }

    /* Throw when a value is incorrectly eaten.
     * This shouldn‚Äôt happen but will throw on new,
     * incorrect rules. */
    function validateEat(subvalue) {
      /* istanbul ignore if */
      if (value.substring(0, subvalue.length) !== subvalue) {
        /* Capture stack-trace. */
        self.file.fail(
          new Error(
            'Incorrectly eaten value: please report this ' +
            'warning on http://git.io/vg5Ft'
          ),
          now()
        );
      }
    }

    /* Mark position and patch `node.position`. */
    function position() {
      var before = now();

      return update;

      /* Add the position to a node. */
      function update(node, indent) {
        var prev = node.position;
        var start = prev ? prev.start : before;
        var combined = [];
        var n = prev && prev.end.line;
        var l = before.line;

        node.position = new Position(start);

        /* If there was already a `position`, this
         * node was merged.  Fixing `start` wasn‚Äôt
         * hard, but the indent is different.
         * Especially because some information, the
         * indent between `n` and `l` wasn‚Äôt
         * tracked.  Luckily, that space is
         * (should be?) empty, so we can safely
         * check for it now. */
        if (prev && indent && prev.indent) {
          combined = prev.indent;

          if (n < l) {
            while (++n < l) {
              combined.push((offset[n] || 0) + 1);
            }

            combined.push(before.column);
          }

          indent = combined.concat(indent);
        }

        node.position.indent = indent || [];

        return node;
      }
    }

    /* Add `node` to `parent`s children or to `tokens`.
     * Performs merges where possible. */
    function add(node, parent) {
      var children = parent ? parent.children : tokens;
      var prev = children[children.length - 1];

      if (
        prev &&
        node.type === prev.type &&
        node.type in MERGEABLE_NODES &&
        mergeable(prev) &&
        mergeable(node)
      ) {
        node = MERGEABLE_NODES[node.type].call(self, prev, node);
      }

      if (node !== prev) {
        children.push(node);
      }

      if (self.atStart && tokens.length !== 0) {
        self.exitStart();
      }

      return node;
    }

    /* Remove `subvalue` from `value`.
     * `subvalue` must be at the start of `value`. */
    function eat(subvalue) {
      var indent = getOffset();
      var pos = position();
      var current = now();

      validateEat(subvalue);

      apply.reset = reset;
      reset.test = test;
      apply.test = test;

      value = value.substring(subvalue.length);

      updatePosition(subvalue);

      indent = indent();

      return apply;

      /* Add the given arguments, add `position` to
       * the returned node, and return the node. */
      function apply(node, parent) {
        return pos(add(pos(node), parent), indent);
      }

      /* Functions just like apply, but resets the
       * content:  the line and column are reversed,
       * and the eaten value is re-added.
       * This is useful for nodes with a single
       * type of content, such as lists and tables.
       * See `apply` above for what parameters are
       * expected. */
      function reset() {
        var node = apply.apply(null, arguments);

        line = current.line;
        column = current.column;
        value = subvalue + value;

        return node;
      }

      /* Test the position, after eating, and reverse
       * to a not-eaten state. */
      function test() {
        var result = pos({});

        line = current.line;
        column = current.column;
        value = subvalue + value;

        return result.position;
      }
    }
  }
}

var markdownEscapes = escapes;

var defaults$1 = [
  '\\',
  '`',
  '*',
  '{',
  '}',
  '[',
  ']',
  '(',
  ')',
  '#',
  '+',
  '-',
  '.',
  '!',
  '_',
  '>'
];

var gfm = defaults$1.concat(['~', '|']);

var commonmark = gfm.concat([
  '\n',
  '"',
  '$',
  '%',
  '&',
  "'",
  ',',
  '/',
  ':',
  ';',
  '<',
  '=',
  '?',
  '@',
  '^'
]);

escapes.default = defaults$1;
escapes.gfm = gfm;
escapes.commonmark = commonmark;

// Get markdown escapes.
function escapes(options) {
  var settings = options || {};

  if (settings.commonmark) {
    return commonmark
  }

  return settings.gfm ? gfm : defaults$1
}

var require$$0 = [
	"address",
	"article",
	"aside",
	"base",
	"basefont",
	"blockquote",
	"body",
	"caption",
	"center",
	"col",
	"colgroup",
	"dd",
	"details",
	"dialog",
	"dir",
	"div",
	"dl",
	"dt",
	"fieldset",
	"figcaption",
	"figure",
	"footer",
	"form",
	"frame",
	"frameset",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"iframe",
	"legend",
	"li",
	"link",
	"main",
	"menu",
	"menuitem",
	"meta",
	"nav",
	"noframes",
	"ol",
	"optgroup",
	"option",
	"p",
	"param",
	"pre",
	"section",
	"source",
	"title",
	"summary",
	"table",
	"tbody",
	"td",
	"tfoot",
	"th",
	"thead",
	"title",
	"tr",
	"track",
	"ul"
];

var defaults = {
  position: true,
  gfm: true,
  commonmark: false,
  footnotes: false,
  pedantic: false,
  blocks: require$$0
};

var setOptions_1 = setOptions;

function setOptions(options) {
  var self = this;
  var current = self.options;
  var key;
  var value;

  if (options == null) {
    options = {};
  } else if (typeof options === 'object') {
    options = immutable(options);
  } else {
    throw new Error(
      'Invalid value `' + options + '` ' +
      'for setting `options`'
    );
  }

  for (key in defaults) {
    value = options[key];

    if (value == null) {
      value = current[key];
    }

    if (
      (key !== 'blocks' && typeof value !== 'boolean') ||
      (key === 'blocks' && typeof value !== 'object')
    ) {
      throw new Error('Invalid value `' + value + '` for setting `options.' + key + '`');
    }

    options[key] = value;
  }

  self.options = options;
  self.escape = markdownEscapes(options);

  return self;
}

var convert_1 = convert;

function convert(test) {
  if (typeof test === 'string') {
    return typeFactory(test)
  }

  if (test === null || test === undefined) {
    return ok
  }

  if (typeof test === 'object') {
    return ('length' in test ? anyFactory : matchesFactory)(test)
  }

  if (typeof test === 'function') {
    return test
  }

  throw new Error('Expected function, string, or object as test')
}

function convertAll(tests) {
  var results = [];
  var length = tests.length;
  var index = -1;

  while (++index < length) {
    results[index] = convert(tests[index]);
  }

  return results
}

// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function matchesFactory(test) {
  return matches

  function matches(node) {
    var key;

    for (key in test) {
      if (node[key] !== test[key]) {
        return false
      }
    }

    return true
  }
}

function anyFactory(tests) {
  var checks = convertAll(tests);
  var length = checks.length;

  return matches

  function matches() {
    var index = -1;

    while (++index < length) {
      if (checks[index].apply(this, arguments)) {
        return true
      }
    }

    return false
  }
}

// Utility to convert a string into a function which checks a given node‚Äôs type
// for said string.
function typeFactory(test) {
  return type

  function type(node) {
    return Boolean(node && node.type === test)
  }
}

// Utility to return true.
function ok() {
  return true
}

var unistUtilVisitParents = visitParents;



var CONTINUE$1 = true;
var SKIP$1 = 'skip';
var EXIT$1 = false;

visitParents.CONTINUE = CONTINUE$1;
visitParents.SKIP = SKIP$1;
visitParents.EXIT = EXIT$1;

function visitParents(tree, test, visitor, reverse) {
  var is;

  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor;
    visitor = test;
    test = null;
  }

  is = convert_1(test);

  one(tree, null, []);

  // Visit a single node.
  function one(node, index, parents) {
    var result = [];
    var subresult;

    if (!test || is(node, index, parents[parents.length - 1] || null)) {
      result = toResult(visitor(node, parents));

      if (result[0] === EXIT$1) {
        return result
      }
    }

    if (node.children && result[0] !== SKIP$1) {
      subresult = toResult(all(node.children, parents.concat(node)));
      return subresult[0] === EXIT$1 ? subresult : result
    }

    return result
  }

  // Visit children in `parent`.
  function all(children, parents) {
    var min = -1;
    var step = reverse ? -1 : 1;
    var index = (reverse ? children.length : min) + step;
    var result;

    while (index > min && index < children.length) {
      result = one(children[index], index, parents);

      if (result[0] === EXIT$1) {
        return result
      }

      index = typeof result[1] === 'number' ? result[1] : index + step;
    }
  }
}

function toResult(value) {
  if (value !== null && typeof value === 'object' && 'length' in value) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE$1, value]
  }

  return [value]
}

var unistUtilVisit = visit;



var CONTINUE = unistUtilVisitParents.CONTINUE;
var SKIP = unistUtilVisitParents.SKIP;
var EXIT = unistUtilVisitParents.EXIT;

visit.CONTINUE = CONTINUE;
visit.SKIP = SKIP;
visit.EXIT = EXIT;

function visit(tree, test, visitor, reverse) {
  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor;
    visitor = test;
    test = null;
  }

  unistUtilVisitParents(tree, test, overload, reverse);

  function overload(node, parents) {
    var parent = parents[parents.length - 1];
    var index = parent ? parent.children.indexOf(node) : null;
    return visitor(node, index, parent)
  }
}

var unistUtilRemovePosition = removePosition;

function removePosition(node, force) {
  unistUtilVisit(node, force ? hard : soft);
  return node
}

function hard(node) {
  delete node.position;
}

function soft(node) {
  node.position = undefined;
}

var parse_1 = parse$1;

var C_NEWLINE$d = '\n';
var EXPRESSION_LINE_BREAKS = /\r\n|\r/g;

/* Parse the bound file. */
function parse$1() {
  var self = this;
  var value = String(self.file);
  var start = {line: 1, column: 1, offset: 0};
  var content = immutable(start);
  var node;

  /* Clean non-unix newlines: `\r\n` and `\r` are all
   * changed to `\n`.  This should not affect positional
   * information. */
  value = value.replace(EXPRESSION_LINE_BREAKS, C_NEWLINE$d);

  if (value.charCodeAt(0) === 0xFEFF) {
    value = value.slice(1);

    content.column++;
    content.offset++;
  }

  node = {
    type: 'root',
    children: self.tokenizeBlock(value, content),
    position: {
      start: start,
      end: self.eof || immutable(start)
    }
  };

  if (!self.options.position) {
    unistUtilRemovePosition(node, true);
  }

  return node;
}

var isWhitespaceCharacter = whitespace;

var fromCode$1 = String.fromCharCode;
var re$1 = /\s/;

// Check if the given character code, or the character code at the first
// character, is a whitespace character.
function whitespace(character) {
  return re$1.test(
    typeof character === 'number' ? fromCode$1(character) : character.charAt(0)
  )
}

var newline_1 = newline;

/* Tokenise newline. */
function newline(eat, value, silent) {
  var character = value.charAt(0);
  var length;
  var subvalue;
  var queue;
  var index;

  if (character !== '\n') {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  index = 1;
  length = value.length;
  subvalue = character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!isWhitespaceCharacter(character)) {
      break;
    }

    queue += character;

    if (character === '\n') {
      subvalue += queue;
      queue = '';
    }

    index++;
  }

  eat(subvalue);
}

/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

var repeatString = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

var trimTrailingLines_1 = trimTrailingLines;

// Remove final newline characters from `value`.
function trimTrailingLines(value) {
  return String(value).replace(/\n+$/, '')
}

var codeIndented = indentedCode;

var C_NEWLINE$c = '\n';
var C_TAB$c = '\t';
var C_SPACE$c = ' ';

var CODE_INDENT_COUNT$1 = 4;
var CODE_INDENT = repeatString(C_SPACE$c, CODE_INDENT_COUNT$1);

/* Tokenise indented code. */
function indentedCode(eat, value, silent) {
  var index = -1;
  var length = value.length;
  var subvalue = '';
  var content = '';
  var subvalueQueue = '';
  var contentQueue = '';
  var character;
  var blankQueue;
  var indent;

  while (++index < length) {
    character = value.charAt(index);

    if (indent) {
      indent = false;

      subvalue += subvalueQueue;
      content += contentQueue;
      subvalueQueue = '';
      contentQueue = '';

      if (character === C_NEWLINE$c) {
        subvalueQueue = character;
        contentQueue = character;
      } else {
        subvalue += character;
        content += character;

        while (++index < length) {
          character = value.charAt(index);

          if (!character || character === C_NEWLINE$c) {
            contentQueue = character;
            subvalueQueue = character;
            break;
          }

          subvalue += character;
          content += character;
        }
      }
    } else if (
      character === C_SPACE$c &&
      value.charAt(index + 1) === character &&
      value.charAt(index + 2) === character &&
      value.charAt(index + 3) === character
    ) {
      subvalueQueue += CODE_INDENT;
      index += 3;
      indent = true;
    } else if (character === C_TAB$c) {
      subvalueQueue += character;
      indent = true;
    } else {
      blankQueue = '';

      while (character === C_TAB$c || character === C_SPACE$c) {
        blankQueue += character;
        character = value.charAt(++index);
      }

      if (character !== C_NEWLINE$c) {
        break;
      }

      subvalueQueue += blankQueue + character;
      contentQueue += character;
    }
  }

  if (content) {
    if (silent) {
      return true;
    }

    return eat(subvalue)({
      type: 'code',
      lang: null,
      value: trimTrailingLines_1(content)
    });
  }
}

var codeFenced = fencedCode;

var C_NEWLINE$b = '\n';
var C_TAB$b = '\t';
var C_SPACE$b = ' ';
var C_TILDE$1 = '~';
var C_TICK$3 = '`';

var MIN_FENCE_COUNT = 3;
var CODE_INDENT_COUNT = 4;

function fencedCode(eat, value, silent) {
  var self = this;
  var settings = self.options;
  var length = value.length + 1;
  var index = 0;
  var subvalue = '';
  var fenceCount;
  var marker;
  var character;
  var flag;
  var queue;
  var content;
  var exdentedContent;
  var closing;
  var exdentedClosing;
  var indent;
  var now;

  if (!settings.gfm) {
    return;
  }

  /* Eat initial spacing. */
  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE$b && character !== C_TAB$b) {
      break;
    }

    subvalue += character;
    index++;
  }

  indent = index;

  /* Eat the fence. */
  character = value.charAt(index);

  if (character !== C_TILDE$1 && character !== C_TICK$3) {
    return;
  }

  index++;
  marker = character;
  fenceCount = 1;
  subvalue += character;

  while (index < length) {
    character = value.charAt(index);

    if (character !== marker) {
      break;
    }

    subvalue += character;
    fenceCount++;
    index++;
  }

  if (fenceCount < MIN_FENCE_COUNT) {
    return;
  }

  /* Eat spacing before flag. */
  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE$b && character !== C_TAB$b) {
      break;
    }

    subvalue += character;
    index++;
  }

  /* Eat flag. */
  flag = '';
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (
      character === C_NEWLINE$b ||
      character === C_TILDE$1 ||
      character === C_TICK$3
    ) {
      break;
    }

    if (character === C_SPACE$b || character === C_TAB$b) {
      queue += character;
    } else {
      flag += queue + character;
      queue = '';
    }

    index++;
  }

  character = value.charAt(index);

  if (character && character !== C_NEWLINE$b) {
    return;
  }

  if (silent) {
    return true;
  }

  now = eat.now();
  now.column += subvalue.length;
  now.offset += subvalue.length;

  subvalue += flag;
  flag = self.decode.raw(self.unescape(flag), now);

  if (queue) {
    subvalue += queue;
  }

  queue = '';
  closing = '';
  exdentedClosing = '';
  content = '';
  exdentedContent = '';

  /* Eat content. */
  while (index < length) {
    character = value.charAt(index);
    content += closing;
    exdentedContent += exdentedClosing;
    closing = '';
    exdentedClosing = '';

    if (character !== C_NEWLINE$b) {
      content += character;
      exdentedClosing += character;
      index++;
      continue;
    }

    /* Add the newline to `subvalue` if its the first
     * character.  Otherwise, add it to the `closing`
     * queue. */
    if (content) {
      closing += character;
      exdentedClosing += character;
    } else {
      subvalue += character;
    }

    queue = '';
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (character !== C_SPACE$b) {
        break;
      }

      queue += character;
      index++;
    }

    closing += queue;
    exdentedClosing += queue.slice(indent);

    if (queue.length >= CODE_INDENT_COUNT) {
      continue;
    }

    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character !== marker) {
        break;
      }

      queue += character;
      index++;
    }

    closing += queue;
    exdentedClosing += queue;

    if (queue.length < fenceCount) {
      continue;
    }

    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character !== C_SPACE$b && character !== C_TAB$b) {
        break;
      }

      closing += character;
      exdentedClosing += character;
      index++;
    }

    if (!character || character === C_NEWLINE$b) {
      break;
    }
  }

  subvalue += content + closing;

  return eat(subvalue)({
    type: 'code',
    lang: flag || null,
    value: trimTrailingLines_1(exdentedContent)
  });
}

var trim_1 = createCommonjsModule(function (module, exports) {
exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};
});

var interrupt_1 = interrupt;

function interrupt(interruptors, tokenizers, ctx, params) {
  var bools = ['pedantic', 'commonmark'];
  var count = bools.length;
  var length = interruptors.length;
  var index = -1;
  var interruptor;
  var config;
  var fn;
  var offset;
  var bool;
  var ignore;

  while (++index < length) {
    interruptor = interruptors[index];
    config = interruptor[1] || {};
    fn = interruptor[0];
    offset = -1;
    ignore = false;

    while (++offset < count) {
      bool = bools[offset];

      if (config[bool] !== undefined && config[bool] !== ctx.options[bool]) {
        ignore = true;
        break;
      }
    }

    if (ignore) {
      continue;
    }

    if (tokenizers[fn].apply(ctx, params)) {
      return true;
    }
  }

  return false;
}

var blockquote_1 = blockquote;

var C_NEWLINE$a = '\n';
var C_TAB$a = '\t';
var C_SPACE$a = ' ';
var C_GT$3 = '>';

/* Tokenise a blockquote. */
function blockquote(eat, value, silent) {
  var self = this;
  var offsets = self.offset;
  var tokenizers = self.blockTokenizers;
  var interruptors = self.interruptBlockquote;
  var now = eat.now();
  var currentLine = now.line;
  var length = value.length;
  var values = [];
  var contents = [];
  var indents = [];
  var add;
  var index = 0;
  var character;
  var rest;
  var nextIndex;
  var content;
  var line;
  var startIndex;
  var prefixed;
  var exit;

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE$a && character !== C_TAB$a) {
      break;
    }

    index++;
  }

  if (value.charAt(index) !== C_GT$3) {
    return;
  }

  if (silent) {
    return true;
  }

  index = 0;

  while (index < length) {
    nextIndex = value.indexOf(C_NEWLINE$a, index);
    startIndex = index;
    prefixed = false;

    if (nextIndex === -1) {
      nextIndex = length;
    }

    while (index < length) {
      character = value.charAt(index);

      if (character !== C_SPACE$a && character !== C_TAB$a) {
        break;
      }

      index++;
    }

    if (value.charAt(index) === C_GT$3) {
      index++;
      prefixed = true;

      if (value.charAt(index) === C_SPACE$a) {
        index++;
      }
    } else {
      index = startIndex;
    }

    content = value.slice(index, nextIndex);

    if (!prefixed && !trim_1(content)) {
      index = startIndex;
      break;
    }

    if (!prefixed) {
      rest = value.slice(index);

      /* Check if the following code contains a possible
       * block. */
      if (interrupt_1(interruptors, tokenizers, self, [eat, rest, true])) {
        break;
      }
    }

    line = startIndex === index ? content : value.slice(startIndex, nextIndex);

    indents.push(index - startIndex);
    values.push(line);
    contents.push(content);

    index = nextIndex + 1;
  }

  index = -1;
  length = indents.length;
  add = eat(values.join(C_NEWLINE$a));

  while (++index < length) {
    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
    currentLine++;
  }

  exit = self.enterBlock();
  contents = self.tokenizeBlock(contents.join(C_NEWLINE$a), now);
  exit();

  return add({
    type: 'blockquote',
    children: contents
  });
}

var headingAtx = atxHeading;

var C_NEWLINE$9 = '\n';
var C_TAB$9 = '\t';
var C_SPACE$9 = ' ';
var C_HASH = '#';

var MAX_ATX_COUNT = 6;

function atxHeading(eat, value, silent) {
  var self = this;
  var settings = self.options;
  var length = value.length + 1;
  var index = -1;
  var now = eat.now();
  var subvalue = '';
  var content = '';
  var character;
  var queue;
  var depth;

  /* Eat initial spacing. */
  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE$9 && character !== C_TAB$9) {
      index--;
      break;
    }

    subvalue += character;
  }

  /* Eat hashes. */
  depth = 0;

  while (++index <= length) {
    character = value.charAt(index);

    if (character !== C_HASH) {
      index--;
      break;
    }

    subvalue += character;
    depth++;
  }

  if (depth > MAX_ATX_COUNT) {
    return;
  }

  if (
    !depth ||
    (!settings.pedantic && value.charAt(index + 1) === C_HASH)
  ) {
    return;
  }

  length = value.length + 1;

  /* Eat intermediate white-space. */
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE$9 && character !== C_TAB$9) {
      index--;
      break;
    }

    queue += character;
  }

  /* Exit when not in pedantic mode without spacing. */
  if (
    !settings.pedantic &&
    queue.length === 0 &&
    character &&
    character !== C_NEWLINE$9
  ) {
    return;
  }

  if (silent) {
    return true;
  }

  /* Eat content. */
  subvalue += queue;
  queue = '';
  content = '';

  while (++index < length) {
    character = value.charAt(index);

    if (!character || character === C_NEWLINE$9) {
      break;
    }

    if (
      character !== C_SPACE$9 &&
      character !== C_TAB$9 &&
      character !== C_HASH
    ) {
      content += queue + character;
      queue = '';
      continue;
    }

    while (character === C_SPACE$9 || character === C_TAB$9) {
      queue += character;
      character = value.charAt(++index);
    }

    while (character === C_HASH) {
      queue += character;
      character = value.charAt(++index);
    }

    while (character === C_SPACE$9 || character === C_TAB$9) {
      queue += character;
      character = value.charAt(++index);
    }

    index--;
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;

  return eat(subvalue)({
    type: 'heading',
    depth: depth,
    children: self.tokenizeInline(content, now)
  });
}

var thematicBreak_1 = thematicBreak;

var C_NEWLINE$8 = '\n';
var C_TAB$8 = '\t';
var C_SPACE$8 = ' ';
var C_ASTERISK$3 = '*';
var C_UNDERSCORE$3 = '_';
var C_DASH$3 = '-';

var THEMATIC_BREAK_MARKER_COUNT = 3;

function thematicBreak(eat, value, silent) {
  var index = -1;
  var length = value.length + 1;
  var subvalue = '';
  var character;
  var marker;
  var markerCount;
  var queue;

  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_TAB$8 && character !== C_SPACE$8) {
      break;
    }

    subvalue += character;
  }

  if (
    character !== C_ASTERISK$3 &&
    character !== C_DASH$3 &&
    character !== C_UNDERSCORE$3
  ) {
    return;
  }

  marker = character;
  subvalue += character;
  markerCount = 1;
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character === marker) {
      markerCount++;
      subvalue += queue + marker;
      queue = '';
    } else if (character === C_SPACE$8) {
      queue += character;
    } else if (
      markerCount >= THEMATIC_BREAK_MARKER_COUNT &&
      (!character || character === C_NEWLINE$8)
    ) {
      subvalue += queue;

      if (silent) {
        return true;
      }

      return eat(subvalue)({type: 'thematicBreak'});
    } else {
      return;
    }
  }
}

var getIndentation = indentation$1;

/* Map of characters, and their column length,
 * which can be used as indentation. */
var characters = {' ': 1, '\t': 4};

/* Gets indentation information for a line. */
function indentation$1(value) {
  var index = 0;
  var indent = 0;
  var character = value.charAt(index);
  var stops = {};
  var size;

  while (character in characters) {
    size = characters[character];

    indent += size;

    if (size > 1) {
      indent = Math.floor(indent / size) * size;
    }

    stops[indent] = index;

    character = value.charAt(++index);
  }

  return {indent: indent, stops: stops};
}

var removeIndentation = indentation;

var C_SPACE$7 = ' ';
var C_NEWLINE$7 = '\n';
var C_TAB$7 = '\t';

/* Remove the minimum indent from every line in `value`.
 * Supports both tab, spaced, and mixed indentation (as
 * well as possible). */
function indentation(value, maximum) {
  var values = value.split(C_NEWLINE$7);
  var position = values.length + 1;
  var minIndent = Infinity;
  var matrix = [];
  var index;
  var indentation;
  var stops;
  var padding;

  values.unshift(repeatString(C_SPACE$7, maximum) + '!');

  while (position--) {
    indentation = getIndentation(values[position]);

    matrix[position] = indentation.stops;

    if (trim_1(values[position]).length === 0) {
      continue;
    }

    if (indentation.indent) {
      if (indentation.indent > 0 && indentation.indent < minIndent) {
        minIndent = indentation.indent;
      }
    } else {
      minIndent = Infinity;

      break;
    }
  }

  if (minIndent !== Infinity) {
    position = values.length;

    while (position--) {
      stops = matrix[position];
      index = minIndent;

      while (index && !(index in stops)) {
        index--;
      }

      if (
        trim_1(values[position]).length !== 0 &&
        minIndent &&
        index !== minIndent
      ) {
        padding = C_TAB$7;
      } else {
        padding = '';
      }

      values[position] = padding + values[position].slice(
        index in stops ? stops[index] + 1 : 0
      );
    }
  }

  values.shift();

  return values.join(C_NEWLINE$7);
}

/* eslint-disable max-params */








var list_1 = list;

var C_ASTERISK$2 = '*';
var C_UNDERSCORE$2 = '_';
var C_PLUS = '+';
var C_DASH$2 = '-';
var C_DOT = '.';
var C_SPACE$6 = ' ';
var C_NEWLINE$6 = '\n';
var C_TAB$6 = '\t';
var C_PAREN_CLOSE$3 = ')';
var C_X_LOWER = 'x';

var TAB_SIZE$1 = 4;
var EXPRESSION_LOOSE_LIST_ITEM = /\n\n(?!\s*$)/;
var EXPRESSION_TASK_ITEM = /^\[([ \t]|x|X)][ \t]/;
var EXPRESSION_BULLET = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var EXPRESSION_PEDANTIC_BULLET = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var EXPRESSION_INITIAL_INDENT = /^( {1,4}|\t)?/gm;

/* Map of characters which can be used to mark
 * list-items. */
var LIST_UNORDERED_MARKERS = {};

LIST_UNORDERED_MARKERS[C_ASTERISK$2] = true;
LIST_UNORDERED_MARKERS[C_PLUS] = true;
LIST_UNORDERED_MARKERS[C_DASH$2] = true;

/* Map of characters which can be used to mark
 * list-items after a digit. */
var LIST_ORDERED_MARKERS = {};

LIST_ORDERED_MARKERS[C_DOT] = true;

/* Map of characters which can be used to mark
 * list-items after a digit. */
var LIST_ORDERED_COMMONMARK_MARKERS = {};

LIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;
LIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE$3] = true;

function list(eat, value, silent) {
  var self = this;
  var commonmark = self.options.commonmark;
  var pedantic = self.options.pedantic;
  var tokenizers = self.blockTokenizers;
  var interuptors = self.interruptList;
  var markers;
  var index = 0;
  var length = value.length;
  var start = null;
  var size = 0;
  var queue;
  var ordered;
  var character;
  var marker;
  var nextIndex;
  var startIndex;
  var prefixed;
  var currentMarker;
  var content;
  var line;
  var prevEmpty;
  var empty;
  var items;
  var allLines;
  var emptyLines;
  var item;
  var enterTop;
  var exitBlockquote;
  var isLoose;
  var node;
  var now;
  var end;
  var indented;

  while (index < length) {
    character = value.charAt(index);

    if (character === C_TAB$6) {
      size += TAB_SIZE$1 - (size % TAB_SIZE$1);
    } else if (character === C_SPACE$6) {
      size++;
    } else {
      break;
    }

    index++;
  }

  if (size >= TAB_SIZE$1) {
    return;
  }

  character = value.charAt(index);

  markers = commonmark ?
    LIST_ORDERED_COMMONMARK_MARKERS :
    LIST_ORDERED_MARKERS;

  if (LIST_UNORDERED_MARKERS[character] === true) {
    marker = character;
    ordered = false;
  } else {
    ordered = true;
    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (!isDecimal(character)) {
        break;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (!queue || markers[character] !== true) {
      return;
    }

    start = parseInt(queue, 10);
    marker = character;
  }

  character = value.charAt(++index);

  if (character !== C_SPACE$6 && character !== C_TAB$6) {
    return;
  }

  if (silent) {
    return true;
  }

  index = 0;
  items = [];
  allLines = [];
  emptyLines = [];

  while (index < length) {
    nextIndex = value.indexOf(C_NEWLINE$6, index);
    startIndex = index;
    prefixed = false;
    indented = false;

    if (nextIndex === -1) {
      nextIndex = length;
    }

    end = index + TAB_SIZE$1;
    size = 0;

    while (index < length) {
      character = value.charAt(index);

      if (character === C_TAB$6) {
        size += TAB_SIZE$1 - (size % TAB_SIZE$1);
      } else if (character === C_SPACE$6) {
        size++;
      } else {
        break;
      }

      index++;
    }

    if (size >= TAB_SIZE$1) {
      indented = true;
    }

    if (item && size >= item.indent) {
      indented = true;
    }

    character = value.charAt(index);
    currentMarker = null;

    if (!indented) {
      if (LIST_UNORDERED_MARKERS[character] === true) {
        currentMarker = character;
        index++;
        size++;
      } else {
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (!isDecimal(character)) {
            break;
          }

          queue += character;
          index++;
        }

        character = value.charAt(index);
        index++;

        if (queue && markers[character] === true) {
          currentMarker = character;
          size += queue.length + 1;
        }
      }

      if (currentMarker) {
        character = value.charAt(index);

        if (character === C_TAB$6) {
          size += TAB_SIZE$1 - (size % TAB_SIZE$1);
          index++;
        } else if (character === C_SPACE$6) {
          end = index + TAB_SIZE$1;

          while (index < end) {
            if (value.charAt(index) !== C_SPACE$6) {
              break;
            }

            index++;
            size++;
          }

          if (index === end && value.charAt(index) === C_SPACE$6) {
            index -= TAB_SIZE$1 - 1;
            size -= TAB_SIZE$1 - 1;
          }
        } else if (character !== C_NEWLINE$6 && character !== '') {
          currentMarker = null;
        }
      }
    }

    if (currentMarker) {
      if (!pedantic && marker !== currentMarker) {
        break;
      }

      prefixed = true;
    } else {
      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE$6) {
        indented = true;
      } else if (commonmark && item) {
        indented = size >= item.indent || size > TAB_SIZE$1;
      }

      prefixed = false;
      index = startIndex;
    }

    line = value.slice(startIndex, nextIndex);
    content = startIndex === index ? line : value.slice(index, nextIndex);

    if (
      currentMarker === C_ASTERISK$2 ||
      currentMarker === C_UNDERSCORE$2 ||
      currentMarker === C_DASH$2
    ) {
      if (tokenizers.thematicBreak.call(self, eat, line, true)) {
        break;
      }
    }

    prevEmpty = empty;
    empty = !trim_1(content).length;

    if (indented && item) {
      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (prefixed) {
      if (emptyLines.length !== 0) {
        item.value.push('');
        item.trail = emptyLines.concat();
      }

      item = {
        value: [line],
        indent: size,
        trail: []
      };

      items.push(item);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (empty) {
      if (prevEmpty) {
        break;
      }

      emptyLines.push(line);
    } else {
      if (prevEmpty) {
        break;
      }

      if (interrupt_1(interuptors, tokenizers, self, [eat, line, true])) {
        break;
      }

      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    }

    index = nextIndex + 1;
  }

  node = eat(allLines.join(C_NEWLINE$6)).reset({
    type: 'list',
    ordered: ordered,
    start: start,
    loose: null,
    children: []
  });

  enterTop = self.enterList();
  exitBlockquote = self.enterBlock();
  isLoose = false;
  index = -1;
  length = items.length;

  while (++index < length) {
    item = items[index].value.join(C_NEWLINE$6);
    now = eat.now();

    item = eat(item)(listItem(self, item, now), node);

    if (item.loose) {
      isLoose = true;
    }

    item = items[index].trail.join(C_NEWLINE$6);

    if (index !== length - 1) {
      item += C_NEWLINE$6;
    }

    eat(item);
  }

  enterTop();
  exitBlockquote();

  node.loose = isLoose;

  return node;
}

function listItem(ctx, value, position) {
  var offsets = ctx.offset;
  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
  var checked = null;
  var task;
  var indent;

  value = fn.apply(null, arguments);

  if (ctx.options.gfm) {
    task = value.match(EXPRESSION_TASK_ITEM);

    if (task) {
      indent = task[0].length;
      checked = task[1].toLowerCase() === C_X_LOWER;
      offsets[position.line] += indent;
      value = value.slice(indent);
    }
  }

  return {
    type: 'listItem',
    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||
      value.charAt(value.length - 1) === C_NEWLINE$6,
    checked: checked,
    children: ctx.tokenizeBlock(value, position)
  };
}

/* Create a list-item using overly simple mechanics. */
function pedanticListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;

  /* Remove the list-item‚Äôs bullet. */
  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);

  /* The initial line was also matched by the below, so
   * we reset the `line`. */
  line = position.line;

  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);

  /* A simple replacer which removed all matches,
   * and adds their length to `offset`. */
  function replacer($0) {
    offsets[line] = (offsets[line] || 0) + $0.length;
    line++;

    return '';
  }
}

/* Create a list-item using sane mechanics. */
function normalListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;
  var max;
  var bullet;
  var rest;
  var lines;
  var trimmedLines;
  var index;
  var length;

  /* Remove the list-item‚Äôs bullet. */
  value = value.replace(EXPRESSION_BULLET, replacer);

  lines = value.split(C_NEWLINE$6);

  trimmedLines = removeIndentation(value, getIndentation(max).indent).split(C_NEWLINE$6);

  /* We replaced the initial bullet with something
   * else above, which was used to trick
   * `removeIndentation` into removing some more
   * characters when possible.  However, that could
   * result in the initial line to be stripped more
   * than it should be. */
  trimmedLines[0] = rest;

  offsets[line] = (offsets[line] || 0) + bullet.length;
  line++;

  index = 0;
  length = lines.length;

  while (++index < length) {
    offsets[line] = (offsets[line] || 0) +
      lines[index].length - trimmedLines[index].length;
    line++;
  }

  return trimmedLines.join(C_NEWLINE$6);

  function replacer($0, $1, $2, $3, $4) {
    bullet = $1 + $2 + $3;
    rest = $4;

    /* Make sure that the first nine numbered list items
     * can indent with an extra space.  That is, when
     * the bullet did not receive an extra final space. */
    if (Number($2) < 10 && bullet.length % 2 === 1) {
      $2 = C_SPACE$6 + $2;
    }

    max = $1 + repeatString(C_SPACE$6, $2.length) + $3;

    return max + rest;
  }
}

var headingSetext = setextHeading;

var C_NEWLINE$5 = '\n';
var C_TAB$5 = '\t';
var C_SPACE$5 = ' ';
var C_EQUALS = '=';
var C_DASH$1 = '-';

var MAX_HEADING_INDENT = 3;

/* Map of characters which can be used to mark setext
 * headers, mapping to their corresponding depth. */
var SETEXT_MARKERS = {};

SETEXT_MARKERS[C_EQUALS] = 1;
SETEXT_MARKERS[C_DASH$1] = 2;

function setextHeading(eat, value, silent) {
  var self = this;
  var now = eat.now();
  var length = value.length;
  var index = -1;
  var subvalue = '';
  var content;
  var queue;
  var character;
  var marker;
  var depth;

  /* Eat initial indentation. */
  while (++index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE$5 || index >= MAX_HEADING_INDENT) {
      index--;
      break;
    }

    subvalue += character;
  }

  /* Eat content. */
  content = '';
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character === C_NEWLINE$5) {
      index--;
      break;
    }

    if (character === C_SPACE$5 || character === C_TAB$5) {
      queue += character;
    } else {
      content += queue + character;
      queue = '';
    }
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;

  /* Ensure the content is followed by a newline and a
   * valid marker. */
  character = value.charAt(++index);
  marker = value.charAt(++index);

  if (character !== C_NEWLINE$5 || !SETEXT_MARKERS[marker]) {
    return;
  }

  subvalue += character;

  /* Eat Setext-line. */
  queue = marker;
  depth = SETEXT_MARKERS[marker];

  while (++index < length) {
    character = value.charAt(index);

    if (character !== marker) {
      if (character !== C_NEWLINE$5) {
        return;
      }

      index--;
      break;
    }

    queue += character;
  }

  if (silent) {
    return true;
  }

  return eat(subvalue + queue)({
    type: 'heading',
    depth: depth,
    children: self.tokenizeInline(content, now)
  });
}

var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
var singleQuoted = '\'[^\']*\'';
var doubleQuoted = '"[^"]*"';
var attributeValue = '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')';
var attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
var openTag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
var closeTag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Za-z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var openCloseTag$1 = new RegExp('^(?:' + openTag + '|' + closeTag + ')');

var tag$2 = new RegExp('^(?:' +
  openTag + '|' +
  closeTag + '|' +
  comment + '|' +
  processing + '|' +
  declaration + '|' +
  cdata +
')');

var html = {
	openCloseTag: openCloseTag$1,
	tag: tag$2
};

var openCloseTag = html.openCloseTag;

var htmlBlock = blockHTML;

var C_TAB$4 = '\t';
var C_SPACE$4 = ' ';
var C_NEWLINE$4 = '\n';
var C_LT$4 = '<';

function blockHTML(eat, value, silent) {
  var self = this;
  var blocks = self.options.blocks;
  var length = value.length;
  var index = 0;
  var next;
  var line;
  var offset;
  var character;
  var count;
  var sequence;
  var subvalue;

  var sequences = [
    [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true],
    [/^<!--/, /-->/, true],
    [/^<\?/, /\?>/, true],
    [/^<![A-Za-z]/, />/, true],
    [/^<!\[CDATA\[/, /\]\]>/, true],
    [new RegExp('^</?(' + blocks.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true],
    [new RegExp(openCloseTag.source + '\\s*$'), /^$/, false]
  ];

  /* Eat initial spacing. */
  while (index < length) {
    character = value.charAt(index);

    if (character !== C_TAB$4 && character !== C_SPACE$4) {
      break;
    }

    index++;
  }

  if (value.charAt(index) !== C_LT$4) {
    return;
  }

  next = value.indexOf(C_NEWLINE$4, index + 1);
  next = next === -1 ? length : next;
  line = value.slice(index, next);
  offset = -1;
  count = sequences.length;

  while (++offset < count) {
    if (sequences[offset][0].test(line)) {
      sequence = sequences[offset];
      break;
    }
  }

  if (!sequence) {
    return;
  }

  if (silent) {
    return sequence[2];
  }

  index = next;

  if (!sequence[1].test(line)) {
    while (index < length) {
      next = value.indexOf(C_NEWLINE$4, index + 1);
      next = next === -1 ? length : next;
      line = value.slice(index + 1, next);

      if (sequence[1].test(line)) {
        if (line) {
          index = next;
        }

        break;
      }

      index = next;
    }
  }

  subvalue = value.slice(0, index);

  return eat(subvalue)({type: 'html', value: subvalue});
}

var collapseWhiteSpace = collapse;

// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
function collapse(value) {
  return String(value).replace(/\s+/g, ' ')
}

var normalize_1 = normalize;

/* Normalize an identifier.  Collapses multiple white space
 * characters into a single space, and removes casing. */
function normalize(value) {
  return collapseWhiteSpace(value).toLowerCase();
}

var footnoteDefinition_1 = footnoteDefinition;
footnoteDefinition.notInList = true;
footnoteDefinition.notInBlock = true;

var C_BACKSLASH$4 = '\\';
var C_NEWLINE$3 = '\n';
var C_TAB$3 = '\t';
var C_SPACE$3 = ' ';
var C_BRACKET_OPEN$4 = '[';
var C_BRACKET_CLOSE$4 = ']';
var C_CARET$1 = '^';
var C_COLON$2 = ':';

var EXPRESSION_INITIAL_TAB = /^( {4}|\t)?/gm;

function footnoteDefinition(eat, value, silent) {
  var self = this;
  var offsets = self.offset;
  var index;
  var length;
  var subvalue;
  var now;
  var currentLine;
  var content;
  var queue;
  var subqueue;
  var character;
  var identifier;
  var add;
  var exit;

  if (!self.options.footnotes) {
    return;
  }

  index = 0;
  length = value.length;
  subvalue = '';
  now = eat.now();
  currentLine = now.line;

  while (index < length) {
    character = value.charAt(index);

    if (!isWhitespaceCharacter(character)) {
      break;
    }

    subvalue += character;
    index++;
  }

  if (
    value.charAt(index) !== C_BRACKET_OPEN$4 ||
    value.charAt(index + 1) !== C_CARET$1
  ) {
    return;
  }

  subvalue += C_BRACKET_OPEN$4 + C_CARET$1;
  index = subvalue.length;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character === C_BRACKET_CLOSE$4) {
      break;
    } else if (character === C_BACKSLASH$4) {
      queue += character;
      index++;
      character = value.charAt(index);
    }

    queue += character;
    index++;
  }

  if (
    !queue ||
    value.charAt(index) !== C_BRACKET_CLOSE$4 ||
    value.charAt(index + 1) !== C_COLON$2
  ) {
    return;
  }

  if (silent) {
    return true;
  }

  identifier = normalize_1(queue);
  subvalue += queue + C_BRACKET_CLOSE$4 + C_COLON$2;
  index = subvalue.length;

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_TAB$3 && character !== C_SPACE$3) {
      break;
    }

    subvalue += character;
    index++;
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  queue = '';
  content = '';
  subqueue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character === C_NEWLINE$3) {
      subqueue = character;
      index++;

      while (index < length) {
        character = value.charAt(index);

        if (character !== C_NEWLINE$3) {
          break;
        }

        subqueue += character;
        index++;
      }

      queue += subqueue;
      subqueue = '';

      while (index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE$3) {
          break;
        }

        subqueue += character;
        index++;
      }

      if (subqueue.length === 0) {
        break;
      }

      queue += subqueue;
    }

    if (queue) {
      content += queue;
      queue = '';
    }

    content += character;
    index++;
  }

  subvalue += content;

  content = content.replace(EXPRESSION_INITIAL_TAB, function (line) {
    offsets[currentLine] = (offsets[currentLine] || 0) + line.length;
    currentLine++;

    return '';
  });

  add = eat(subvalue);

  exit = self.enterBlock();
  content = self.tokenizeBlock(content, now);
  exit();

  return add({
    type: 'footnoteDefinition',
    identifier: identifier,
    children: content
  });
}

var definition_1 = definition;
definition.notInList = true;
definition.notInBlock = true;

var C_DOUBLE_QUOTE$1 = '"';
var C_SINGLE_QUOTE$1 = '\'';
var C_BACKSLASH$3 = '\\';
var C_NEWLINE$2 = '\n';
var C_TAB$2 = '\t';
var C_SPACE$2 = ' ';
var C_BRACKET_OPEN$3 = '[';
var C_BRACKET_CLOSE$3 = ']';
var C_PAREN_OPEN$2 = '(';
var C_PAREN_CLOSE$2 = ')';
var C_COLON$1 = ':';
var C_LT$3 = '<';
var C_GT$2 = '>';

function definition(eat, value, silent) {
  var self = this;
  var commonmark = self.options.commonmark;
  var index = 0;
  var length = value.length;
  var subvalue = '';
  var beforeURL;
  var beforeTitle;
  var queue;
  var character;
  var test;
  var identifier;
  var url;
  var title;

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_SPACE$2 && character !== C_TAB$2) {
      break;
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);

  if (character !== C_BRACKET_OPEN$3) {
    return;
  }

  index++;
  subvalue += character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character === C_BRACKET_CLOSE$3) {
      break;
    } else if (character === C_BACKSLASH$3) {
      queue += character;
      index++;
      character = value.charAt(index);
    }

    queue += character;
    index++;
  }

  if (
    !queue ||
    value.charAt(index) !== C_BRACKET_CLOSE$3 ||
    value.charAt(index + 1) !== C_COLON$1
  ) {
    return;
  }

  identifier = queue;
  subvalue += queue + C_BRACKET_CLOSE$3 + C_COLON$1;
  index = subvalue.length;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (
      character !== C_TAB$2 &&
      character !== C_SPACE$2 &&
      character !== C_NEWLINE$2
    ) {
      break;
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);
  queue = '';
  beforeURL = subvalue;

  if (character === C_LT$3) {
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (!isEnclosedURLCharacter(character)) {
        break;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (character === isEnclosedURLCharacter.delimiter) {
      subvalue += C_LT$3 + queue + character;
      index++;
    } else {
      if (commonmark) {
        return;
      }

      index -= queue.length + 1;
      queue = '';
    }
  }

  if (!queue) {
    while (index < length) {
      character = value.charAt(index);

      if (!isUnclosedURLCharacter(character)) {
        break;
      }

      queue += character;
      index++;
    }

    subvalue += queue;
  }

  if (!queue) {
    return;
  }

  url = queue;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (
      character !== C_TAB$2 &&
      character !== C_SPACE$2 &&
      character !== C_NEWLINE$2
    ) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);
  test = null;

  if (character === C_DOUBLE_QUOTE$1) {
    test = C_DOUBLE_QUOTE$1;
  } else if (character === C_SINGLE_QUOTE$1) {
    test = C_SINGLE_QUOTE$1;
  } else if (character === C_PAREN_OPEN$2) {
    test = C_PAREN_CLOSE$2;
  }

  if (!test) {
    queue = '';
    index = subvalue.length;
  } else if (queue) {
    subvalue += queue + character;
    index = subvalue.length;
    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character === test) {
        break;
      }

      if (character === C_NEWLINE$2) {
        index++;
        character = value.charAt(index);

        if (character === C_NEWLINE$2 || character === test) {
          return;
        }

        queue += C_NEWLINE$2;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (character !== test) {
      return;
    }

    beforeTitle = subvalue;
    subvalue += queue + character;
    index++;
    title = queue;
    queue = '';
  } else {
    return;
  }

  while (index < length) {
    character = value.charAt(index);

    if (character !== C_TAB$2 && character !== C_SPACE$2) {
      break;
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);

  if (!character || character === C_NEWLINE$2) {
    if (silent) {
      return true;
    }

    beforeURL = eat(beforeURL).test().end;
    url = self.decode.raw(self.unescape(url), beforeURL, {nonTerminated: false});

    if (title) {
      beforeTitle = eat(beforeTitle).test().end;
      title = self.decode.raw(self.unescape(title), beforeTitle);
    }

    return eat(subvalue)({
      type: 'definition',
      identifier: normalize_1(identifier),
      title: title || null,
      url: url
    });
  }
}

/* Check if `character` can be inside an enclosed URI. */
function isEnclosedURLCharacter(character) {
  return character !== C_GT$2 &&
    character !== C_BRACKET_OPEN$3 &&
    character !== C_BRACKET_CLOSE$3;
}

isEnclosedURLCharacter.delimiter = C_GT$2;

/* Check if `character` can be inside an unclosed URI. */
function isUnclosedURLCharacter(character) {
  return character !== C_BRACKET_OPEN$3 &&
    character !== C_BRACKET_CLOSE$3 &&
    !isWhitespaceCharacter(character);
}

var table_1 = table;

var C_BACKSLASH$2 = '\\';
var C_TICK$2 = '`';
var C_DASH = '-';
var C_PIPE = '|';
var C_COLON = ':';
var C_SPACE$1 = ' ';
var C_NEWLINE$1 = '\n';
var C_TAB$1 = '\t';

var MIN_TABLE_COLUMNS = 1;
var MIN_TABLE_ROWS = 2;

var TABLE_ALIGN_LEFT = 'left';
var TABLE_ALIGN_CENTER = 'center';
var TABLE_ALIGN_RIGHT = 'right';
var TABLE_ALIGN_NONE = null;

function table(eat, value, silent) {
  var self = this;
  var index;
  var alignments;
  var alignment;
  var subvalue;
  var row;
  var length;
  var lines;
  var queue;
  var character;
  var hasDash;
  var align;
  var cell;
  var preamble;
  var count;
  var opening;
  var now;
  var position;
  var lineCount;
  var line;
  var rows;
  var table;
  var lineIndex;
  var pipeIndex;
  var first;

  /* Exit when not in gfm-mode. */
  if (!self.options.gfm) {
    return;
  }

  /* Get the rows.
   * Detecting tables soon is hard, so there are some
   * checks for performance here, such as the minimum
   * number of rows, and allowed characters in the
   * alignment row. */
  index = 0;
  lineCount = 0;
  length = value.length + 1;
  lines = [];

  while (index < length) {
    lineIndex = value.indexOf(C_NEWLINE$1, index);
    pipeIndex = value.indexOf(C_PIPE, index + 1);

    if (lineIndex === -1) {
      lineIndex = value.length;
    }

    if (pipeIndex === -1 || pipeIndex > lineIndex) {
      if (lineCount < MIN_TABLE_ROWS) {
        return;
      }

      break;
    }

    lines.push(value.slice(index, lineIndex));
    lineCount++;
    index = lineIndex + 1;
  }

  /* Parse the alignment row. */
  subvalue = lines.join(C_NEWLINE$1);
  alignments = lines.splice(1, 1)[0] || [];
  index = 0;
  length = alignments.length;
  lineCount--;
  alignment = false;
  align = [];

  while (index < length) {
    character = alignments.charAt(index);

    if (character === C_PIPE) {
      hasDash = null;

      if (alignment === false) {
        if (first === false) {
          return;
        }
      } else {
        align.push(alignment);
        alignment = false;
      }

      first = false;
    } else if (character === C_DASH) {
      hasDash = true;
      alignment = alignment || TABLE_ALIGN_NONE;
    } else if (character === C_COLON) {
      if (alignment === TABLE_ALIGN_LEFT) {
        alignment = TABLE_ALIGN_CENTER;
      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {
        alignment = TABLE_ALIGN_RIGHT;
      } else {
        alignment = TABLE_ALIGN_LEFT;
      }
    } else if (!isWhitespaceCharacter(character)) {
      return;
    }

    index++;
  }

  if (alignment !== false) {
    align.push(alignment);
  }

  /* Exit when without enough columns. */
  if (align.length < MIN_TABLE_COLUMNS) {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  /* Parse the rows. */
  position = -1;
  rows = [];

  table = eat(subvalue).reset({
    type: 'table',
    align: align,
    children: rows
  });

  while (++position < lineCount) {
    line = lines[position];
    row = {type: 'tableRow', children: []};

    /* Eat a newline character when this is not the
     * first row. */
    if (position) {
      eat(C_NEWLINE$1);
    }

    /* Eat the row. */
    eat(line).reset(row, table);

    length = line.length + 1;
    index = 0;
    queue = '';
    cell = '';
    preamble = true;
    count = null;
    opening = null;

    while (index < length) {
      character = line.charAt(index);

      if (character === C_TAB$1 || character === C_SPACE$1) {
        if (cell) {
          queue += character;
        } else {
          eat(character);
        }

        index++;
        continue;
      }

      if (character === '' || character === C_PIPE) {
        if (preamble) {
          eat(character);
        } else {
          if (character && opening) {
            queue += character;
            index++;
            continue;
          }

          if ((cell || character) && !preamble) {
            subvalue = cell;

            if (queue.length > 1) {
              if (character) {
                subvalue += queue.slice(0, queue.length - 1);
                queue = queue.charAt(queue.length - 1);
              } else {
                subvalue += queue;
                queue = '';
              }
            }

            now = eat.now();

            eat(subvalue)({
              type: 'tableCell',
              children: self.tokenizeInline(cell, now)
            }, row);
          }

          eat(queue + character);

          queue = '';
          cell = '';
        }
      } else {
        if (queue) {
          cell += queue;
          queue = '';
        }

        cell += character;

        if (character === C_BACKSLASH$2 && index !== length - 2) {
          cell += line.charAt(index + 1);
          index++;
        }

        if (character === C_TICK$2) {
          count = 1;

          while (line.charAt(index + 1) === character) {
            cell += character;
            index++;
            count++;
          }

          if (!opening) {
            opening = count;
          } else if (count >= opening) {
            opening = 0;
          }
        }
      }

      preamble = false;
      index++;
    }

    /* Eat the alignment row. */
    if (!position) {
      eat(C_NEWLINE$1 + alignments);
    }
  }

  return table;
}

var paragraph_1 = paragraph;

var C_NEWLINE = '\n';
var C_TAB = '\t';
var C_SPACE = ' ';

var TAB_SIZE = 4;

/* Tokenise paragraph. */
function paragraph(eat, value, silent) {
  var self = this;
  var settings = self.options;
  var commonmark = settings.commonmark;
  var gfm = settings.gfm;
  var tokenizers = self.blockTokenizers;
  var interruptors = self.interruptParagraph;
  var index = value.indexOf(C_NEWLINE);
  var length = value.length;
  var position;
  var subvalue;
  var character;
  var size;
  var now;

  while (index < length) {
    /* Eat everything if there‚Äôs no following newline. */
    if (index === -1) {
      index = length;
      break;
    }

    /* Stop if the next character is NEWLINE. */
    if (value.charAt(index + 1) === C_NEWLINE) {
      break;
    }

    /* In commonmark-mode, following indented lines
     * are part of the paragraph. */
    if (commonmark) {
      size = 0;
      position = index + 1;

      while (position < length) {
        character = value.charAt(position);

        if (character === C_TAB) {
          size = TAB_SIZE;
          break;
        } else if (character === C_SPACE) {
          size++;
        } else {
          break;
        }

        position++;
      }

      if (size >= TAB_SIZE) {
        index = value.indexOf(C_NEWLINE, index + 1);
        continue;
      }
    }

    subvalue = value.slice(index + 1);

    /* Check if the following code contains a possible
     * block. */
    if (interrupt_1(interruptors, tokenizers, self, [eat, subvalue, true])) {
      break;
    }

    /* Break if the following line starts a list, when
     * already in a list, or when in commonmark, or when
     * in gfm mode and the bullet is *not* numeric. */
    if (
      tokenizers.list.call(self, eat, subvalue, true) &&
      (
        self.inList ||
        commonmark ||
        (gfm && !isDecimal(trim_1.left(subvalue).charAt(0)))
      )
    ) {
      break;
    }

    position = index;
    index = value.indexOf(C_NEWLINE, index + 1);

    if (index !== -1 && trim_1(value.slice(position, index)) === '') {
      index = position;
      break;
    }
  }

  subvalue = value.slice(0, index);

  if (trim_1(subvalue) === '') {
    eat(subvalue);

    return null;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  now = eat.now();
  subvalue = trimTrailingLines_1(subvalue);

  return eat(subvalue)({
    type: 'paragraph',
    children: self.tokenizeInline(subvalue, now)
  });
}

var _escape$1 = locate$8;

function locate$8(value, fromIndex) {
  return value.indexOf('\\', fromIndex);
}

var _escape = escape;
escape.locator = _escape$1;

function escape(eat, value, silent) {
  var self = this;
  var character;
  var node;

  if (value.charAt(0) === '\\') {
    character = value.charAt(1);

    if (self.escape.indexOf(character) !== -1) {
      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true;
      }

      if (character === '\n') {
        node = {type: 'break'};
      } else {
        node = {
          type: 'text',
          value: character
        };
      }

      return eat('\\' + character)(node);
    }
  }
}

var tag$1 = locate$7;

function locate$7(value, fromIndex) {
  return value.indexOf('<', fromIndex);
}

var autoLink_1 = autoLink;
autoLink.locator = tag$1;
autoLink.notInLink = true;

var C_LT$2 = '<';
var C_GT$1 = '>';
var C_AT_SIGN$1 = '@';
var C_SLASH = '/';
var MAILTO = 'mailto:';
var MAILTO_LENGTH = MAILTO.length;

/* Tokenise a link. */
function autoLink(eat, value, silent) {
  var self;
  var subvalue;
  var length;
  var index;
  var queue;
  var character;
  var hasAtCharacter;
  var link;
  var now;
  var content;
  var tokenizers;
  var exit;

  if (value.charAt(0) !== C_LT$2) {
    return;
  }

  self = this;
  subvalue = '';
  length = value.length;
  index = 0;
  queue = '';
  hasAtCharacter = false;
  link = '';

  index++;
  subvalue = C_LT$2;

  while (index < length) {
    character = value.charAt(index);

    if (
      isWhitespaceCharacter(character) ||
      character === C_GT$1 ||
      character === C_AT_SIGN$1 ||
      (character === ':' && value.charAt(index + 1) === C_SLASH)
    ) {
      break;
    }

    queue += character;
    index++;
  }

  if (!queue) {
    return;
  }

  link += queue;
  queue = '';

  character = value.charAt(index);
  link += character;
  index++;

  if (character === C_AT_SIGN$1) {
    hasAtCharacter = true;
  } else {
    if (
      character !== ':' ||
      value.charAt(index + 1) !== C_SLASH
    ) {
      return;
    }

    link += C_SLASH;
    index++;
  }

  while (index < length) {
    character = value.charAt(index);

    if (isWhitespaceCharacter(character) || character === C_GT$1) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);

  if (!queue || character !== C_GT$1) {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  link += queue;
  content = link;
  subvalue += link + character;
  now = eat.now();
  now.column++;
  now.offset++;

  if (hasAtCharacter) {
    if (link.slice(0, MAILTO_LENGTH).toLowerCase() === MAILTO) {
      content = content.substr(MAILTO_LENGTH);
      now.column += MAILTO_LENGTH;
      now.offset += MAILTO_LENGTH;
    } else {
      link = MAILTO + link;
    }
  }

  /* Temporarily remove all tokenizers except text in autolinks. */
  tokenizers = self.inlineTokenizers;
  self.inlineTokenizers = {text: tokenizers.text};

  exit = self.enterLink();

  content = self.tokenizeInline(content, now);

  self.inlineTokenizers = tokenizers;
  exit();

  return eat(subvalue)({
    type: 'link',
    title: null,
    url: parseEntities_1(link, {nonTerminated: false}),
    children: content
  });
}

var url$1 = locate$6;

var PROTOCOLS$1 = ['https://', 'http://', 'mailto:'];

function locate$6(value, fromIndex) {
  var length = PROTOCOLS$1.length;
  var index = -1;
  var min = -1;
  var position;

  if (!this.options.gfm) {
    return -1;
  }

  while (++index < length) {
    position = value.indexOf(PROTOCOLS$1[index], fromIndex);

    if (position !== -1 && (position < min || min === -1)) {
      min = position;
    }
  }

  return min;
}

var url_1 = url;
url.locator = url$1;
url.notInLink = true;

var C_BRACKET_OPEN$2 = '[';
var C_BRACKET_CLOSE$2 = ']';
var C_PAREN_OPEN$1 = '(';
var C_PAREN_CLOSE$1 = ')';
var C_LT$1 = '<';
var C_AT_SIGN = '@';

var HTTP_PROTOCOL = 'http://';
var HTTPS_PROTOCOL = 'https://';
var MAILTO_PROTOCOL = 'mailto:';

var PROTOCOLS = [
  HTTP_PROTOCOL,
  HTTPS_PROTOCOL,
  MAILTO_PROTOCOL
];

var PROTOCOLS_LENGTH = PROTOCOLS.length;

function url(eat, value, silent) {
  var self = this;
  var subvalue;
  var content;
  var character;
  var index;
  var position;
  var protocol;
  var match;
  var length;
  var queue;
  var parenCount;
  var nextCharacter;
  var exit;

  if (!self.options.gfm) {
    return;
  }

  subvalue = '';
  index = -1;
  length = PROTOCOLS_LENGTH;

  while (++index < length) {
    protocol = PROTOCOLS[index];
    match = value.slice(0, protocol.length);

    if (match.toLowerCase() === protocol) {
      subvalue = match;
      break;
    }
  }

  if (!subvalue) {
    return;
  }

  index = subvalue.length;
  length = value.length;
  queue = '';
  parenCount = 0;

  while (index < length) {
    character = value.charAt(index);

    if (isWhitespaceCharacter(character) || character === C_LT$1) {
      break;
    }

    if (
      character === '.' ||
      character === ',' ||
      character === ':' ||
      character === ';' ||
      character === '"' ||
      character === '\'' ||
      character === ')' ||
      character === ']'
    ) {
      nextCharacter = value.charAt(index + 1);

      if (!nextCharacter || isWhitespaceCharacter(nextCharacter)) {
        break;
      }
    }

    if (character === C_PAREN_OPEN$1 || character === C_BRACKET_OPEN$2) {
      parenCount++;
    }

    if (character === C_PAREN_CLOSE$1 || character === C_BRACKET_CLOSE$2) {
      parenCount--;

      if (parenCount < 0) {
        break;
      }
    }

    queue += character;
    index++;
  }

  if (!queue) {
    return;
  }

  subvalue += queue;
  content = subvalue;

  if (protocol === MAILTO_PROTOCOL) {
    position = queue.indexOf(C_AT_SIGN);

    if (position === -1 || position === length - 1) {
      return;
    }

    content = content.substr(MAILTO_PROTOCOL.length);
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  exit = self.enterLink();
  content = self.tokenizeInline(content, eat.now());
  exit();

  return eat(subvalue)({
    type: 'link',
    title: null,
    url: parseEntities_1(subvalue, {nonTerminated: false}),
    children: content
  });
}

var tag = html.tag;

var htmlInline = inlineHTML;
inlineHTML.locator = tag$1;

var EXPRESSION_HTML_LINK_OPEN = /^<a /i;
var EXPRESSION_HTML_LINK_CLOSE = /^<\/a>/i;

function inlineHTML(eat, value, silent) {
  var self = this;
  var length = value.length;
  var character;
  var subvalue;

  if (value.charAt(0) !== '<' || length < 3) {
    return;
  }

  character = value.charAt(1);

  if (
    !isAlphabetical(character) &&
    character !== '?' &&
    character !== '!' &&
    character !== '/'
  ) {
    return;
  }

  subvalue = value.match(tag);

  if (!subvalue) {
    return;
  }

  /* istanbul ignore if - not used yet. */
  if (silent) {
    return true;
  }

  subvalue = subvalue[0];

  if (!self.inLink && EXPRESSION_HTML_LINK_OPEN.test(subvalue)) {
    self.inLink = true;
  } else if (self.inLink && EXPRESSION_HTML_LINK_CLOSE.test(subvalue)) {
    self.inLink = false;
  }

  return eat(subvalue)({type: 'html', value: subvalue});
}

var link$1 = locate$5;

function locate$5(value, fromIndex) {
  var link = value.indexOf('[', fromIndex);
  var image = value.indexOf('![', fromIndex);

  if (image === -1) {
    return link;
  }

  /* Link can never be `-1` if an image is found, so we don‚Äôt need
   * to check for that :) */
  return link < image ? link : image;
}

var link_1 = link;
link.locator = link$1;

var own = {}.hasOwnProperty;

var C_BACKSLASH$1 = '\\';
var C_BRACKET_OPEN$1 = '[';
var C_BRACKET_CLOSE$1 = ']';
var C_PAREN_OPEN = '(';
var C_PAREN_CLOSE = ')';
var C_LT = '<';
var C_GT = '>';
var C_TICK$1 = '`';
var C_DOUBLE_QUOTE = '"';
var C_SINGLE_QUOTE = '\'';

/* Map of characters, which can be used to mark link
 * and image titles. */
var LINK_MARKERS = {};

LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;

/* Map of characters, which can be used to mark link
 * and image titles in commonmark-mode. */
var COMMONMARK_LINK_MARKERS = {};

COMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
COMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;
COMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;

function link(eat, value, silent) {
  var self = this;
  var subvalue = '';
  var index = 0;
  var character = value.charAt(0);
  var pedantic = self.options.pedantic;
  var commonmark = self.options.commonmark;
  var gfm = self.options.gfm;
  var closed;
  var count;
  var opening;
  var beforeURL;
  var beforeTitle;
  var subqueue;
  var hasMarker;
  var markers;
  var isImage;
  var content;
  var marker;
  var length;
  var title;
  var depth;
  var queue;
  var url;
  var now;
  var exit;
  var node;

  /* Detect whether this is an image. */
  if (character === '!') {
    isImage = true;
    subvalue = character;
    character = value.charAt(++index);
  }

  /* Eat the opening. */
  if (character !== C_BRACKET_OPEN$1) {
    return;
  }

  /* Exit when this is a link and we‚Äôre already inside
   * a link. */
  if (!isImage && self.inLink) {
    return;
  }

  subvalue += character;
  queue = '';
  index++;

  /* Eat the content. */
  length = value.length;
  now = eat.now();
  depth = 0;

  now.column += index;
  now.offset += index;

  while (index < length) {
    character = value.charAt(index);
    subqueue = character;

    if (character === C_TICK$1) {
      /* Inline-code in link content. */
      count = 1;

      while (value.charAt(index + 1) === C_TICK$1) {
        subqueue += character;
        index++;
        count++;
      }

      if (!opening) {
        opening = count;
      } else if (count >= opening) {
        opening = 0;
      }
    } else if (character === C_BACKSLASH$1) {
      /* Allow brackets to be escaped. */
      index++;
      subqueue += value.charAt(index);
    /* In GFM mode, brackets in code still count.
     * In all other modes, they don‚Äôt.  This empty
     * block prevents the next statements are
     * entered. */
    } else if ((!opening || gfm) && character === C_BRACKET_OPEN$1) {
      depth++;
    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE$1) {
      if (depth) {
        depth--;
      } else {
        /* Allow white-space between content and
         * url in GFM mode. */
        if (!pedantic) {
          while (index < length) {
            character = value.charAt(index + 1);

            if (!isWhitespaceCharacter(character)) {
              break;
            }

            subqueue += character;
            index++;
          }
        }

        if (value.charAt(index + 1) !== C_PAREN_OPEN) {
          return;
        }

        subqueue += C_PAREN_OPEN;
        closed = true;
        index++;

        break;
      }
    }

    queue += subqueue;
    subqueue = '';
    index++;
  }

  /* Eat the content closing. */
  if (!closed) {
    return;
  }

  content = queue;
  subvalue += queue + subqueue;
  index++;

  /* Eat white-space. */
  while (index < length) {
    character = value.charAt(index);

    if (!isWhitespaceCharacter(character)) {
      break;
    }

    subvalue += character;
    index++;
  }

  /* Eat the URL. */
  character = value.charAt(index);
  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;
  queue = '';
  beforeURL = subvalue;

  if (character === C_LT) {
    index++;
    beforeURL += C_LT;

    while (index < length) {
      character = value.charAt(index);

      if (character === C_GT) {
        break;
      }

      if (commonmark && character === '\n') {
        return;
      }

      queue += character;
      index++;
    }

    if (value.charAt(index) !== C_GT) {
      return;
    }

    subvalue += C_LT + queue + C_GT;
    url = queue;
    index++;
  } else {
    character = null;
    subqueue = '';

    while (index < length) {
      character = value.charAt(index);

      if (subqueue && own.call(markers, character)) {
        break;
      }

      if (isWhitespaceCharacter(character)) {
        if (!pedantic) {
          break;
        }

        subqueue += character;
      } else {
        if (character === C_PAREN_OPEN) {
          depth++;
        } else if (character === C_PAREN_CLOSE) {
          if (depth === 0) {
            break;
          }

          depth--;
        }

        queue += subqueue;
        subqueue = '';

        if (character === C_BACKSLASH$1) {
          queue += C_BACKSLASH$1;
          character = value.charAt(++index);
        }

        queue += character;
      }

      index++;
    }

    subvalue += queue;
    url = queue;
    index = subvalue.length;
  }

  /* Eat white-space. */
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!isWhitespaceCharacter(character)) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);
  subvalue += queue;

  /* Eat the title. */
  if (queue && own.call(markers, character)) {
    index++;
    subvalue += character;
    queue = '';
    marker = markers[character];
    beforeTitle = subvalue;

    /* In commonmark-mode, things are pretty easy: the
     * marker cannot occur inside the title.
     *
     * Non-commonmark does, however, support nested
     * delimiters. */
    if (commonmark) {
      while (index < length) {
        character = value.charAt(index);

        if (character === marker) {
          break;
        }

        if (character === C_BACKSLASH$1) {
          queue += C_BACKSLASH$1;
          character = value.charAt(++index);
        }

        index++;
        queue += character;
      }

      character = value.charAt(index);

      if (character !== marker) {
        return;
      }

      title = queue;
      subvalue += queue + character;
      index++;

      while (index < length) {
        character = value.charAt(index);

        if (!isWhitespaceCharacter(character)) {
          break;
        }

        subvalue += character;
        index++;
      }
    } else {
      subqueue = '';

      while (index < length) {
        character = value.charAt(index);

        if (character === marker) {
          if (hasMarker) {
            queue += marker + subqueue;
            subqueue = '';
          }

          hasMarker = true;
        } else if (!hasMarker) {
          queue += character;
        } else if (character === C_PAREN_CLOSE) {
          subvalue += queue + marker + subqueue;
          title = queue;
          break;
        } else if (isWhitespaceCharacter(character)) {
          subqueue += character;
        } else {
          queue += marker + subqueue + character;
          subqueue = '';
          hasMarker = false;
        }

        index++;
      }
    }
  }

  if (value.charAt(index) !== C_PAREN_CLOSE) {
    return;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  subvalue += C_PAREN_CLOSE;

  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {nonTerminated: false});

  if (title) {
    beforeTitle = eat(beforeTitle).test().end;
    title = self.decode.raw(self.unescape(title), beforeTitle);
  }

  node = {
    type: isImage ? 'image' : 'link',
    title: title || null,
    url: url
  };

  if (isImage) {
    node.alt = self.decode.raw(self.unescape(content), now) || null;
  } else {
    exit = self.enterLink();
    node.children = self.tokenizeInline(content, now);
    exit();
  }

  return eat(subvalue)(node);
}

var reference_1 = reference;
reference.locator = link$1;

var T_LINK = 'link';
var T_IMAGE = 'image';
var T_FOOTNOTE = 'footnote';
var REFERENCE_TYPE_SHORTCUT = 'shortcut';
var REFERENCE_TYPE_COLLAPSED = 'collapsed';
var REFERENCE_TYPE_FULL = 'full';
var C_CARET = '^';
var C_BACKSLASH = '\\';
var C_BRACKET_OPEN = '[';
var C_BRACKET_CLOSE = ']';

function reference(eat, value, silent) {
  var self = this;
  var character = value.charAt(0);
  var index = 0;
  var length = value.length;
  var subvalue = '';
  var intro = '';
  var type = T_LINK;
  var referenceType = REFERENCE_TYPE_SHORTCUT;
  var content;
  var identifier;
  var now;
  var node;
  var exit;
  var queue;
  var bracketed;
  var depth;

  /* Check whether we‚Äôre eating an image. */
  if (character === '!') {
    type = T_IMAGE;
    intro = character;
    character = value.charAt(++index);
  }

  if (character !== C_BRACKET_OPEN) {
    return;
  }

  index++;
  intro += character;
  queue = '';

  /* Check whether we‚Äôre eating a footnote. */
  if (self.options.footnotes && value.charAt(index) === C_CARET) {
    /* Exit if `![^` is found, so the `!` will be seen as text after this,
     * and we‚Äôll enter this function again when `[^` is found. */
    if (type === T_IMAGE) {
      return;
    }

    intro += C_CARET;
    index++;
    type = T_FOOTNOTE;
  }

  /* Eat the text. */
  depth = 0;

  while (index < length) {
    character = value.charAt(index);

    if (character === C_BRACKET_OPEN) {
      bracketed = true;
      depth++;
    } else if (character === C_BRACKET_CLOSE) {
      if (!depth) {
        break;
      }

      depth--;
    }

    if (character === C_BACKSLASH) {
      queue += C_BACKSLASH;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }

  subvalue = queue;
  content = queue;
  character = value.charAt(index);

  if (character !== C_BRACKET_CLOSE) {
    return;
  }

  index++;
  subvalue += character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!isWhitespaceCharacter(character)) {
      break;
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);

  /* Inline footnotes cannot have an identifier. */
  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {
    identifier = '';
    queue += character;
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {
        break;
      }

      if (character === C_BACKSLASH) {
        identifier += C_BACKSLASH;
        character = value.charAt(++index);
      }

      identifier += character;
      index++;
    }

    character = value.charAt(index);

    if (character === C_BRACKET_CLOSE) {
      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;
      queue += identifier + character;
      index++;
    } else {
      identifier = '';
    }

    subvalue += queue;
    queue = '';
  } else {
    if (!content) {
      return;
    }

    identifier = content;
  }

  /* Brackets cannot be inside the identifier. */
  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {
    return;
  }

  subvalue = intro + subvalue;

  if (type === T_LINK && self.inLink) {
    return null;
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {
    return eat(subvalue)({
      type: 'footnote',
      children: this.tokenizeInline(content, eat.now())
    });
  }

  now = eat.now();
  now.column += intro.length;
  now.offset += intro.length;
  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;

  node = {
    type: type + 'Reference',
    identifier: normalize_1(identifier)
  };

  if (type === T_LINK || type === T_IMAGE) {
    node.referenceType = referenceType;
  }

  if (type === T_LINK) {
    exit = self.enterLink();
    node.children = self.tokenizeInline(content, now);
    exit();
  } else if (type === T_IMAGE) {
    node.alt = self.decode.raw(self.unescape(content), now) || null;
  }

  return eat(subvalue)(node);
}

var strong$1 = locate$4;

function locate$4(value, fromIndex) {
  var asterisk = value.indexOf('**', fromIndex);
  var underscore = value.indexOf('__', fromIndex);

  if (underscore === -1) {
    return asterisk;
  }

  if (asterisk === -1) {
    return underscore;
  }

  return underscore < asterisk ? underscore : asterisk;
}

var strong_1 = strong;
strong.locator = strong$1;

var C_ASTERISK$1 = '*';
var C_UNDERSCORE$1 = '_';

function strong(eat, value, silent) {
  var self = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var prev;

  if (
    (character !== C_ASTERISK$1 && character !== C_UNDERSCORE$1) ||
    value.charAt(++index) !== character
  ) {
    return;
  }

  pedantic = self.options.pedantic;
  marker = character;
  subvalue = marker + marker;
  length = value.length;
  index++;
  queue = '';
  character = '';

  if (pedantic && isWhitespaceCharacter(value.charAt(index))) {
    return;
  }

  while (index < length) {
    prev = character;
    character = value.charAt(index);

    if (
      character === marker &&
      value.charAt(index + 1) === marker &&
      (!pedantic || !isWhitespaceCharacter(prev))
    ) {
      character = value.charAt(index + 2);

      if (character !== marker) {
        if (!trim_1(queue)) {
          return;
        }

        /* istanbul ignore if - never used (yet) */
        if (silent) {
          return true;
        }

        now = eat.now();
        now.column += 2;
        now.offset += 2;

        return eat(subvalue + queue + subvalue)({
          type: 'strong',
          children: self.tokenizeInline(queue, now)
        });
      }
    }

    if (!pedantic && character === '\\') {
      queue += character;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }
}

var isWordCharacter = wordCharacter;

var fromCode = String.fromCharCode;
var re = /\w/;

// Check if the given character code, or the character code at the first
// character, is a word character.
function wordCharacter(character) {
  return re.test(
    typeof character === 'number' ? fromCode(character) : character.charAt(0)
  )
}

var emphasis$1 = locate$3;

function locate$3(value, fromIndex) {
  var asterisk = value.indexOf('*', fromIndex);
  var underscore = value.indexOf('_', fromIndex);

  if (underscore === -1) {
    return asterisk;
  }

  if (asterisk === -1) {
    return underscore;
  }

  return underscore < asterisk ? underscore : asterisk;
}

var emphasis_1 = emphasis;
emphasis.locator = emphasis$1;

var C_ASTERISK = '*';
var C_UNDERSCORE = '_';

function emphasis(eat, value, silent) {
  var self = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var prev;

  if (character !== C_ASTERISK && character !== C_UNDERSCORE) {
    return;
  }

  pedantic = self.options.pedantic;
  subvalue = character;
  marker = character;
  length = value.length;
  index++;
  queue = '';
  character = '';

  if (pedantic && isWhitespaceCharacter(value.charAt(index))) {
    return;
  }

  while (index < length) {
    prev = character;
    character = value.charAt(index);

    if (character === marker && (!pedantic || !isWhitespaceCharacter(prev))) {
      character = value.charAt(++index);

      if (character !== marker) {
        if (!trim_1(queue) || prev === marker) {
          return;
        }

        if (!pedantic && marker === C_UNDERSCORE && isWordCharacter(character)) {
          queue += marker;
          continue;
        }

        /* istanbul ignore if - never used (yet) */
        if (silent) {
          return true;
        }

        now = eat.now();
        now.column++;
        now.offset++;

        return eat(subvalue + queue + marker)({
          type: 'emphasis',
          children: self.tokenizeInline(queue, now)
        });
      }

      queue += marker;
    }

    if (!pedantic && character === '\\') {
      queue += character;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }
}

var _delete$1 = locate$2;

function locate$2(value, fromIndex) {
  return value.indexOf('~~', fromIndex);
}

var _delete = strikethrough;
strikethrough.locator = _delete$1;

var C_TILDE = '~';
var DOUBLE = '~~';

function strikethrough(eat, value, silent) {
  var self = this;
  var character = '';
  var previous = '';
  var preceding = '';
  var subvalue = '';
  var index;
  var length;
  var now;

  if (
    !self.options.gfm ||
    value.charAt(0) !== C_TILDE ||
    value.charAt(1) !== C_TILDE ||
    isWhitespaceCharacter(value.charAt(2))
  ) {
    return;
  }

  index = 1;
  length = value.length;
  now = eat.now();
  now.column += 2;
  now.offset += 2;

  while (++index < length) {
    character = value.charAt(index);

    if (
      character === C_TILDE &&
      previous === C_TILDE &&
      (!preceding || !isWhitespaceCharacter(preceding))
    ) {
      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true;
      }

      return eat(DOUBLE + subvalue + DOUBLE)({
        type: 'delete',
        children: self.tokenizeInline(subvalue, now)
      });
    }

    subvalue += previous;
    preceding = previous;
    previous = character;
  }
}

var codeInline$1 = locate$1;

function locate$1(value, fromIndex) {
  return value.indexOf('`', fromIndex);
}

var codeInline = inlineCode;
inlineCode.locator = codeInline$1;

var C_TICK = '`';

/* Tokenise inline code. */
function inlineCode(eat, value, silent) {
  var length = value.length;
  var index = 0;
  var queue = '';
  var tickQueue = '';
  var contentQueue;
  var subqueue;
  var count;
  var openingCount;
  var subvalue;
  var character;
  var found;
  var next;

  while (index < length) {
    if (value.charAt(index) !== C_TICK) {
      break;
    }

    queue += C_TICK;
    index++;
  }

  if (!queue) {
    return;
  }

  subvalue = queue;
  openingCount = index;
  queue = '';
  next = value.charAt(index);
  count = 0;

  while (index < length) {
    character = next;
    next = value.charAt(index + 1);

    if (character === C_TICK) {
      count++;
      tickQueue += character;
    } else {
      count = 0;
      queue += character;
    }

    if (count && next !== C_TICK) {
      if (count === openingCount) {
        subvalue += queue + tickQueue;
        found = true;
        break;
      }

      queue += tickQueue;
      tickQueue = '';
    }

    index++;
  }

  if (!found) {
    if (openingCount % 2 !== 0) {
      return;
    }

    queue = '';
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  contentQueue = '';
  subqueue = '';
  length = queue.length;
  index = -1;

  while (++index < length) {
    character = queue.charAt(index);

    if (isWhitespaceCharacter(character)) {
      subqueue += character;
      continue;
    }

    if (subqueue) {
      if (contentQueue) {
        contentQueue += subqueue;
      }

      subqueue = '';
    }

    contentQueue += character;
  }

  return eat(subvalue)({
    type: 'inlineCode',
    value: contentQueue
  });
}

var _break$1 = locate;

function locate(value, fromIndex) {
  var index = value.indexOf('\n', fromIndex);

  while (index > fromIndex) {
    if (value.charAt(index - 1) !== ' ') {
      break;
    }

    index--;
  }

  return index;
}

var _break = hardBreak;
hardBreak.locator = _break$1;

var MIN_BREAK_LENGTH = 2;

function hardBreak(eat, value, silent) {
  var length = value.length;
  var index = -1;
  var queue = '';
  var character;

  while (++index < length) {
    character = value.charAt(index);

    if (character === '\n') {
      if (index < MIN_BREAK_LENGTH) {
        return;
      }

      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true;
      }

      queue += character;

      return eat(queue)({type: 'break'});
    }

    if (character !== ' ') {
      return;
    }

    queue += character;
  }
}

var text_1 = text;

function text(eat, value, silent) {
  var self = this;
  var methods;
  var tokenizers;
  var index;
  var length;
  var subvalue;
  var position;
  var tokenizer;
  var name;
  var min;
  var now;

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true;
  }

  methods = self.inlineMethods;
  length = methods.length;
  tokenizers = self.inlineTokenizers;
  index = -1;
  min = value.length;

  while (++index < length) {
    name = methods[index];

    if (name === 'text' || !tokenizers[name]) {
      continue;
    }

    tokenizer = tokenizers[name].locator;

    if (!tokenizer) {
      eat.file.fail('Missing locator: `' + name + '`');
    }

    position = tokenizer.call(self, value, 1);

    if (position !== -1 && position < min) {
      min = position;
    }
  }

  subvalue = value.slice(0, min);
  now = eat.now();

  self.decode(subvalue, now, function (content, position, source) {
    eat(source || content)({
      type: 'text',
      value: content
    });
  });
}

var parser = Parser;

function Parser(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = immutable(this.options);
  this.setOptions({});

  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;

  this.toOffset = vfileLocation(file).toOffset;
  this.unescape = _unescape(this, 'escape');
  this.decode = decode(this);
}

var proto = Parser.prototype;

/* Expose core. */
proto.setOptions = setOptions_1;
proto.parse = parse_1;

/* Expose `defaults`. */
proto.options = defaults;

/* Enter and exit helpers. */
proto.exitStart = stateToggle('atStart', true);
proto.enterList = stateToggle('inList', false);
proto.enterLink = stateToggle('inLink', false);
proto.enterBlock = stateToggle('inBlock', false);

/* Nodes that can interupt a paragraph:
 *
 * ```markdown
 * A paragraph, followed by a thematic break.
 * ___
 * ```
 *
 * In the above example, the thematic break ‚Äúinterupts‚Äù
 * the paragraph. */
proto.interruptParagraph = [
  ['thematicBreak'],
  ['atxHeading'],
  ['fencedCode'],
  ['blockquote'],
  ['html'],
  ['setextHeading', {commonmark: false}],
  ['definition', {commonmark: false}],
  ['footnote', {commonmark: false}]
];

/* Nodes that can interupt a list:
 *
 * ```markdown
 * - One
 * ___
 * ```
 *
 * In the above example, the thematic break ‚Äúinterupts‚Äù
 * the list. */
proto.interruptList = [
  ['atxHeading', {pedantic: false}],
  ['fencedCode', {pedantic: false}],
  ['thematicBreak', {pedantic: false}],
  ['definition', {commonmark: false}],
  ['footnote', {commonmark: false}]
];

/* Nodes that can interupt a blockquote:
 *
 * ```markdown
 * > A paragraph.
 * ___
 * ```
 *
 * In the above example, the thematic break ‚Äúinterupts‚Äù
 * the blockquote. */
proto.interruptBlockquote = [
  ['indentedCode', {commonmark: true}],
  ['fencedCode', {commonmark: true}],
  ['atxHeading', {commonmark: true}],
  ['setextHeading', {commonmark: true}],
  ['thematicBreak', {commonmark: true}],
  ['html', {commonmark: true}],
  ['list', {commonmark: true}],
  ['definition', {commonmark: false}],
  ['footnote', {commonmark: false}]
];

/* Handlers. */
proto.blockTokenizers = {
  newline: newline_1,
  indentedCode: codeIndented,
  fencedCode: codeFenced,
  blockquote: blockquote_1,
  atxHeading: headingAtx,
  thematicBreak: thematicBreak_1,
  list: list_1,
  setextHeading: headingSetext,
  html: htmlBlock,
  footnote: footnoteDefinition_1,
  definition: definition_1,
  table: table_1,
  paragraph: paragraph_1
};

proto.inlineTokenizers = {
  escape: _escape,
  autoLink: autoLink_1,
  url: url_1,
  html: htmlInline,
  link: link_1,
  reference: reference_1,
  strong: strong_1,
  emphasis: emphasis_1,
  deletion: _delete,
  code: codeInline,
  break: _break,
  text: text_1
};

/* Expose precedence. */
proto.blockMethods = keys(proto.blockTokenizers);
proto.inlineMethods = keys(proto.inlineTokenizers);

/* Tokenizers. */
proto.tokenizeBlock = tokenizer('block');
proto.tokenizeInline = tokenizer('inline');
proto.tokenizeFactory = tokenizer;

/* Get all keys in `value`. */
function keys(value) {
  var result = [];
  var key;

  for (key in value) {
    result.push(key);
  }

  return result;
}

var remarkParse = parse;
parse.Parser = parser;

function parse(options) {
  var Local = unherit_1(parser);
  Local.prototype.options = immutable(Local.prototype.options, this.data('settings'), options);
  this.Parser = Local;
}

/**
 * @fileoverview Processes Markdown files for consumption by ESLint.
 * @author Brandon Mills
 */




const UNSATISFIABLE_RULES = [
    "eol-last", // The Markdown parser strips trailing newlines in code fences
    "unicode-bom" // Code blocks will begin in the middle of Markdown files
];
const SUPPORTS_AUTOFIX = true;

const markdown = unified_1().use(remarkParse);

/**
 * @type {Map<string, Block[]>}
 */
const blocksCache = new Map();

/**
 * Performs a depth-first traversal of the Markdown AST.
 * @param {ASTNode} node A Markdown AST node.
 * @param {{[key: string]: (node: ASTNode) => void}} callbacks A map of node types to callbacks.
 * @returns {void}
 */
function traverse(node, callbacks) {
    if (callbacks[node.type]) {
        callbacks[node.type](node);
    } else {
        callbacks["*"]();
    }

    if (typeof node.children !== "undefined") {
        for (let i = 0; i < node.children.length; i++) {
            traverse(node.children[i], callbacks);
        }
    }
}

/**
 * Extracts `eslint-*` or `global` comments from HTML comments if present.
 * @param {string} html The text content of an HTML AST node.
 * @returns {string} The comment's text without the opening and closing tags or
 *     an empty string if the text is not an ESLint HTML comment.
 */
function getComment(html) {
    const commentStart = "<!--";
    const commentEnd = "-->";
    const regex = /^(eslint\b|global\s)/u;

    if (
        html.slice(0, commentStart.length) !== commentStart ||
        html.slice(-commentEnd.length) !== commentEnd
    ) {
        return "";
    }

    const comment = html.slice(commentStart.length, -commentEnd.length);

    if (!regex.test(comment.trim())) {
        return "";
    }

    return comment;
}

// Before a code block, blockquote characters (`>`) are also considered
// "whitespace".
const leadingWhitespaceRegex = /^[>\s]*/u;

/**
 * Gets the offset for the first column of the node's first line in the
 * original source text.
 * @param {ASTNode} node A Markdown code block AST node.
 * @returns {number} The offset for the first column of the node's first line.
 */
function getBeginningOfLineOffset(node) {
    return node.position.start.offset - node.position.start.column + 1;
}

/**
 * Gets the leading text, typically whitespace with possible blockquote chars,
 * used to indent a code block.
 * @param {string} text The text of the file.
 * @param {ASTNode} node A Markdown code block AST node.
 * @returns {string} The text from the start of the first line to the opening
 *     fence of the code block.
 */
function getIndentText(text, node) {
    return leadingWhitespaceRegex.exec(
        text.slice(getBeginningOfLineOffset(node))
    )[0];
}

/**
 * When applying fixes, the postprocess step needs to know how to map fix ranges
 * from their location in the linted JS to the original offset in the Markdown.
 * Configuration comments and indentation trimming both complicate this process.
 *
 * Configuration comments appear in the linted JS but not in the Markdown code
 * block. Fixes to configuration comments would cause undefined behavior and
 * should be ignored during postprocessing. Fixes to actual code after
 * configuration comments need to be mapped back to the code block after
 * removing any offset due to configuration comments.
 *
 * Fenced code blocks can be indented by up to three spaces at the opening
 * fence. Inside of a list, for example, this indent can be in addition to the
 * indent already required for list item children. Leading whitespace inside
 * indented code blocks is trimmed up to the level of the opening fence and does
 * not appear in the linted code. Further, lines can have less leading
 * whitespace than the opening fence, so not all lines are guaranteed to have
 * the same column offset as the opening fence.
 *
 * The source code of a non-configuration-comment line in the linted JS is a
 * suffix of the corresponding line in the Markdown code block. There are no
 * differences within the line, so the mapping need only provide the offset
 * delta at the beginning of each line.
 * @param {string} text The text of the file.
 * @param {ASTNode} node A Markdown code block AST node.
 * @param {string[]} comments List of configuration comment strings that will be
 *     inserted at the beginning of the code block.
 * @returns {RangeMap[]} A list of offset-based adjustments, where lookups are
 *     done based on the `js` key, which represents the range in the linted JS,
 *     and the `md` key is the offset delta that, when added to the JS range,
 *     returns the corresponding location in the original Markdown source.
 */
function getBlockRangeMap(text, node, comments) {

    /*
     * The parser sets the fenced code block's start offset to wherever content
     * should normally begin (typically the first column of the line, but more
     * inside a list item, for example). The code block's opening fance may be
     * further indented by up to three characters. If the code block has
     * additional indenting, the opening fence's first backtick may be up to
     * three whitespace characters after the start offset.
     */
    const startOffset = getBeginningOfLineOffset(node);

    /*
     * Extract the Markdown source to determine the leading whitespace for each
     * line.
     */
    const code = text.slice(startOffset, node.position.end.offset);
    const lines = code.split("\n");

    /*
     * The parser trims leading whitespace from each line of code within the
     * fenced code block up to the opening fence's first backtick. The first
     * backtick's column is the AST node's starting column plus any additional
     * indentation.
     */
    const baseIndent = getIndentText(text, node).length;

    /*
     * Track the length of any inserted configuration comments at the beginning
     * of the linted JS and start the JS offset lookup keys at this index.
     */
    const commentLength = comments.reduce((len, comment) => len + comment.length + 1, 0);

    /*
     * In case there are configuration comments, initialize the map so that the
     * first lookup index is always 0. If there are no configuration comments,
     * the lookup index will also be 0, and the lookup should always go to the
     * last range that matches, skipping this initialization entry.
     */
    const rangeMap = [{
        js: 0,
        md: 0
    }];

    // Start the JS offset after any configuration comments.
    let jsOffset = commentLength;

    /*
     * Start the Markdown offset at the beginning of the block's first line of
     * actual code. The first line of the block is always the opening fence, so
     * the code begins on the second line.
     */
    let mdOffset = startOffset + lines[0].length + 1;

    /*
     * For each line, determine how much leading whitespace was trimmed due to
     * indentation. Increase the JS lookup offset by the length of the line
     * post-trimming and the Markdown offset by the total line length.
     */
    for (let i = 0; i + 1 < lines.length; i++) {
        const line = lines[i + 1];
        const leadingWhitespaceLength = leadingWhitespaceRegex.exec(line)[0].length;

        // The parser trims leading whitespace up to the level of the opening
        // fence, so keep any additional indentation beyond that.
        const trimLength = Math.min(baseIndent, leadingWhitespaceLength);

        rangeMap.push({
            js: jsOffset,

            // Advance `trimLength` character from the beginning of the Markdown
            // line to the beginning of the equivalent JS line, then compute the
            // delta.
            md: mdOffset + trimLength - jsOffset
        });

        // Accumulate the current line in the offsets, and don't forget the
        // newline.
        mdOffset += line.length + 1;
        jsOffset += line.length - trimLength + 1;
    }

    return rangeMap;
}

/**
 * Extracts lintable code blocks from Markdown text.
 * @param {string} text The text of the file.
 * @param {string} filename The filename of the file
 * @returns {Array<{ filename: string, text: string }>} Source code blocks to lint.
 */
function preprocess(text, filename) {
    const ast = markdown.parse(text);
    const blocks = [];

    blocksCache.set(filename, blocks);

    /**
     * During the depth-first traversal, keep track of any sequences of HTML
     * comment nodes containing `eslint-*` or `global` comments. If a code
     * block immediately follows such a sequence, insert the comments at the
     * top of the code block. Any non-ESLint comment or other node type breaks
     * and empties the sequence.
     * @type {string[]}
     */
    let htmlComments = [];

    traverse(ast, {
        "*"() {
            htmlComments = [];
        },
        code(node) {
            if (node.lang) {
                const comments = [];

                for (const comment of htmlComments) {
                    if (comment.trim() === "eslint-skip") {
                        htmlComments = [];
                        return;
                    }

                    comments.push(`/*${comment}*/`);
                }

                htmlComments = [];

                blocks.push({
                    ...node,
                    baseIndentText: getIndentText(text, node),
                    comments,
                    rangeMap: getBlockRangeMap(text, node, comments)
                });
            }
        },
        html(node) {
            const comment = getComment(node.value);

            if (comment) {
                htmlComments.push(comment);
            } else {
                htmlComments = [];
            }
        }
    });

    return blocks.map((block, index) => ({
        filename: `${index}.${block.lang.trim().split(" ")[0]}`,
        text: [
            ...block.comments,
            block.value,
            ""
        ].join("\n")
    }));
}

/**
 * Creates a map function that adjusts messages in a code block.
 * @param {Block} block A code block.
 * @returns {(message: Message) => Message} A function that adjusts messages in a code block.
 */
function adjustBlock(block) {
    const leadingCommentLines = block.comments.reduce((count, comment) => count + comment.split("\n").length, 0);

    const blockStart = block.position.start.line;

    /**
     * Adjusts ESLint messages to point to the correct location in the Markdown.
     * @param {Message} message A message from ESLint.
     * @returns {Message} The same message, but adjusted to the correct location.
     */
    return function adjustMessage(message) {

        const lineInCode = message.line - leadingCommentLines;

        if (lineInCode < 1) {
            return null;
        }

        const out = {
            line: lineInCode + blockStart,
            column: message.column + block.position.indent[lineInCode - 1] - 1
        };

        if (Number.isInteger(message.endLine)) {
            out.endLine = message.endLine - leadingCommentLines + blockStart;
        }

        const adjustedFix = {};

        if (message.fix) {
            adjustedFix.fix = {
                range: message.fix.range.map(range => {

                    // Advance through the block's range map to find the last
                    // matching range by finding the first range too far and
                    // then going back one.
                    let i = 1;

                    while (i < block.rangeMap.length && block.rangeMap[i].js <= range) {
                        i++;
                    }

                    // Apply the mapping delta for this range.
                    return range + block.rangeMap[i - 1].md;
                }),
                text: message.fix.text.replace(/\n/gu, `\n${block.baseIndentText}`)
            };
        }

        return { ...message, ...out, ...adjustedFix };
    };
}

/**
 * Excludes unsatisfiable rules from the list of messages.
 * @param {Message} message A message from the linter.
 * @returns {boolean} True if the message should be included in output.
 */
function excludeUnsatisfiableRules(message) {
    return message && UNSATISFIABLE_RULES.indexOf(message.ruleId) < 0;
}

/**
 * Transforms generated messages for output.
 * @param {Array<Message[]>} messages An array containing one array of messages
 *     for each code block returned from `preprocess`.
 * @param {string} filename The filename of the file
 * @returns {Message[]} A flattened array of messages with mapped locations.
 */
function postprocess(messages, filename) {
    const blocks = blocksCache.get(filename);

    blocksCache.delete(filename);

    return [].concat(...messages.map((group, i) => {
        const adjust = adjustBlock(blocks[i]);

        return group.map(adjust).filter(excludeUnsatisfiableRules);
    }));
}

var processor = {
    preprocess,
    postprocess,
    supportsAutofix: SUPPORTS_AUTOFIX
};

/**
 * @fileoverview Enables the processor for Markdown file extensions.
 * @author Brandon Mills
 */



var lib = {
    configs: {
        recommended: {
            plugins: ["markdown"],
            overrides: [
                {
                    files: ["*.md"],
                    processor: "markdown/markdown"
                },
                {
                    files: ["**/*.md/**"],
                    parserOptions: {
                        ecmaFeatures: {

                            // Adding a "use strict" directive at the top of
                            // every code block is tedious and distracting, so
                            // opt into strict mode parsing without the
                            // directive.
                            impliedStrict: true
                        }
                    },
                    rules: {

                        // The Markdown parser automatically trims trailing
                        // newlines from code blocks.
                        "eol-last": "off",

                        // In code snippets and examples, these rules are often
                        // counterproductive to clarity and brevity.
                        "no-undef": "off",
                        "no-unused-expressions": "off",
                        "no-unused-vars": "off",
                        "padded-blocks": "off",

                        // Adding a "use strict" directive at the top of every
                        // code block is tedious and distracting. The config
                        // opts into strict mode parsing without the directive.
                        strict: "off",

                        // The processor will not receive a Unicode Byte Order
                        // Mark from the Markdown parser.
                        "unicode-bom": "off"
                    }
                }
            ]
        }
    },
    processors: {
        markdown: processor
    }
};

/**
 * @fileoverview Exports the processor.
 * @author Brandon Mills
 */

var eslintPluginMarkdown = lib;

module.exports = eslintPluginMarkdown;

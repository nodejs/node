{"version":3,"sources":["../src/jsdocUtils.js"],"names":["tagStructure","setTagStructure","mode","flattenRoots","params","root","hasRestElement","hasPropertyRest","rests","names","reduce","acc","cur","Array","isArray","nms","flattened","inner","filter","Boolean","push","concat","isRestProperty","restElement","name","getPropertiesFromPropertySignature","propSignature","type","undefined","typeAnnotation","key","members","map","member","getFunctionParameterNames","functionNode","checkDefaultObjects","getParamName","param","isProperty","_","has","left","propertyNames","annotationParamName","properties","roots","prop","value","elements","idx","right","raw","includes","argument","parameter","Error","hasParams","length","getJsdocTagsDeep","jsdoc","targetTagName","ret","tags","forEach","tag","modeWarnSettings","getTagNamesForMode","context","jsdocTags","typeScriptTags","closureTags","hasBeenWarned","report","loc","start","column","line","message","markSettingAsWarned","getPreferredTagName","tagPreference","prefValues","Object","values","some","prefVal","replacement","tagPreferenceFixed","mapKeys","_value","replace","tagNames","preferredTagName","entries","find","aliases","isValidTag","definedTags","validTagNames","keys","flatten","additionalTags","allTags","hasTag","targetTagLower","toLowerCase","doc","hasATag","targetTagNames","hasDefinedTypeTag","tagType","trim","ensureMap","set","Map","get","overrideTagStructure","structuredTags","tagMap","required","tagStruct","requiredName","requiredType","typeOrNameRequired","getTagStructureForMode","isNamepathDefiningTag","tagMustHaveTypePosition","tagMightHaveTypePosition","namepathTypes","Set","tagMightHaveNamePosition","tagMightHaveNamepath","tagMustHaveNamePosition","tagMightHaveEitherTypeOrNamePosition","tagMustHaveEitherTypeOrNamePosition","tagMissingRequiredTypeOrNamepath","mustHaveTypePosition","mightHaveTypePosition","hasTypePosition","hasNameOrNamepathPosition","mustHaveEither","hasEither","isNewPromiseExpression","node","callee","hasReturnValue","promFilter","expression","body","bodyNode","consequent","alternate","block","handler","finalizer","cases","someCase","nde","hasNonEmptyResolverCall","resolverName","arguments","test","element","expressions","subExpression","property","decorators","decorator","computed","declarations","id","init","quasi","object","source","hasValueOrExecutorHasNonEmptyResolveValue","anyPromiseAsReturn","prom","hasNonFunctionYield","checkYieldReturnValue","parent","hasYieldValue","generator","hasThrowValue","innerFunction","parseClosureTemplateTag","split","enforcedContexts","defaultContexts","contexts","options","getContextObject","checkJsdoc","filterTags","tagsWithNamesAndDescriptions","getTagsByType","descName","tagsWithoutNames","tagsWithNames","tagName","tagWithName","getIndent","sourceCode","text","match","isConstructor","kind","isGetter","isSetter","hasAccessorPair","sourceKind","sourceName","oppositeKind","children","exemptSpeciaMethods","schema","hasSchemaOption","schemaProperties","default","checkGetters","checkSetters","dropPathSegmentQuotes","str","comparePaths","otherPathName","getRegexFromString","regexString","requiredFlags","flags","regex","uniqueFlags","join","RegExp"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport WarnSettings from './WarnSettings';\nimport getDefaultTagStructureForMode from './getDefaultTagStructureForMode';\nimport {\n  jsdocTags, closureTags, typeScriptTags,\n} from './tagNames';\n\ntype ParserMode = \"jsdoc\"|\"typescript\"|\"closure\";\n\nlet tagStructure;\n\nconst setTagStructure = (mode) => {\n  tagStructure = getDefaultTagStructureForMode(mode);\n};\n\n// Given a nested array of property names, reduce them to a single array,\n// appending the name of the root element along the way if present.\nconst flattenRoots = (params, root = '') => {\n  let hasRestElement = false;\n  let hasPropertyRest = false;\n  const rests = [];\n\n  const names = params.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      let nms;\n      if (Array.isArray(cur[1])) {\n        nms = cur[1];\n      } else {\n        if (cur[1].hasRestElement) {\n          hasRestElement = true;\n        }\n        if (cur[1].hasPropertyRest) {\n          hasPropertyRest = true;\n        }\n        nms = cur[1].names;\n      }\n\n      const flattened = flattenRoots(nms, root ? `${root}.${cur[0]}` : cur[0]);\n      if (flattened.hasRestElement) {\n        hasRestElement = true;\n      }\n      if (flattened.hasPropertyRest) {\n        hasPropertyRest = true;\n      }\n      const inner = [\n        root ? `${root}.${cur[0]}` : cur[0],\n        ...flattened.names,\n      ].filter(Boolean);\n      rests.push(false, ...flattened.rests);\n\n      return acc.concat(inner);\n    }\n    if (typeof cur === 'object') {\n      if (cur.isRestProperty) {\n        hasPropertyRest = true;\n        rests.push(true);\n      } else {\n        rests.push(false);\n      }\n      if (cur.restElement) {\n        hasRestElement = true;\n      }\n      acc.push(root ? `${root}.${cur.name}` : cur.name);\n    } else if (typeof cur !== 'undefined') {\n      rests.push(false);\n      acc.push(root ? `${root}.${cur}` : cur);\n    }\n\n    return acc;\n  }, []);\n\n  return {\n    hasPropertyRest,\n    hasRestElement,\n    names,\n    rests,\n  };\n};\n\ntype T = string | [?string, T];\nconst getPropertiesFromPropertySignature = (propSignature): T => {\n  if (\n    propSignature.type === 'TSIndexSignature' ||\n    propSignature.type === 'TSConstructSignatureDeclaration' ||\n    propSignature.type === 'TSCallSignatureDeclaration'\n  ) {\n    return undefined;\n  }\n  if (propSignature.typeAnnotation && propSignature.typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {\n    return [propSignature.key.name, propSignature.typeAnnotation.typeAnnotation.members.map((member) => {\n      return getPropertiesFromPropertySignature(member);\n    })];\n  }\n\n  return propSignature.key.name;\n};\n\nconst getFunctionParameterNames = (\n  functionNode : Object, checkDefaultObjects: Boolean,\n) : Array<T> => {\n  // eslint-disable-next-line complexity\n  const getParamName = (param, isProperty) => {\n    if (_.has(param, 'typeAnnotation') || _.has(param, 'left.typeAnnotation')) {\n      const typeAnnotation = _.has(param, 'left.typeAnnotation') ? param.left.typeAnnotation : param.typeAnnotation;\n      if (typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {\n        const propertyNames = typeAnnotation.typeAnnotation.members.map((member) => {\n          return getPropertiesFromPropertySignature(member);\n        });\n        const flattened = {\n          ...flattenRoots(propertyNames),\n          annotationParamName: param.name,\n        };\n        if (_.has(param, 'name') || _.has(param, 'left.name')) {\n          return [_.has(param, 'left.name') ? param.left.name : param.name, flattened];\n        }\n\n        return [undefined, flattened];\n      }\n    }\n\n    if (_.has(param, 'name')) {\n      return param.name;\n    }\n\n    if (_.has(param, 'left.name')) {\n      return param.left.name;\n    }\n\n    if (param.type === 'ObjectPattern' || param.left?.type === 'ObjectPattern') {\n      const properties = param.properties || param.left?.properties;\n      const roots = properties.map((prop) => {\n        return getParamName(prop, true);\n      });\n\n      return [undefined, flattenRoots(roots)];\n    }\n\n    if (param.type === 'Property') {\n      switch (param.value.type) {\n      case 'ArrayPattern':\n        return [param.key.name, param.value.elements.map((prop, idx) => {\n          return {\n            name: idx,\n            restElement: prop.type === 'RestElement',\n          };\n        })];\n      case 'ObjectPattern':\n        return [param.key.name, param.value.properties.map((prop) => {\n          return getParamName(prop, isProperty);\n        })];\n      case 'AssignmentPattern': {\n        switch (param.value.left.type) {\n        case 'Identifier':\n          // Default parameter\n          if (checkDefaultObjects && param.value.right.type === 'ObjectExpression') {\n            return [param.key.name, param.value.right.properties.map((prop) => {\n              return getParamName(prop, isProperty);\n            })];\n          }\n          break;\n        case 'ObjectPattern':\n          return [param.key.name, param.value.left.properties.map((prop) => {\n            return getParamName(prop, isProperty);\n          })];\n        case 'ArrayPattern':\n          return [param.key.name, param.value.left.elements.map((prop, idx) => {\n            return {\n              name: idx,\n              restElement: prop.type === 'RestElement',\n            };\n          })];\n        }\n      }\n      }\n\n      switch (param.key.type) {\n      case 'Identifier':\n        return param.key.name;\n\n      // The key of an object could also be a string or number\n      case 'Literal':\n        return param.key.raw ||\n          // istanbul ignore next -- `raw` may not be present in all parsers\n          param.key.value;\n\n      // case 'MemberExpression':\n      default:\n        // Todo: We should really create a structure (and a corresponding\n        //   option analogous to `checkRestProperty`) which allows for\n        //   (and optionally requires) dynamic properties to have a single\n        //   line of documentation\n        return undefined;\n      }\n    }\n\n    if (param.type === 'ArrayPattern' || param.left?.type === 'ArrayPattern') {\n      const elements = param.elements || param.left?.elements;\n      const roots = elements.map((prop, idx) => {\n        return {\n          name: idx,\n          restElement: prop.type === 'RestElement',\n        };\n      });\n\n      return [undefined, flattenRoots(roots)];\n    }\n\n    if (['RestElement', 'ExperimentalRestProperty'].includes(param.type)) {\n      return {\n        isRestProperty: isProperty,\n        name: param.argument.name,\n        restElement: true,\n      };\n    }\n\n    if (param.type === 'TSParameterProperty') {\n      return getParamName(param.parameter, true);\n    }\n\n    throw new Error(`Unsupported function signature format: \\`${param.type}\\`.`);\n  };\n\n  return (functionNode.params || functionNode.value.params).map((param) => {\n    return getParamName(param);\n  });\n};\n\nconst hasParams = (functionNode) => {\n  // Should also check `functionNode.value.params` if supporting `MethodDefinition`\n  return functionNode.params.length;\n};\n\n/**\n * Gets all names of the target type, including those that refer to a path, e.g.\n * \"@param foo; @param foo.bar\".\n */\nconst getJsdocTagsDeep = (jsdoc : Object, targetTagName : string) : Array<Object> => {\n  const ret = [];\n  jsdoc.tags.forEach(({name, tag, type}, idx) => {\n    if (tag !== targetTagName) {\n      return;\n    }\n    ret.push({\n      idx,\n      name,\n      type,\n    });\n  });\n\n  return ret;\n};\n\nconst modeWarnSettings = WarnSettings();\n\nconst getTagNamesForMode = (mode, context) => {\n  switch (mode) {\n  case 'jsdoc':\n    return jsdocTags;\n  case 'typescript':\n    return typeScriptTags;\n  case 'closure': case 'permissive':\n    return closureTags;\n  default:\n    if (!modeWarnSettings.hasBeenWarned(context, 'mode')) {\n      context.report({\n        loc: {\n          start: {\n            column: 1,\n            line: 1,\n          },\n        },\n        message: `Unrecognized value \\`${mode}\\` for \\`settings.jsdoc.mode\\`.`,\n      });\n      modeWarnSettings.markSettingAsWarned(context, 'mode');\n    }\n\n    // We'll avoid breaking too many other rules\n    return jsdocTags;\n  }\n};\n\nconst getPreferredTagName = (\n  context,\n  mode : ParserMode,\n  name : string,\n  tagPreference : Object = {},\n) : string|Object => {\n  const prefValues = Object.values(tagPreference);\n  if (prefValues.includes(name) || prefValues.some((prefVal) => {\n    return prefVal && typeof prefVal === 'object' && prefVal.replacement === name;\n  })) {\n    return name;\n  }\n\n  // Allow keys to have a 'tag ' prefix to avoid upstream bug in ESLint\n  // that disallows keys that conflict with Object.prototype,\n  // e.g. 'tag constructor' for 'constructor':\n  // https://github.com/eslint/eslint/issues/13289\n  // https://github.com/gajus/eslint-plugin-jsdoc/issues/537\n  const tagPreferenceFixed = _.mapKeys(tagPreference, (_value, key) => {\n    return key.replace('tag ', '');\n  });\n\n  if (_.has(tagPreferenceFixed, name)) {\n    return tagPreferenceFixed[name];\n  }\n\n  const tagNames = getTagNamesForMode(mode, context);\n\n  const preferredTagName = Object.entries(tagNames).find(([, aliases]) => {\n    return aliases.includes(name);\n  })?.[0];\n  if (preferredTagName) {\n    return preferredTagName;\n  }\n\n  return name;\n};\n\nconst isValidTag = (\n  context,\n  mode : ParserMode,\n  name : string,\n  definedTags : Array,\n) : boolean => {\n  const tagNames = getTagNamesForMode(mode, context);\n  const validTagNames = Object.keys(tagNames).concat(_.flatten(Object.values(tagNames)));\n  const additionalTags = definedTags;\n  const allTags = validTagNames.concat(additionalTags);\n\n  return allTags.includes(name);\n};\n\nconst hasTag = (jsdoc : Object, targetTagName : string) : boolean => {\n  const targetTagLower = targetTagName.toLowerCase();\n\n  return _.some(jsdoc.tags, (doc : Object) => {\n    return doc.tag.toLowerCase() === targetTagLower;\n  });\n};\n\nconst hasATag = (jsdoc : Object, targetTagNames : Array) : boolean => {\n  return targetTagNames.some((targetTagName) => {\n    return hasTag(jsdoc, targetTagName);\n  });\n};\n\n/**\n * Checks if the JSDoc comment declares a defined type.\n *\n * @param {JsDocTag} tag\n *   the tag which should be checked.\n * @returns {boolean}\n *   true in case a defined type is declared; otherwise false.\n */\nconst hasDefinedTypeTag = (tag) => {\n  // The function should not continue in the event the type is not defined...\n  if (typeof tag === 'undefined' || tag === null) {\n    return false;\n  }\n\n  // .. same applies if it declares an `{undefined}` or `{void}` type\n  const tagType = tag.type.trim();\n  if (tagType === 'undefined' || tagType === 'void') {\n    return false;\n  }\n\n  // In any other case, a type is present\n  return true;\n};\n\nconst ensureMap = (map, tag) => {\n  if (!map.has(tag)) {\n    map.set(tag, new Map());\n  }\n\n  return map.get(tag);\n};\n\nconst overrideTagStructure = (structuredTags, tagMap = tagStructure) => {\n  Object.entries(structuredTags).forEach(([tag, {\n    name, type, required = [],\n  }]) => {\n    const tagStruct = ensureMap(tagMap, tag);\n\n    tagStruct.set('nameContents', name);\n    tagStruct.set('typeAllowed', type);\n\n    const requiredName = required.includes('name');\n    if (requiredName && name === false) {\n      throw new Error('Cannot add \"name\" to `require` with the tag\\'s `name` set to `false`');\n    }\n    tagStruct.set('nameRequired', requiredName);\n\n    const requiredType = required.includes('type');\n    if (requiredType && type === false) {\n      throw new Error('Cannot add \"type\" to `require` with the tag\\'s `type` set to `false`');\n    }\n    tagStruct.set('typeRequired', requiredType);\n\n    const typeOrNameRequired = required.includes('typeOrNameRequired');\n    if (typeOrNameRequired && name === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `name` set to `false`');\n    }\n    if (typeOrNameRequired && type === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `type` set to `false`');\n    }\n    tagStruct.set('typeOrNameRequired', typeOrNameRequired);\n  });\n};\n\nconst getTagStructureForMode = (mode, structuredTags) => {\n  const tagStruct = getDefaultTagStructureForMode(mode);\n\n  try {\n    overrideTagStructure(structuredTags, tagStruct);\n  } catch {\n    //\n  }\n\n  return tagStruct;\n};\n\nconst isNamepathDefiningTag = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('nameContents') === 'namepath-defining';\n};\n\nconst tagMustHaveTypePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('typeRequired');\n};\n\nconst tagMightHaveTypePosition = (tag, tagMap = tagStructure) => {\n  if (tagMustHaveTypePosition(tag, tagMap)) {\n    return true;\n  }\n\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = tagStruct.get('typeAllowed');\n\n  return ret === undefined ? true : ret;\n};\n\nconst namepathTypes = new Set([\n  'namepath-defining', 'namepath-referencing',\n]);\n\nconst tagMightHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = tagStruct.get('nameContents');\n\n  return ret === undefined ? true : Boolean(ret);\n};\n\nconst tagMightHaveNamepath = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return namepathTypes.has(tagStruct.get('nameContents'));\n};\n\nconst tagMustHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('nameRequired');\n};\n\nconst tagMightHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  return tagMightHaveTypePosition(tag, tagMap) || tagMightHaveNamepath(tag, tagMap);\n};\n\nconst tagMustHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('typeOrNameRequired');\n};\n\nconst tagMissingRequiredTypeOrNamepath = (tag, tagMap = tagStructure) => {\n  const mustHaveTypePosition = tagMustHaveTypePosition(tag.tag, tagMap);\n  const mightHaveTypePosition = tagMightHaveTypePosition(tag.tag, tagMap);\n  const hasTypePosition = mightHaveTypePosition && Boolean(tag.type);\n  const hasNameOrNamepathPosition = (\n    tagMustHaveNamePosition(tag.tag, tagMap) ||\n    tagMightHaveNamepath(tag.tag, tagMap)\n  ) && Boolean(tag.name);\n  const mustHaveEither = tagMustHaveEitherTypeOrNamePosition(tag.tag, tagMap);\n  const hasEither = tagMightHaveEitherTypeOrNamePosition(tag.tag, tagMap) &&\n    (hasTypePosition || hasNameOrNamepathPosition);\n\n  return mustHaveEither && !hasEither && !mustHaveTypePosition;\n};\n\n/**\n * Checks if a node is a promise but has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {object} node\n * @returns {boolean}\n */\nconst isNewPromiseExpression = (node) => {\n  return node.type === 'NewExpression' && node.callee.type === 'Identifier' &&\n    node.callee.name === 'Promise';\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @returns {boolean|Node}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return node.expression || hasReturnValue(node.body, promFilter);\n  }\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode, promFilter);\n    });\n  }\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasReturnValue(node.body, promFilter);\n  }\n  case 'IfStatement': {\n    return hasReturnValue(node.consequent, promFilter) || hasReturnValue(node.alternate, promFilter);\n  }\n  case 'TryStatement': {\n    return hasReturnValue(node.block, promFilter) ||\n      hasReturnValue(node.handler && node.handler.body, promFilter) ||\n      hasReturnValue(node.finalizer, promFilter);\n  }\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasReturnValue(nde, promFilter);\n        });\n      },\n    );\n  }\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Avoids further checking child nodes if a nested function shadows the\n * resolver, but otherwise, if name is used (by call or passed in as an\n * argument to another function), will be considered as non-empty.\n *\n * This could check for redeclaration of the resolver, but as such is\n * unlikely, we avoid the performance cost of checking everywhere for\n * (re)declarations or assignments.\n *\n * @param {AST} node\n * @param {string} resolverName\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasNonEmptyResolverCall = (node, resolverName) => {\n  if (!node) {\n    return false;\n  }\n\n  // Arrow function without block\n  switch (node.type) {\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return node.callee.name === resolverName && (\n\n      // Implicit or expliit undefined\n      node.arguments.length > 1 || node.arguments[0] !== undefined\n    ) ||\n      node.arguments.some((nde) => {\n        // Being passed in to another function (which might invoke it)\n        return nde.type === 'Identifier' && nde.name === resolverName ||\n\n          // Handle nested items\n          hasNonEmptyResolverCall(nde, resolverName);\n      });\n  case 'ChainExpression':\n  case 'Decorator':\n  case 'ExpressionStatement':\n    return hasNonEmptyResolverCall(node.expression, resolverName);\n  case 'ClassBody':\n  case 'BlockStatement':\n    return node.body.some((bodyNode) => {\n      return hasNonEmptyResolverCall(bodyNode, resolverName);\n    });\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    // Shadowing\n    if (node.params[0]?.name === resolverName) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonEmptyResolverCall(node.test, resolverName) ||\n      hasNonEmptyResolverCall(node.consequent, resolverName) ||\n      hasNonEmptyResolverCall(node.alternate, resolverName);\n  }\n  case 'TryStatement': {\n    return hasNonEmptyResolverCall(node.block, resolverName) ||\n      hasNonEmptyResolverCall(node.handler && node.handler.body, resolverName) ||\n      hasNonEmptyResolverCall(node.finalizer, resolverName);\n  }\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonEmptyResolverCall(nde, resolverName);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonEmptyResolverCall(element, resolverName);\n    });\n\n  case 'AssignmentPattern':\n    return hasNonEmptyResolverCall(node.right, resolverName);\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonEmptyResolverCall(node.left, resolverName) ||\n      hasNonEmptyResolverCall(node.right, resolverName);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonEmptyResolverCall(subExpression, resolverName);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonEmptyResolverCall(property, resolverName);\n    });\n  // istanbul ignore next -- In Babel?\n  case 'ClassMethod':\n  case 'MethodDefinition':\n    return node.decorators && node.decorators.some((decorator) => {\n      return hasNonEmptyResolverCall(decorator, resolverName);\n    }) ||\n      node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  /* eslint-enable no-fallthrough */\n  case 'Property':\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      node.arguments.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n  case 'ClassExpression':\n  case 'ClassDeclaration':\n    return hasNonEmptyResolverCall(node.body, resolverName);\n\n  case 'AwaitExpression':\n  case 'SpreadElement':\n  case 'UnaryExpression':\n  case 'YieldExpression':\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonEmptyResolverCall(nde, resolverName);\n    });\n  }\n  case 'VariableDeclarator': {\n    return hasNonEmptyResolverCall(node.id, resolverName) ||\n      hasNonEmptyResolverCall(node.init, resolverName);\n  }\n\n  case 'TaggedTemplateExpression':\n    return hasNonEmptyResolverCall(node.quasi, resolverName);\n\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonEmptyResolverCall(node.object, resolverName) ||\n      hasNonEmptyResolverCall(node.property, resolverName);\n\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonEmptyResolverCall(node.source, resolverName);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n  }\n\n  /*\n  // Shouldn't need to parse literals/literal components, etc.\n\n  case 'Identifier':\n  case 'TemplateElement':\n  case 'Super':\n  // Exports not relevant in this context\n  */\n  default:\n    return false;\n  }\n};\n\n/**\n * Checks if a Promise executor has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {object} node\n * @param {boolean} anyPromiseAsReturn\n * @returns {boolean}\n */\nconst hasValueOrExecutorHasNonEmptyResolveValue = (node, anyPromiseAsReturn) => {\n  return hasReturnValue(node, (prom) => {\n    if (anyPromiseAsReturn) {\n      return true;\n    }\n\n    const [{params, body} = {}] = prom.arguments;\n\n    if (!params?.length) {\n      return false;\n    }\n\n    const [{name: resolverName}] = params;\n\n    return hasNonEmptyResolverCall(body, resolverName);\n  });\n};\n\n// eslint-disable-next-line complexity\nconst hasNonFunctionYield = (node, checkYieldReturnValue) => {\n  if (!node) {\n    return false;\n  }\n  switch (node.type) {\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return ![\n        'ArrowFunctionExpression',\n        'FunctionDeclaration',\n        'FunctionExpression',\n      ].includes(bodyNode.type) && hasNonFunctionYield(\n        bodyNode, checkYieldReturnValue,\n      );\n    });\n  }\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return node.arguments.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'ChainExpression':\n  case 'ExpressionStatement': {\n    return hasNonFunctionYield(node.expression, checkYieldReturnValue);\n  }\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonFunctionYield(node.body, checkYieldReturnValue);\n  }\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonFunctionYield(node.test, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.consequent, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.alternate, checkYieldReturnValue);\n  }\n  case 'TryStatement': {\n    return hasNonFunctionYield(node.block, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.handler && node.handler.body, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.finalizer, checkYieldReturnValue);\n  }\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonFunctionYield(nde, checkYieldReturnValue);\n        });\n      },\n    );\n  }\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'AssignmentPattern':\n    return hasNonFunctionYield(node.right, checkYieldReturnValue);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonFunctionYield(nde, checkYieldReturnValue);\n    });\n  }\n  case 'VariableDeclarator': {\n    return hasNonFunctionYield(node.id, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.init, checkYieldReturnValue);\n  }\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonFunctionYield(node.left, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.right, checkYieldReturnValue);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonFunctionYield(subExpression, checkYieldReturnValue);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonFunctionYield(property, checkYieldReturnValue);\n    });\n\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  /* eslint-enable no-fallthrough */\n  case 'Property':\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.value, checkYieldReturnValue);\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      node.arguments.some((nde) => {\n        return hasNonFunctionYield(nde, checkYieldReturnValue);\n      });\n\n  case 'SpreadElement':\n  case 'UnaryExpression':\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n\n  case 'TaggedTemplateExpression':\n    return hasNonFunctionYield(node.quasi, checkYieldReturnValue);\n\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonFunctionYield(node.object, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.property, checkYieldReturnValue);\n\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonFunctionYield(node.source, checkYieldReturnValue);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n  }\n\n  case 'YieldExpression': {\n    if (checkYieldReturnValue) {\n      if (node.parent.type === 'VariableDeclarator') {\n        return true;\n      }\n\n      return false;\n    }\n\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    return true;\n  }\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @returns {boolean}\n */\nconst hasYieldValue = (node, checkYieldReturnValue) => {\n  return node.generator && (\n    node.expression || hasNonFunctionYield(node.body, checkYieldReturnValue)\n  );\n};\n\n/**\n * Checks if a node has a throws statement.\n *\n * @param {object} node\n * @param {boolean} innerFunction\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasThrowValue = (node, innerFunction) => {\n  if (!node) {\n    return false;\n  }\n\n  // There are cases where a function may execute its inner function which\n  //   throws, but we're treating functions atomically rather than trying to\n  //   follow them\n  switch (node.type) {\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return !innerFunction && hasThrowValue(node.body, true);\n  }\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasThrowValue(bodyNode);\n    });\n  }\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasThrowValue(node.body);\n  }\n  case 'IfStatement': {\n    return hasThrowValue(node.consequent) || hasThrowValue(node.alternate);\n  }\n\n  // We only consider it to throw an error if the catch or finally blocks throw an error.\n  case 'TryStatement': {\n    return hasThrowValue(node.handler && node.handler.body) ||\n        hasThrowValue(node.finalizer);\n  }\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasThrowValue(nde);\n        });\n      },\n    );\n  }\n  case 'ThrowStatement': {\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/** @param {string} tag */\n/*\nconst isInlineTag = (tag) => {\n  return /^(@link|@linkcode|@linkplain|@tutorial) /u.test(tag);\n};\n*/\n\n/**\n * Parses GCC Generic/Template types\n *\n * @see {https://github.com/google/closure-compiler/wiki/Generic-Types}\n * @see {https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#template}\n * @param {JsDocTag} tag\n * @returns {Array<string>}\n */\nconst parseClosureTemplateTag = (tag) => {\n  return tag.name\n    .split(',')\n    .map((type) => {\n      return type.trim();\n    });\n};\n\n/**\n * Checks user option for `contexts` array, defaulting to\n *   contexts designated by the rule. Returns an array of\n *   ESTree AST types, indicating allowable contexts.\n *\n * @param {*} context\n * @param {true|string[]} defaultContexts\n * @returns {string[]}\n */\nconst enforcedContexts = (context, defaultContexts) => {\n  const {\n    contexts = defaultContexts === true ? [\n      'ArrowFunctionExpression',\n      'FunctionDeclaration',\n      'FunctionExpression',\n    ] : defaultContexts,\n  } = context.options[0] || {};\n\n  return contexts;\n};\n\n/**\n * @param {string[]} contexts\n * @param {Function} checkJsdoc\n */\nconst getContextObject = (contexts, checkJsdoc) => {\n  const properties = {};\n\n  contexts.forEach((prop) => {\n    if (typeof prop === 'object') {\n      properties[prop.context] = checkJsdoc;\n    } else {\n      properties[prop] = checkJsdoc;\n    }\n  });\n\n  return properties;\n};\n\nconst filterTags = (tags, filter) => {\n  return tags.filter(filter);\n};\n\nconst tagsWithNamesAndDescriptions = new Set([\n  'param', 'arg', 'argument', 'property', 'prop',\n  'template',\n\n  // These two are parsed by our custom parser as though having a `name`\n  'returns', 'return',\n]);\n\nconst getTagsByType = (context, mode, tags, tagPreference) => {\n  const descName = getPreferredTagName(context, mode, 'description', tagPreference);\n  const tagsWithoutNames = [];\n  const tagsWithNames = filterTags(tags, (tag) => {\n    const {tag: tagName} = tag;\n    const tagWithName = tagsWithNamesAndDescriptions.has(tagName);\n    if (!tagWithName && tagName !== descName) {\n      tagsWithoutNames.push(tag);\n    }\n\n    return tagWithName;\n  });\n\n  return {\n    tagsWithNames,\n    tagsWithoutNames,\n  };\n};\n\nconst getIndent = (sourceCode) => {\n  return (sourceCode.text.match(/^\\n*([ \\t]+)/u)?.[1] ?? '') + ' ';\n};\n\nconst isConstructor = (node) => {\n  return node?.type === 'MethodDefinition' && node.kind === 'constructor' ||\n    node?.parent?.kind === 'constructor';\n};\n\nconst isGetter = (node) => {\n  return node && node.parent.kind === 'get';\n};\n\nconst isSetter = (node) => {\n  return node && node.parent.kind === 'set';\n};\n\nconst hasAccessorPair = (node) => {\n  const {type, kind: sourceKind, key: {name: sourceName}} = node;\n  const oppositeKind = sourceKind === 'get' ? 'set' : 'get';\n\n  const children = type === 'MethodDefinition' ? 'body' : 'properties';\n\n  return node.parent[children].some(({kind, key: {name}}) => {\n    return kind === oppositeKind && name === sourceName;\n  });\n};\n\nconst exemptSpeciaMethods = (jsdoc, node, context, schema) => {\n  const hasSchemaOption = (prop) => {\n    const schemaProperties = schema[0].properties;\n\n    return context.options[0]?.[prop] ??\n      (schemaProperties[prop] && schemaProperties[prop].default);\n  };\n\n  const checkGetters = hasSchemaOption('checkGetters');\n  const checkSetters = hasSchemaOption('checkSetters');\n\n  return !hasSchemaOption('checkConstructors') &&\n    (\n      isConstructor(node) ||\n      hasATag(jsdoc, [\n        'class',\n        'constructor',\n      ])) ||\n  isGetter(node) && (\n    !checkGetters ||\n    checkGetters === 'no-setter' && hasAccessorPair(node.parent)\n  ) ||\n  isSetter(node) && (\n    !checkSetters ||\n    checkSetters === 'no-getter' && hasAccessorPair(node.parent)\n  );\n};\n\n/**\n * Since path segments may be unquoted (if matching a reserved word,\n * identifier or numeric literal) or single or double quoted, in either\n * the `@param` or in source, we need to strip the quotes to give a fair\n * comparison.\n *\n * @param {string} str\n * @returns {string}\n */\nconst dropPathSegmentQuotes = (str) => {\n  return str.replace(/\\.(['\"])(.*)\\1/gu, '.$2');\n};\n\nconst comparePaths = (name) => {\n  return (otherPathName) => {\n    return otherPathName === name ||\n      dropPathSegmentQuotes(otherPathName) === dropPathSegmentQuotes(name);\n  };\n};\n\nconst getRegexFromString = (regexString, requiredFlags) => {\n  const match = regexString.match(/^\\/(.*)\\/([gimyus]*)$/us);\n  let flags = 'u';\n  let regex = regexString;\n  if (match) {\n    [, regex, flags] = match;\n    if (!flags) {\n      flags = 'u';\n    }\n  }\n\n  const uniqueFlags = [...new Set(flags + (requiredFlags || ''))];\n  flags = uniqueFlags.join('');\n\n  return new RegExp(regex, flags);\n};\n\nexport default {\n  comparePaths,\n  dropPathSegmentQuotes,\n  enforcedContexts,\n  exemptSpeciaMethods,\n  filterTags,\n  flattenRoots,\n  getContextObject,\n  getFunctionParameterNames,\n  getIndent,\n  getJsdocTagsDeep,\n  getPreferredTagName,\n  getRegexFromString,\n  getTagsByType,\n  getTagStructureForMode,\n  hasATag,\n  hasDefinedTypeTag,\n  hasParams,\n  hasReturnValue,\n  hasTag,\n  hasThrowValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n  hasYieldValue,\n  isConstructor,\n  isGetter,\n  isNamepathDefiningTag,\n  isSetter,\n  isValidTag,\n  overrideTagStructure,\n  parseClosureTemplateTag,\n  setTagStructure,\n  tagMightHaveNamepath,\n  tagMightHaveNamePosition,\n  tagMightHaveTypePosition,\n  tagMissingRequiredTypeOrNamepath,\n  tagMustHaveNamePosition,\n  tagMustHaveTypePosition,\n};\n"],"file":"jsdocUtils.js"}
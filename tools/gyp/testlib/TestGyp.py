# Copyright (c) 2012 Google Inc. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""
TestGyp.py:  a testing framework for GYP integration tests.
"""
from __future__ import print_function

import collections
import errno
import itertools
import os
import re
import shutil
import subprocess
import sys
import tempfile
import json
import traceback

from contextlib import contextmanager

from SConsLib import TestCommon
from SConsLib.TestCmd import IS_PY3, is_List, match_re as test_cmd_match_re

RPATH_RE = re.compile(r'Library (?:r|run)path: \[([^\]]+)\]')
RPROG_RE = re.compile(r'\[Requesting program interpreter: ([^\]]+)\]')
BUILDTOOLS_RE = re.compile(r"^xcode-select: error: tool 'xcodebuild' requires Xcode.*$\n", re.MULTILINE)
PYDEV_RE = re.compile(r"^pydev debugger.*$\n+", re.MULTILINE)

def remove_debug_line_numbers(contents):
  """Function to remove the line numbers from the debug output
  of gyp and thus reduce the extreme fragility of the stdout
  comparison tests.
  """
  lines = contents.splitlines()
  # split each line on first 4 ":"
  lines = [l.split(":", 3) for l in lines]
  # join each line back together while ignoring the
  # 3rd column which is the line number
  lines = [l[-1] for l in lines if len(l) > 3]
  matches = [eval(l.split(':', 1)[1]) for l in lines if l.startswith('ExpandVariables Matches')]
  matches = sorted([
    ' '.join(["%s=%s" % (k, d[k]) for k in sorted(d.keys())])
    for d in matches
  ])
  found_output = sorted([l for l in lines if l.startswith('ExpandVariables Found output')])
  return '\n'.join(matches + found_output)


def match_modulo_line_numbers(contents_a, contents_b):
  """File contents matcher that ignores line numbers."""
  return TestCommon.match_exact(contents_a, contents_b)


def mk_temp_dir(workdir):
  # Put test output in out/testworkarea by default.
  # Use temporary names so there are no collisions.
  workdir = workdir or 'testworkarea'
  workdir = os.path.join('out', workdir)
  # Create work area if it doesn't already exist.
  if not os.path.isdir(workdir):
    os.makedirs(workdir)
  return tempfile.mktemp(prefix='testgyp.', dir=workdir)


@contextmanager
def LocalEnv(local_env):
  """Context manager to provide a local OS environment."""
  old_env = os.environ.copy()
  os.environ.update(local_env)
  try:
    yield
  finally:
    os.environ.clear()
    os.environ.update(old_env)


# noinspection PyAttributeOutsideInit
class TestGypBase(TestCommon.TestCommon):
  """
  Class for controlling end-to-end tests of gyp generators.

  Instantiating this class will create a temporary directory and
  arrange for its destruction (via the TestCmd superclass) and
  copy all of the non-gyptest files in the directory hierarchy of the
  executing script.

  The default behavior is to test the 'gyp' or 'gyp.bat' file in the
  current directory.  An alternative may be specified explicitly on
  instantiation, or by setting the TESTGYP_GYP environment variable.

  This class should be subclassed for each supported gyp generator
  (format).  Various abstract methods below define calling signatures
  used by the test scripts to invoke builds on the generated build
  configuration and to run executables generated by those builds.
  """

  format = ''
  formats = []
  build_tool = None
  build_tool_list = []

  _exe = TestCommon.exe_suffix
  _obj = TestCommon.obj_suffix
  shobj_ = TestCommon.shobj_prefix
  _shobj = TestCommon.shobj_suffix
  lib_ = TestCommon.lib_prefix
  _lib = TestCommon.lib_suffix
  dll_ = TestCommon.dll_prefix
  _dll = TestCommon.dll_suffix
  module_ = TestCommon.module_prefix
  _module = TestCommon.module_suffix

  # Constants to represent different targets.
  ALL = '__all__'
  DEFAULT = '__default__'

  # Constants for different target types.
  EXECUTABLE = '__executable__'
  STATIC_LIB = '__static_lib__'
  SHARED_LIB = '__shared_lib__'
  LOADABLE_MODULE = '__loadable_module__'

  def __init__(self, gyp=None, **kw):
    origin_cwd = os.path.abspath(os.path.dirname(sys.argv[0]))

    kw.setdefault('match', TestCommon.match_exact)
    kw.setdefault('interpreter', sys.executable)
    if 'description' not in kw:
      bt = [t[0] for t in traceback.extract_stack() if 'gyptest' in t[0]]
      kw['description'] = bt and bt.pop()
    kw['workdir'] = mk_temp_dir(kw.get('workdir'))
    kw_formats = kw.pop('formats', [])

    if not gyp:
      gyp = os.environ.get('TESTGYP_GYP', 'gyp_main.py')
    gyp = os.path.abspath(gyp)
    kw.setdefault('program', gyp)

    super(TestGypBase, self).__init__(**kw)

    self.extra_args = sys.argv[1:]
    self.origin_cwd=origin_cwd
    self.gyp = gyp

    self.formats = [self.format]

    self.initialize_build_tool()

    if kw_formats:
      excluded_formats = {f[1:] for f in kw_formats if f[0] == '!'}
      explicit_formats = {f for f in kw_formats if f[0] != '!'}
      possible_formats = set([self.format] + self.format.split('-'))
      if excluded_formats.intersection(possible_formats):
        self.skip_test('Test excluded for %s format' % self.format)
      if explicit_formats and not explicit_formats.intersection(possible_formats):
        self.skip_test('Test format %s not explicitly included' % self.format)

    self.dir_fixture(self.origin_cwd)
    self.set_configuration(None)
    self.is_make = 'make' in self.format.split('-')
    self.is_ninja = 'ninja' in self.format.split('-')

    # Set $HOME so that gyp doesn't read the user's actual
    # ~/.gyp/include.gypi file, which may contain variables
    # and other settings that would change the output.
    os.environ['HOME'] = self.workpath()
    # Clear $GYP_DEFINES for the same reason.
    if 'GYP_DEFINES' in os.environ:
      del os.environ['GYP_DEFINES']
    # Override the user's language settings, which could
    # otherwise make the output vary from what is expected.
    os.environ['LC_ALL'] = 'C'

  def __del__(self):
    return

  def _complete(self, actual_stdout, expected_stdout, actual_stderr, expected_stderr, status, match):
    if sys.platform == 'darwin' and actual_stderr:
      actual_stderr = BUILDTOOLS_RE.sub('', actual_stderr)
    if actual_stderr:
      actual_stderr = PYDEV_RE.sub('', actual_stderr)
    if match.__name__ == 'match_modulo_line_numbers':
      if actual_stdout:
        actual_stdout = remove_debug_line_numbers(actual_stdout)
      if expected_stdout:
        expected_stdout = remove_debug_line_numbers(expected_stdout)
    return super(TestGypBase, self)._complete(actual_stdout, expected_stdout, actual_stderr, expected_stderr, status, match)

  def built_file_must_exist(self, name, type=None, remove=False, **kw):
    """
    Fails the test if the specified built file name does not exist.
    """
    path = self.built_file_path(name, type, **kw)
    self.must_exist(path)
    if remove:
      os.remove(path)

  def built_file_must_not_exist(self, name, type=None, **kw):
    """
    Fails the test if the specified built file name exists.
    """
    return self.must_not_exist(self.built_file_path(name, type, **kw))

  def built_file_must_match(self, name, contents, **kw):
    """
    Fails the test if the contents of the specified built file name
    do not match the specified contents.
    """
    return self.must_match(self.built_file_path(name, **kw), contents)

  def built_file_must_not_contain(self, name, contents, **kw):
    """
    Fails the test if the specified built file name contains the specified
    contents.
    """
    return self.must_not_contain(self.built_file_path(name, **kw), contents)

  def cleanup(self, condition=None):
    os.chdir(self._cwd)
    self.workdir = None
    if not self._dirlist:
      return
    if self._preserve.get(condition or self.condition):
      if self.verbose:
        for d in self._dirlist:
          print(u"Preserved directory %s" % d, file=sys.stderr)
      return
    lst = self._dirlist[:]
    lst.reverse()
    for d in lst:
      self.writable(d, 1)
      shutil.rmtree(d, ignore_errors=True)
    self._dirlist = []
    # noinspection PyProtectedMember
    from SConsLib.TestCmd import _Cleanup
    if self in _Cleanup:
      _Cleanup.remove(self)

  def fail_test(self, condition=1, function=None, skip=0, message=None):
    """Cause the test to fail.

    By default, the fail_test() method reports that the test FAILED
    and exits with a status of 1.  If a condition argument is supplied,
    the test fails only if the condition is true.
    """
    if not condition:
      return
    self.condition = 'fail_test'
    if not function is None:
      function()
    of = ""
    desc = ""
    sep = ""
    if self.program:
      of = " of " + self.program
      sep = "\n"
    if self.description:
      desc = " [" + self.description + "]"
      sep = "\n"

    string = ""
    tb = [t for t in traceback.extract_stack() if os.path.basename(t[0]) not in ("TestCmd.py", "TestCommon.py", "TestGyp.py")]
    for file, line, name, text in tb[skip:]:
      if name not in ("?", "<module>"):
        name = " (" + name + ")"
      string += ("%s:%d at %s\n" % (file, line, name))
    sys.stderr.flush()
    sys.stderr.write("FAILED test:\n" + of + desc + sep)
    sys.stderr.write(string)
    sys.stderr.flush()

    sys.exit(1)

  def initialize_build_tool(self):
    """
    Initializes the .build_tool attribute.

    Searches the .build_tool_list for an executable name on the user's
    $PATH.  The first tool on the list is used as-is if nothing is found
    on the current $PATH.
    """
    for build_tool in self.build_tool_list:
      if not build_tool:
        continue
      if os.path.isabs(build_tool):
        self.build_tool = build_tool
        return
      build_tool = self.where_is(build_tool)
      if build_tool:
        self.build_tool = build_tool
        return

    if self.build_tool_list:
      self.build_tool = self.build_tool_list[0]

  def must_match(self, file, expect, mode='rt', match=None, message=None, newline=None):
    super(TestGypBase, self).must_match(file, expect, mode, match, message, newline)

  def must_contain(self, file, required, mode='rt', find=None):
    if isinstance(required, list) and not find:
      def find(content, subseq):
        seq = content.splitlines()
        seq_len = len(seq)
        seq_strp = [l.strip() for l in seq]
        sub_len = len(subseq)
        subseq_strp = [l.strip() for l in subseq]
        return any(seq_strp[i:i+sub_len] == subseq_strp for i in range(seq_len))
    super(TestGypBase, self).must_contain(file, required, mode, find)

  def must_not_contain(self, file, banned, mode='rt', find=None):
    super(TestGypBase, self).must_not_contain(file, banned, mode, find)

  def read(self, file, mode='rt', newline=None, encoding='utf-8'):
    file = self.canonicalize(file)
    if mode[0] != 'r':
      raise ValueError("mode must begin with 'r'")
    kw = {
      'mode': mode,
    }
    if IS_PY3 and 'b' not in mode:
        kw['encoding'] = encoding
        kw['newline'] = newline
    elif newline is None:
      kw['mode'] = kw['mode'].replace('t', 'U')

    with open(file, **kw) as f:
      ret = f.read()

    if not IS_PY3 and 'b' not in mode:
      ret = ret.encode(encoding)

    return ret

  def relocate(self, source, destination):
    """
    Renames (relocates) the specified source (usually a directory)
    to the specified destination, creating the destination directory
    first if necessary.

    Note:  Don't use this as a generic "rename" operation.  In the
    future, "relocating" parts of a GYP tree may affect the state of
    the test to modify the behavior of later method calls.
    """
    destination_dir = os.path.dirname(destination)
    if not os.path.exists(destination_dir):
      self.subdir(destination_dir)
    os.rename(source, destination)

  def report_not_up_to_date(self):
    """
    Reports that a build is not up-to-date.

    This provides common reporting for formats that have complicated
    conditions for checking whether a build is up-to-date.  Formats
    that expect exact output from the command (make) can
    just set stdout= when they call the run_build() method.
    """
    print("Build is not up-to-date:")
    print(self.banner('STDOUT '))
    print(self.stdout())
    stderr = self.stderr()
    if stderr:
      print(self.banner('STDERR '))
      print(stderr)

  def run_gyp(self, gyp_file, *args, **kw):
    """
    Runs gyp against the specified gyp_file with the specified args.
    """
    if kw.pop('ignore_line_numbers', False):
      kw.setdefault('match', match_modulo_line_numbers)

    # TODO:  --depth=. works around Chromium-specific tree climbing.
    depth = kw.pop('depth', '.')
    run_args = ['--depth='+depth]
    run_args.extend(['--format=' + f.replace('-mock', '') for f in self.formats])
    run_args.append(gyp_file)

    run_args.extend(self.extra_args)

    # Default xcode_ninja_target_pattern to ^.*$ to fix xcode-ninja tests
    xcode_ninja_target_pattern = kw.pop('xcode_ninja_target_pattern', '.*')
    if self is TestGypXcodeNinja:
      run_args.extend(['-G', 'xcode_ninja_target_pattern=%s' % xcode_ninja_target_pattern])

    # TODO: if extra_args contains a '--build' flag we really want that to only apply to the last format (self.format).
    run_args.extend(args)

    if 'mock' in self.format and any('--build' in a for a in run_args):
      self.skip_test("--build skipped for 'mock' formats")

    return self.run(program=self.gyp, interpreter=self.interpreter, arguments=run_args, **kw)

  def run(self, *args, **kw):
    """
    Executes a program by calling the superclass .run() method.

    This exists to provide a common place to filter out keyword
    arguments implemented in this layer, without having to update
    the tool-specific subclasses or clutter the tests themselves
    with platform-specific code.
    """
    if 'SYMROOT' in kw:
      del kw['SYMROOT']
    return super(TestGypBase, self).run(*args, **kw)

  def run_built_executable(self, name, *args, **kw):
    # Enclosing the name in a list avoids prepending the original dir.
    program = [self.built_file_path(name, type=self.EXECUTABLE, **kw)]
    if sys.platform == 'darwin':
      configuration = self.configuration_dirname()
      build_dir = 'build' if self.format == 'xcode' else 'out'
      os.environ['DYLD_LIBRARY_PATH'] = os.path.join(build_dir, configuration)
    return self.run(program=program, *args, **kw)

  def set_configuration(self, configuration):
    """
    Sets the configuration, to be used for invoking the build
    tool and testing potential built output.
    """
    self.configuration = configuration

  def configuration_dirname(self):
    if self.configuration:
      return self.configuration.split('|')[0]
    else:
      return 'Default'

  def configuration_platform(self):
    if self.configuration and '|' in self.configuration:
      return self.configuration.split('|')[1]
    else:
      return ''

  def configuration_buildname(self):
    if self.configuration:
      return self.configuration
    else:
      return 'Default'


  def no_result(self, condition=1, function=None, skip=0):
    """
    Report that the test could not be run.
    """
    if skip:
      sys.exit(2)
    else:
      super(TestGypBase, self).no_result(condition, function, skip)

  def run_readelf(self, p, chdir='', flag='-d'):
    r = RPATH_RE if flag == '-d' else RPROG_RE
    p = self.built_file_path(p, chdir=chdir)
    o = subprocess.check_output(['readelf', flag, p]).decode('utf-8')
    return r.findall(o)


  #
  # Abstract methods to be defined by format-specific subclasses.
  #

  def build(self, gyp_file, target=None, **kw):
    """
    Runs a build of the specified target against the configuration
    generated from the specified gyp_file.

    A 'target' argument of None or the special value TestGyp.DEFAULT
    specifies the default argument for the underlying build tool.
    A 'target' argument of TestGyp.ALL specifies the 'all' target
    (if any) of the underlying build tool.
    """
    raise NotImplementedError

  def built_file_path(self, name, type=None, **kw):
    """
    Returns a path to the specified file name, of the specified type.
    """
    raise NotImplementedError

  def built_file_basename(self, name, type=None, **kw):
    """
    Returns the base name of the specified file name, of the specified type.

    A bare=True keyword argument specifies that prefixes and suffixes shouldn't
    be applied.
    """
    if not kw.get('bare'):
      if type == self.EXECUTABLE:
        name = name + self._exe
      elif type == self.STATIC_LIB:
        name = self.lib_ + name + self._lib
      elif type == self.SHARED_LIB:
        name = self.dll_ + name + self._dll
      elif type == self.LOADABLE_MODULE:
        name = self.module_ + name + self._module
    return name

  def up_to_date(self, gyp_file, target=None, **kw):
    """
    Verifies that a build of the specified target is up to date.

    The subclass should implement this by calling build()
    (or a reasonable equivalent), checking whatever conditions
    will tell it the build was an "up to date" null build, and
    failing if it isn't.
    """
    raise NotImplementedError


class TestGypGypd(TestGypBase):
  """
  Subclass for testing the GYP 'gypd' generator (spit out the
  internal data structure as pretty-printed Python).
  """
  format = 'gypd'


class TestGypCustom(TestGypBase):
  """
  Subclass for testing the GYP with custom generator
  """

  def __init__(self, **kw):
    self.format = kw.pop("format")
    super(TestGypCustom, self).__init__(**kw)


class TestGypCMake(TestGypBase):
  """
  Subclass for testing the GYP CMake generator, using cmake's ninja backend.
  """
  format = 'cmake'
  build_tool_list = ['cmake']
  ALL = 'all'

  def cmake_build(self, **kw):
    arguments = kw.get('arguments', [])[:]

    self.build_tool_list = ['cmake']
    self.initialize_build_tool()

    chdir = os.path.join(kw.get('chdir', '.'), 'out', self.configuration_dirname())
    kw['chdir'] = chdir

    arguments.append('-G')
    arguments.append('Ninja')

    kw['arguments'] = arguments

    stderr = kw.get('stderr', None)
    if stderr:
      kw['stderr'] = stderr.split('$$$')[0]

    self.run(program=self.build_tool, **kw)

  def ninja_build(self, _, target=None, **kw):
    arguments = kw.get('arguments', [])[:]

    self.build_tool_list = ['ninja']
    self.initialize_build_tool()

    # Add a -C output/path to the command line.
    arguments.append('-C')
    arguments.append(os.path.join('out', self.configuration_dirname()))

    if target not in (None, self.DEFAULT):
      arguments.append(target)

    kw['arguments'] = arguments

    stderr = kw.get('stderr', None)
    if stderr:
      stderrs = stderr.split('$$$')
      kw['stderr'] = stderrs[1] if len(stderrs) > 1 else ''

    return self.run(program=self.build_tool, **kw)

  def build(self, gyp_file, target=None, status=0, **kw):
    # Two tools must be run to build, cmake and the ninja.
    # Allow cmake to succeed when the overall expectation is to fail.
    if status is None:
      kw['status'] = None
    else:
      if not isinstance(status, collections.Iterable): status = (status,)
      kw['status'] = list(itertools.chain((0,), status))
    self.cmake_build(**kw)
    kw['status'] = status
    self.ninja_build(gyp_file, target, **kw)

  def built_file_path(self, name, type=None, **kw):
    result = []
    chdir = kw.get('chdir')
    if chdir:
      result.append(chdir)
    result.append('out')
    result.append(self.configuration_dirname())
    if type == self.STATIC_LIB:
      if sys.platform != 'darwin':
        result.append('obj.target')
    elif type == self.SHARED_LIB:
      if sys.platform != 'darwin' and sys.platform != 'win32':
        result.append('lib.target')
    subdir = kw.get('subdir')
    if subdir and type != self.SHARED_LIB:
      result.append(subdir)
    result.append(self.built_file_basename(name, type, **kw))
    return self.workpath(*result)

  def up_to_date(self, gyp_file, target=None, **kw):
    result = self.ninja_build(gyp_file, target, **kw)
    if not result:
      stdout = self.stdout()
      if 'ninja: no work to do' not in stdout:
        self.report_not_up_to_date()
        self.fail_test()
    return result


class TestGypMake(TestGypBase):
  """
  Subclass for testing the GYP Make generator.
  """
  format = 'make'
  build_tool_list = ['make']
  ALL = 'all'
  def build(self, gyp_file, target=None, **kw):
    """
    Runs a Make build using the Makefiles generated from the specified
    gyp_file.
    """
    arguments = kw.get('arguments', [])[:]
    if self.configuration:
      arguments.append('BUILDTYPE=' + self.configuration)
    if target not in (None, self.DEFAULT):
      arguments.append(target)
    # Sub-directory builds provide per-gyp Makefiles (i.e.
    # Makefile.gyp_filename), so use that if there is no Makefile.
    chdir = kw.get('chdir', '')
    if not os.path.exists(os.path.join(chdir, 'Makefile')):
      print("NO Makefile in " + os.path.join(chdir, 'Makefile'))
      arguments.insert(0, '-f')
      arguments.insert(1, os.path.splitext(gyp_file)[0] + '.Makefile')
    kw['arguments'] = arguments
    return self.run(program=self.build_tool, **kw)

  def up_to_date(self, gyp_file, target=None, **kw):
    """
    Verifies that a build of the specified Make target is up to date.
    """
    if target in (None, self.DEFAULT):
      message_target = 'all'
    else:
      message_target = target
    kw['stdout'] = "make: Nothing to be done for ['`]%s'.\n" % message_target
    kw['match'] = test_cmd_match_re
    return self.build(gyp_file, target, **kw)

  def run_built_executable(self, name, *args, **kw):
    """
    Runs an executable built by Make.
    """
    configuration = self.configuration_dirname()
    libdir = os.path.join('out', configuration, 'lib')
    # TODO(piman): when everything is cross-compile safe, remove lib.target
    if sys.platform == 'darwin':
      # Mac puts target shared libraries right in the product directory.
      configuration = self.configuration_dirname()
      os.environ['DYLD_LIBRARY_PATH'] = (
          libdir + '.host:' + os.path.join('out', configuration))
    else:
      os.environ['LD_LIBRARY_PATH'] = libdir + '.host:' + libdir + '.target'
    # Enclosing the name in a list avoids prepending the original dir.
    program = [self.built_file_path(name, type=self.EXECUTABLE, **kw)]
    return self.run(program=program, *args, **kw)

  def built_file_path(self, name, type=None, **kw):
    """
    Returns a path to the specified file name, of the specified type,
    as built by Make.

    Built files are in the subdirectory 'out/{configuration}'.
    The default is 'out/Default'.

    A chdir= keyword argument specifies the source directory
    relative to which  the output subdirectory can be found.

    "type" values of STATIC_LIB or SHARED_LIB append the necessary
    prefixes and suffixes to a platform-independent library base name.

    A subdir= keyword argument specifies a library subdirectory within
    the default 'obj.target'.
    """
    result = []
    chdir = kw.get('chdir')
    if chdir:
      result.append(chdir)
    configuration = self.configuration_dirname()
    result.extend(['out', configuration])
    if type == self.STATIC_LIB and sys.platform != 'darwin':
      result.append('obj.target')
    elif type == self.SHARED_LIB and sys.platform != 'darwin':
      result.append('lib.target')
    subdir = kw.get('subdir')
    if subdir and type != self.SHARED_LIB:
      result.append(subdir)
    result.append(self.built_file_basename(name, type, **kw))
    return self.workpath(*result)

def ConvertToCygpath(path):
  """Convert to cygwin path if we are using cygwin."""
  if sys.platform == 'cygwin':
    p = subprocess.Popen(['cygpath', path], stdout=subprocess.PIPE)
    path = p.communicate()[0].strip()
  return path


def MakeDirs(new_dir):
  """A wrapper around os.makedirs() that emulates "mkdir -p"."""
  try:
    os.makedirs(new_dir)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise

def GetDefaultKeychainPath():
  """Get the keychain path, for used before updating HOME."""
  assert sys.platform == 'darwin'
  # Format is:
  # $ security default-keychain
  #     "/Some/Path/To/default.keychain"
  path = subprocess.check_output(['security', 'default-keychain']).decode(
      'utf-8', 'ignore').strip()
  return path[1:-1]

def FindMSBuildInstallation(msvs_version = 'auto'):
  """Returns path to MSBuild for msvs_version or latest available.

  Looks in the registry to find install location of MSBuild.
  MSBuild before v4.0 will not build c++ projects, so only use newer versions.
  """
  from gyp.MSVS.MSVSVersion import TryQueryRegistryValue

  msvs_to_msbuild = {
    '2015': '14.0',
    '2013': '12.0',
    '2012': '4.0',  # Really v4.0.30319 which comes with .NET 4.5.
    '2010': '4.0'
  }

  msbuild_base_key = r'SOFTWARE\Microsoft\MSBuild\ToolsVersions'
  if not TryQueryRegistryValue(msbuild_base_key):
    print('Error: could not find MSBuild base registry entry')
    return None

  msbuild_key = ''
  found_msbuild_ver = ''
  if msvs_version in msvs_to_msbuild:
    msbuild_test_version = msvs_to_msbuild[msvs_version]
    msbuild_key = msbuild_base_key + '\\' + msbuild_test_version
    if TryQueryRegistryValue(msbuild_key):
      found_msbuild_ver = msbuild_test_version
    else:
      print('Warning: Environment variable GYP_MSVS_VERSION specifies "%s" but corresponding MSBuild "%s" was not found.' % (msvs_version, found_msbuild_ver))
  if not found_msbuild_ver:
    for msvs_version in sorted(msvs_to_msbuild.keys(), reverse=True):
      msbuild_test_version = msvs_to_msbuild[msvs_version]
      msbuild_key = msbuild_base_key + '\\' + msbuild_test_version
      if TryQueryRegistryValue(msbuild_key):
        found_msbuild_ver = msbuild_test_version
        break
  if not found_msbuild_ver:
    print('Error: could not find am MSBuild registry entry')
    return None

  msbuild_path = TryQueryRegistryValue(msbuild_key, 'MSBuildToolsPath')
  if not msbuild_path:
    print('Error: could not get MSBuildToolsPath registry entry value for MSBuild version %s' % found_msbuild_ver)
    return None

  return os.path.join(msbuild_path, 'MSBuild.exe')


def FindVisualStudioInstallation():
  """
  Returns appropriate values for .build_tool and .uses_msbuild fields
  of TestGypBase for Visual Studio.

  We use the value specified by GYP_MSVS_VERSION.  If not specified, we
  search for likely deployment paths.
  """
  override_build_tool = os.environ.get('GYP_BUILD_TOOL')
  if override_build_tool:
    return override_build_tool, True, override_build_tool

  msvs_version = 'auto'
  for flag in (f for f in sys.argv if f.startswith('msvs_version=')):
    msvs_version = flag.split('=')[-1]
  msvs_version = os.environ.get('GYP_MSVS_VERSION', msvs_version)

  if msvs_version == 'auto' or msvs_version >= '2017':
    msbuild_exes = []
    try:
      args1 = [
        r'C:\Program Files (x86)\Microsoft Visual Studio\Installer\vswhere.exe',
        '-latest', '-products', '*', '-prerelease', '-format', 'json',
        '-requires', 'Microsoft.VisualStudio.Component.VC.Tools.x86.x64',
      ]
      vswhere_json = subprocess.check_output(args1)
      vswhere_infos = json.loads(vswhere_json)
      if len(vswhere_infos) == 0:
        raise IOError("vswhere did not find any MSVS instances.")
      top_vs_info = vswhere_infos[0]
      if top_vs_info:
        inst_path = top_vs_info['installationPath']
        args2 = ['cmd.exe', '/d', '/c',
                 'cd', '/d', inst_path,
                 '&', 'dir', '/b', '/s', 'msbuild.exe']
        msbuild_exes = subprocess.check_output(args2).strip().splitlines()
      if len(msbuild_exes):
        msbuild_path = str(msbuild_exes[0].decode('utf-8'))
        os.environ['GYP_MSVS_VERSION'] = str(top_vs_info['catalog']['productLineVersion'])
        os.environ['GYP_BUILD_TOOL'] = msbuild_path
        return msbuild_path, True, msbuild_path
    except Exception as e:
      traceback.print_exc(file=sys.stderr)
      print(e, file=sys.stderr)
      pass

  possible_roots = ['%s:\\Program Files%s' % (chr(drive), suffix)
                    for drive in range(ord('C'), ord('Z') + 1)
                    for suffix in ['', ' (x86)']]
  possible_paths = {
    '2015': r'Microsoft Visual Studio 14.0\Common7\IDE\devenv.com',
    '2013': r'Microsoft Visual Studio 12.0\Common7\IDE\devenv.com',
    '2012': r'Microsoft Visual Studio 11.0\Common7\IDE\devenv.com',
    '2010': r'Microsoft Visual Studio 10.0\Common7\IDE\devenv.com',
    '2008': r'Microsoft Visual Studio 9.0\Common7\IDE\devenv.com',
    '2005': r'Microsoft Visual Studio 8\Common7\IDE\devenv.com'}

  possible_roots = [ConvertToCygpath(r) for r in possible_roots]

  # Check that the path to the specified GYP_MSVS_VERSION exists.
  if msvs_version in possible_paths:
    path = possible_paths[msvs_version]
    for r in possible_roots:
      build_tool = os.path.join(r, path)
      if os.path.exists(build_tool):
        uses_msbuild = msvs_version >= '2010'
        msbuild_path = FindMSBuildInstallation(msvs_version)
        return build_tool, uses_msbuild, msbuild_path
    else:
      print('Warning: Environment variable GYP_MSVS_VERSION specifies "%s" '
            'but corresponding "%s" was not found.' % (msvs_version, path))
  print('Error: could not find MSVS version %s' % msvs_version)
  sys.exit(1)


class TestGypOnMSToolchain(TestGypBase):
  """
  Common subclass for testing generators that target the Microsoft Visual
  Studio toolchain (cl, link, dumpbin, etc.)
  """
  @staticmethod
  def _ComputeVsvarsPath(devenv_path):
    # devenv_dir = os.path.split(devenv_path)[0]

    # Check for location of Community install (in VS2017, at least).
    vcvars_path = os.path.join(devenv_path, '..', '..', '..', '..', 'VC', 'Auxiliary', 'Build', 'vcvars32.bat')
    if os.path.exists(vcvars_path):
      return os.path.abspath(vcvars_path)

    vsvars_path = os.path.join(devenv_path, '..', '..', 'Tools', 'vsvars32.bat')
    return os.path.abspath(vsvars_path)

  # noinspection PyAttributeOutsideInit
  def initialize_build_tool(self):
    super(TestGypOnMSToolchain, self).initialize_build_tool()
    if sys.platform in ('win32', 'cygwin'):
      build_tools = FindVisualStudioInstallation()
      self.devenv_path, self.uses_msbuild, self.msbuild_path = build_tools
      self.vsvars_path = TestGypOnMSToolchain._ComputeVsvarsPath(self.devenv_path)

  def run_dumpbin(self, *dumpbin_args):
    """Run the dumpbin tool with the specified arguments, and capturing and
    returning stdout."""
    assert sys.platform in ('win32', 'cygwin')
    cmd = os.environ.get('COMSPEC', 'cmd.exe')
    arguments = [cmd, '/c', self.vsvars_path, '&&', 'dumpbin']
    arguments.extend(dumpbin_args)
    proc = subprocess.Popen(arguments, stdout=subprocess.PIPE)
    output = proc.communicate()[0].decode('utf-8', 'ignore')
    assert not proc.returncode
    return output


class TestGypNinja(TestGypOnMSToolchain):
  """
  Subclass for testing the GYP Ninja generator.
  """
  format = 'ninja'
  build_tool_list = ['ninja']
  ALL = 'all'
  DEFAULT = 'all'

  def run_gyp(self, gyp_file, *args, **kw):
    """

    Args:
      gyp_file (str):
    """
    TestGypBase.run_gyp(self, gyp_file, *args, **kw)

  def build(self, gyp_file, target=None, **kw):
    arguments = kw.get('arguments', [])[:]

    # Add a -C output/path to the command line.
    arguments.append('-C')
    arguments.append(os.path.join('out', self.configuration_dirname()))

    if target is None:
      target = 'all'
    arguments.append(target)

    kw['arguments'] = arguments
    return self.run(program=self.build_tool, **kw)

  def built_file_path(self, name, type=None, **kw):
    result = []
    chdir = kw.get('chdir')
    if chdir:
      result.append(chdir)
    result.append('out')
    result.append(self.configuration_dirname())
    if type == self.STATIC_LIB:
      if sys.platform != 'darwin':
        result.append('obj')
    elif type == self.SHARED_LIB:
      if sys.platform != 'darwin' and sys.platform != 'win32':
        result.append('lib')
    subdir = kw.get('subdir')
    if subdir and type != self.SHARED_LIB:
      result.append(subdir)
    result.append(self.built_file_basename(name, type, **kw))
    return self.workpath(*result)

  def up_to_date(self, gyp_file, target=None, **kw):
    result = self.build(gyp_file, target, **kw)
    if not result:
      stdout = self.stdout()
      if 'ninja: no work to do' not in stdout:
        self.report_not_up_to_date()
        self.fail_test()
    return result


class TestGypMSVS(TestGypOnMSToolchain):
  """
  Subclass for testing the GYP Visual Studio generator.
  """
  format = 'msvs'

  u = r'=== Build: 0 succeeded, 0 failed, (\d+) up-to-date, 0 skipped ==='
  up_to_date_re = re.compile(u, re.M)

  # Initial None element will indicate to our .initialize_build_tool()
  # method below that 'devenv' was not found on %PATH%.
  #
  # Note:  we must use devenv.com to be able to capture build output.
  # Directly executing devenv.exe only sends output to BuildLog.htm.
  build_tool_list = [None, 'devenv.com']

  def initialize_build_tool(self):
    super(TestGypMSVS, self).initialize_build_tool()
    self.build_tool = self.devenv_path

  def build(self, gyp_file, target=None, rebuild=False, clean=False, **kw):
    """
    Runs a Visual Studio build using the configuration generated
    from the specified gyp_file.
    """
    if '15.0' in self.build_tool or 'Current' in self.build_tool:
      build = '/t'
      if target not in (None, self.ALL, self.DEFAULT):
        build += ':' + target
      if clean:
        build += ':Clean'
      elif rebuild:
        build += ':Rebuild'
      elif ':' not in build:
        build += ':Build'
      arguments = kw.get('arguments', [])[:]
      configuration_arg = '/p:Configuration=%s' % self.configuration_dirname()
      arguments.extend([gyp_file.replace('.gyp', '.sln'), build, configuration_arg])
      platform = self.configuration_platform()
      if platform:
        arguments.append('/p:Platform=%s' % platform)
    else:
      configuration_arg = self.configuration_buildname()
      if clean:
        build = '/Clean'
      elif rebuild:
        build = '/Rebuild'
      else:
        build = '/Build'
      arguments = kw.get('arguments', [])[:]
      arguments.extend([gyp_file.replace('.gyp', '.sln'), build, configuration_arg])
      # Note:  the Visual Studio generator doesn't add an explicit 'all'
      # target, so we just treat it the same as the default.
      if target not in (None, self.ALL, self.DEFAULT):
        arguments.extend(['/Project', target])
      if self.configuration:
        arguments.extend(['/ProjectConfig', self.configuration])
    kw['arguments'] = arguments
    return self.run(program=self.build_tool, **kw)
  def up_to_date(self, gyp_file, target=None, **kw):
    r"""
    Verifies that a build of the specified Visual Studio target is up to date.

    Beware that VS2010 will behave strangely if you build under
    C:\USERS\yourname\AppData\Local. It will cause needless work.  The ouptut
    will be "1 succeeded and 0 up to date".  MSBuild tracing reveals that:
    "Project 'C:\Users\...\AppData\Local\...vcxproj' not up to date because
    'C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO 10.0\VC\BIN\1033\CLUI.DLL'
    was modified at 02/21/2011 17:03:30, which is newer than '' which was
    modified at 01/01/0001 00:00:00.

    The workaround is to specify a workdir when instantiating the test, e.g.
    test = TestGyp.TestGyp(workdir='workarea')
    """
    result = self.build(gyp_file, target, **kw)
    if not result:
      stdout = self.stdout()

      m = self.up_to_date_re.search(stdout)
      up_to_date = m and int(m.group(1)) > 0
      if not up_to_date:
        self.report_not_up_to_date()
        self.fail_test()
    return result

  def built_file_path(self, name, type=None, **kw):
    """
    Returns a path to the specified file name, of the specified type, as built by Visual Studio.
    Built files are in a subdirectory that matches the configuration name.  The default is 'Default'.
    A chdir= keyword argument specifies the source directory relative to which  the output subdirectory can be found.
    "type" values of STATIC_LIB or SHARED_LIB append the necessary prefixes and suffixes to a platform-independent library base name.
    """
    result = []
    chdir = kw.get('chdir')
    if chdir:
      result.append(chdir)
    result.append(self.configuration_dirname())
    if type == self.STATIC_LIB:
      result.append('lib')
    result.append(self.built_file_basename(name, type, **kw))
    return self.workpath(*result)


class TestGypMSVSNinja(TestGypNinja):
  """
  Subclass for testing the GYP Visual Studio Ninja generator.
  """
  format = 'msvs-ninja'

  def initialize_build_tool(self):
    super(TestGypMSVSNinja, self).initialize_build_tool()
    # When using '--build', make sure ninja is first in the format list.
    self.formats.insert(0, 'ninja')

  def build(self, gyp_file, target=None, rebuild=False, clean=False, **kw):
    """
    Runs a Visual Studio build using the configuration generated
    from the specified gyp_file.
    """
    arguments = kw.get('arguments', [])[:]
    if target in (None, self.ALL, self.DEFAULT):
      # Note: the Visual Studio generator doesn't add an explicit 'all' target.
      # This will build each project. This will work if projects are hermetic,
      # but may fail if they are not (a project may run more than once).
      # It would be nice to supply an all.metaproj for MSBuild.
      arguments.extend([gyp_file.replace('.gyp', '.sln')])
    else:
      # MSBuild documentation claims that one can specify a sln but then build a
      # project target like 'msbuild a.sln /t:proj:target' but this format only
      # supports 'Clean', 'Rebuild', and 'Publish' (with none meaning Default).
      # This limitation is due to the .sln -> .sln.metaproj conversion.
      # The ':' is not special, 'proj:target' is a target in the metaproj.
      arguments.extend([target+'.vcxproj'])

    if clean:
      build = 'Clean'
    elif rebuild:
      build = 'Rebuild'
    else:
      build = 'Build'
    arguments.extend(['/target:'+build])
    configuration = self.configuration_buildname()
    config = configuration.split('|')
    arguments.extend(['/property:Configuration='+config[0]])
    if len(config) > 1:
      arguments.extend(['/property:Platform='+config[1]])
    arguments.extend(['/property:BuildInParallel=false'])
    arguments.extend(['/verbosity:minimal'])

    kw['arguments'] = arguments
    return self.run(program=self.msbuild_path, **kw)


class TestGypXcode(TestGypBase):
  """
  Subclass for testing the GYP Xcode generator.
  """
  format = 'xcode'
  build_tool_list = ['xcodebuild']

  phase_script_execution = ("\n"
                            "PhaseScriptExecution /\\S+/Script-[0-9A-F]+\\.sh\n"
                            "    cd /\\S+\n"
                            "    /bin/sh -c /\\S+/Script-[0-9A-F]+\\.sh\n"
                            "(make: Nothing to be done for ['`]all'\\.\n)?")

  strip_up_to_date_expressions = [
    # Various actions or rules can run even when the overall build target
    # is up to date.  Strip those phases' GYP-generated output.
    re.compile(phase_script_execution, re.S),

    # The message from distcc_pump can trail the "BUILD SUCCEEDED"
    # message, so strip that, too.
    re.compile('__________Shutting down distcc-pump include server\n', re.S),
  ]

  up_to_date_endings = (
    'Checking Dependencies...\n** BUILD SUCCEEDED **\n', # Xcode 3.0/3.1
    'Check dependencies\n** BUILD SUCCEEDED **\n\n',     # Xcode 3.2
    'Check dependencies\n\n\n** BUILD SUCCEEDED **\n\n', # Xcode 4.2
    'Check dependencies\n\n** BUILD SUCCEEDED **\n\n',   # Xcode 5.0
  )

  def build(self, gyp_file, target=None, **kw):
    """
    Runs an xcodebuild using the .xcodeproj generated from the specified
    gyp_file.
    """
    # Be sure we're working with a copy of 'arguments' since we modify it.
    # The caller may not be expecting it to be modified.
    arguments = kw.get('arguments', [])[:]
    arguments.extend(['-project', gyp_file.replace('.gyp', '.xcodeproj')])
    if target == self.ALL:
      arguments.append('-alltargets',)
    elif target not in (None, self.DEFAULT):
      arguments.extend(['-target', target])
    if self.configuration:
      arguments.extend(['-configuration', self.configuration])
    symroot = kw.get('SYMROOT', '$SRCROOT/build')
    if symroot:
      arguments.append('SYMROOT='+symroot)
    kw['arguments'] = arguments

    # Work around spurious stderr output from Xcode 4, http://crbug.com/181012
    match = kw.pop('match', self.match)
    def match_filter_xcode(actual, expected):
      if actual:
        if not is_List(actual):
          actual = actual.split('\n')
        if not is_List(expected):
          expected = expected.split('\n')
        actual = [a for a in actual
                    if 'No recorder, buildTask: <Xcode3BuildTask:' not in a and
                       'Beginning test session' not in a and
                       'Writing diagnostic log' not in a and
                       'Logs/Test/' not in a]
      return match(actual, expected)
    kw['match'] = match_filter_xcode

    return self.run(program=self.build_tool, **kw)
  def up_to_date(self, gyp_file, target=None, **kw):
    """
    Verifies that a build of the specified Xcode target is up to date.
    """
    result = self.build(gyp_file, target, **kw)
    if not result:
      output = self.stdout()
      for expression in self.strip_up_to_date_expressions:
        output = expression.sub('', output)
      if not output.endswith(self.up_to_date_endings):
        self.report_not_up_to_date()
        self.fail_test()
    return result

  def built_file_path(self, name, type=None, **kw):
    """
    Returns a path to the specified file name, of the specified type,
    as built by Xcode.

    Built files are in the subdirectory 'build/{configuration}'.
    The default is 'build/Default'.

    A chdir= keyword argument specifies the source directory
    relative to which  the output subdirectory can be found.

    "type" values of STATIC_LIB or SHARED_LIB append the necessary
    prefixes and suffixes to a platform-independent library base name.
    """
    result = []
    chdir = kw.get('chdir')
    if chdir:
      result.append(chdir)
    configuration = self.configuration_dirname()
    result.extend(['build', configuration])
    result.append(self.built_file_basename(name, type, **kw))
    return self.workpath(*result)


class TestGypXcodeNinja(TestGypXcode):
  """
  Subclass for testing the GYP Xcode Ninja generator.
  """
  format = 'xcode-ninja'

  def initialize_build_tool(self):
    super(TestGypXcodeNinja, self).initialize_build_tool()
    # When using '--build', make sure ninja is first in the format list.
    self.formats.insert(0, 'ninja')

  def build(self, gyp_file, target=None, **kw):
    """
    Runs an xcodebuild using the .xcodeproj generated from the specified gyp_file.
    """
    build_config = self.configuration
    if build_config and build_config.endswith(('-iphoneos', '-iphonesimulator')):
      build_config, sdk = self.configuration.split('-')
      kw['arguments'] = kw.get('arguments', []) + ['-sdk', sdk]

    with self._build_configuration(build_config):
      return super(TestGypXcodeNinja, self).build(gyp_file.replace('.gyp', '.ninja.gyp'), target, **kw)

  @contextmanager
  def _build_configuration(self, build_config):
    config = self.configuration
    self.configuration = build_config
    try:
      yield
    finally:
      self.configuration = config

  def built_file_path(self, name, type=None, **kw):
    result = []
    chdir = kw.get('chdir')
    if chdir:
      result.append(chdir)
    result.append('out')
    result.append(self.configuration_dirname())
    subdir = kw.get('subdir')
    if subdir and type != self.SHARED_LIB:
      result.append(subdir)
    result.append(self.built_file_basename(name, type, **kw))
    return self.workpath(*result)

  def up_to_date(self, gyp_file, target=None, **kw):
    result = self.build(gyp_file, target, **kw)
    if not result:
      stdout = self.stdout()
      if 'ninja: no work to do' not in stdout:
        self.report_not_up_to_date()
        self.fail_test()
    return result


class TestGypMakeMock(TestGypMake):
  format = 'make-mock'
  build_tool_list = ['dir']
  ALL = 'all'

  def build(self, gyp_file, target=None, **kw):
    # noinspection PyAttributeOutsideInit
    self.stdout = lambda: self.skip_test('No stdout for mock tests')
    return True

  def built_file_must_match(self, name, contents, **kw):
    return True

  def run_built_executable(self, name, *args, **kw):
    # noinspection PyAttributeOutsideInit
    self.stdout = lambda: self.skip_test('No stdout for mock tests')
    return True

  def must_exist(self, *files):
    return True

  def built_file_must_exist(self, name, type=None, remove=False, **kw):
    return True

  def built_file_path(self, name, type=None, **kw):
    if not os.path.exists(name):
      self.skip_test("missing %s" % name)
    return super(TestGypMakeMock, self).built_file_path(name, type, **kw)

  def read(self, file, *args, **kwargs):
    if isinstance(file, list):
      file = os.path.join(*file)
    if not os.path.exists(file):
      self.skip_test("missing %s" % file)
    return super(TestGypMakeMock, self).read(file, *args, **kwargs)

  def initialize_build_tool(self):
    return


class TestGypNinjaMock(TestGypNinja):
  format = 'ninja-mock'
  build_tool_list = ['dir']
  ALL = 'all'

  def build(self, gyp_file, target=None, **kw):
    # noinspection PyAttributeOutsideInit
    self.stdout = lambda: self.skip_test('No stdout for mock tests')
    return True

  def built_file_must_match(self, name, contents, **kw):
    return True

  def run_built_executable(self, name, *args, **kw):
    # noinspection PyAttributeOutsideInit
    self.stdout = lambda: self.skip_test('No stdout for mock tests')
    return True

  def must_exist(self, *files):
    return True

  def built_file_must_exist(self, name, type=None, remove=False, **kw):
    return True

  def built_file_path(self, name, type=None, **kw):
    if not os.path.exists(name):
      self.skip_test("missing %s" % name)
    return super(TestGypNinjaMock, self).built_file_path(name, type, **kw)

  def read(self, file, *args, **kwargs):
    if isinstance(file, list):
      file = os.path.join(*file)
    if not os.path.exists(file):
      self.skip_test("missing %s" % file)
    return super(TestGypNinjaMock, self).read(file, *args, **kwargs)

  def initialize_build_tool(self):
    return


class TestGypMSVSMock(TestGypMSVS):
  format = 'msvs-mock'
  build_tool_list = ['dir']
  ALL = 'all'
  uses_msbuild = True

  def build(self, gyp_file, target=None, **kw):
    # noinspection PyAttributeOutsideInit
    self.stdout = lambda: self.skip_test('No stdout for mock tests')
    return True

  def built_file_must_match(self, name, contents, **kw):
    return True

  def run_built_executable(self, name, *args, **kw):
    # noinspection PyAttributeOutsideInit
    self.stdout = lambda: self.skip_test('No stdout for mock tests')
    return True

  def must_exist(self, *files):
    return True

  def built_file_must_exist(self, name, type=None, remove=False, **kw):
    return True

  def built_file_path(self, name, type=None, **kw):
    if not os.path.exists(name):
      self.skip_test("missing %s" % name)
    return super(TestGypMSVSMock, self).built_file_path(name, type, **kw)

  def read(self, file, *args, **kwargs):
    if isinstance(file, list):
      file = os.path.join(*file)
    if not os.path.exists(file):
      self.skip_test("missing %s" % file)
    return super(TestGypMSVSMock, self).read(file, *args, **kwargs)
  def run_dumpbin(self, *dumpbin_args):
    self.skip_test("skipping run_dumpbin")

  def initialize_build_tool(self):
    return


format_class_list = [
  TestGypGypd,
  TestGypCMake,
  TestGypMake,
  TestGypMakeMock,
  TestGypMSVS,
  TestGypMSVSMock,
  TestGypMSVSNinja,
  TestGypNinja,
  TestGypNinjaMock,
  TestGypXcode,
  TestGypXcodeNinja,
]

def TestGyp(**kw):
  """
  Returns an appropriate TestGyp* instance for a specified GYP format.
  """
  disable = kw.pop('disable', None)
  if disable:
    print("This test is currently disabled: https://crbug.com/483696.")
    sys.exit(2)
  platforms = kw.pop('platforms', None)
  if platforms:
    excluded_platforms = {f[1:] for f in platforms if f[0] == '!'}
    explicit_platforms = {f for f in platforms if f[0] != '!'}
    platform = sys.platform
    platform_mismatch = ''
    if platform in excluded_platforms:
      platform_mismatch = 'Test excluded for platform %s' % platform
    if platform not in explicit_platforms:
      platform_mismatch = 'Test not explicitly included for platforms %s' % platform
    if platform_mismatch:
      print(platform_mismatch)
      sys.exit(2)

  fmt = kw.pop('format', os.environ.get('TESTGYP_FORMAT'))
  for format_class in format_class_list:
    if fmt == format_class.format:
      return format_class(**kw)
  raise Exception("unknown format %r" % fmt)


def CheckFileType_macOS(test, file, archs):
  """Check that |file| contains exactly |archs| or fails |test|."""
  proc = subprocess.Popen(['lipo', '-info', file], stdout=subprocess.PIPE)
  o = proc.communicate()[0].decode('utf-8').strip()
  assert not proc.returncode
  if len(archs) == 1:
    pattern = re.compile('^Non-fat file: (.*) is architecture: (.*)$')
  else:
    pattern = re.compile('^Architectures in the fat file: (.*) are: (.*)$')
  match = pattern.match(o)
  if match is None:
    print('Output does not match expected pattern: %s' % pattern.pattern)
    test.fail_test()
  else:
    found_file, found_archs = match.groups()
    if found_file != file or set(found_archs.split()) != set(archs):
      print('Expected file %s with arch %s, got %s with arch %s' % (file, ' '.join(archs), found_file, found_archs))
      test.fail_test()
